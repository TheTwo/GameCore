---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wupei.
--- DateTime: 2020/9/3 11:25
---

---@class EntityNewData
---@field data wds.Troop | wds.MapMob
---@field entityPath table param of DBEntityPath
---

local AbstractManager = require("AbstractManager")
local DBEntityType = require('DBEntityType')
local DBEntityPath = require('DBEntityPath')
local MonsterClassType = require("MonsterClassType")
local Delegate = require('Delegate')
local TroopCtrl = require("TroopCtrl")
local BehemothTroopCtrl = require("BehemothTroopCtrl")
local BuildingTroopCtrl = require('BuildingTroopCtrl')
local KBuildingTroopCtrl = require('KBuildingTroopCtrl')
local ModuleRefer = require('ModuleRefer')
local EventConst = require('EventConst')
local ConfigRefer = require('ConfigRefer')
local SLGConfig = require('SlgLocalConfig')
local TroopConst = require('TroopConst')
local SlgUtils = require('SlgUtils')
local TimelineGameEventDefine = require("TimelineGameEventDefine")
local KingdomMapUtils = require('KingdomMapUtils')
local I18N = require("I18N")
local MapUtils = CS.Grid.MapUtils
local VisibleType = require('VisibleType')
local CheckTroopTrusteeshipStateDefine = require("CheckTroopTrusteeshipStateDefine")
local HeroPetFormation = require("HeroPetFormation")
local BehemothFormation = require("BehemothFormation")
local RallyFormation = require("RallyFormation")
local ProtocolId = require("ProtocolId")
local HUDTroopUtils = require("HUDTroopUtils")

---@class TroopManager : AbstractManager
---@field _ftManager CS.SEFloatingTextManager
---@field _minLod number
---@field _maxLod number
---@field dirtyHUD TroopHUD[]
local TroopManager = class('TroopManager',AbstractManager)

local EnterSimpleModeLimit = 100
local ExitSimpleModeLimit = 80

function TroopManager:ctor(...)
    AbstractManager.ctor(self, ...)
    self.unitLayerMask = CS.UnityEngine.LayerMask.NameToLayer('Character')
    self:Init()
end

function TroopManager:Init()
    self._editModule = ModuleRefer.TroopEditModule
    ---@type CS.DragonReborn.Performance.DeviceLevel
    self._performanceLevel = (g_Game.PerformanceLevelManager:GetDeviceLevel() == CS.DragonReborn.Performance.DeviceLevel.High) and 0 or 1
    ---@type table<number, TroopCtrl>
    self._troops = {}
    self._troopCount = 0
    self._playerTroopCount = 0;
    self._simpleMode = false
    ---@type table<number,BuildingTroopCtrl | KBuildingTroopCtrl>
    self._buildings = {}
    self._buildingView = {}
    self._furnitureView = {}
    self._wallView = {}
    self._elementView = {}
    self._troopParent = CS.UnityEngine.GameObject("TroopHolder").transform
    self._troopParent:SetParent(self._module.worldHolder, false)
    self._monsterParent = CS.UnityEngine.GameObject("MonsterHolder").transform
    self._monsterParent:SetParent(self._module.worldHolder, false)

	self._presetLastBackToCityStatus = {}

    ---@type table<number,EntityNewData>
    self._entityWillNew = {}
    self._willNewCount = 0
    self._willNewCreateMax = 20
    self._timelineHideTroop = false

    ---@type table<number, TroopCtrl>
    self._myTroops = {}

    local maxLod = self._curScene.cameraLodData:GetLodCount()
    self._minLod = math.min( SLGConfig.TroopMinLod,maxLod)
    self._maxLod = math.min( SLGConfig.TroopMaxLod, maxLod)
    if self._minLod >= self._maxLod then
        self._minLod = self._maxLod
    end

    self._minCamSize = self._curScene.cameraLodData:GetLodSizeThreshold(self._minLod - 1)
    self._maxCamSize = self._curScene.cameraLodData:GetLodSizeThreshold(self._maxLod)
end

function TroopManager:GetMyTroopCtrlMap()
    return self._myTroops
end

---@return TroopCtrl
function TroopManager:GetMyTroopCtrlOne()
    for i, v in pairs(self._myTroops) do
        return v
    end
    return nil
end

function TroopManager:IsMyExistingTroopId(troopId)
    return self._myTroops[troopId] ~= nil
end
function TroopManager:Awake()
    ------------------------------
    --Troop Entity wds.Troop | wds.MapMob | wds.MobileFortress | wds.SlgPuppet | wds.MapBuilding
    g_Game.DatabaseManager:AddEntityNewByType(DBEntityType.Troop,Delegate.GetOrCreate(self,self.OnTroopCreated))
    g_Game.DatabaseManager:AddEntityDestroyByType(DBEntityType.Troop,Delegate.GetOrCreate(self,self.OnTroopDeleted))

    g_Game.DatabaseManager:AddEntityNewByType(DBEntityType.MapMob,Delegate.GetOrCreate(self,self.OnMobCreate))
    g_Game.DatabaseManager:AddEntityDestroyByType(DBEntityType.MapMob,Delegate.GetOrCreate(self,self.OnMobDestroy))

    g_Game.DatabaseManager:AddEntityNewByType(DBEntityType.MobileFortress,Delegate.GetOrCreate(self,self.OnMobileFortressCreate))
    g_Game.DatabaseManager:AddEntityDestroyByType(DBEntityType.MobileFortress,Delegate.GetOrCreate(self,self.OnMobileFortressDestroy))

    g_Game.DatabaseManager:AddEntityNewByType(DBEntityType.SlgPuppet,Delegate.GetOrCreate(self,self.OnPuppetCreate))
    g_Game.DatabaseManager:AddEntityDestroyByType(DBEntityType.SlgPuppet,Delegate.GetOrCreate(self,self.OnPupperDestroy))

    g_Game.DatabaseManager:AddEntityNewByType(DBEntityType.MapBuilding,Delegate.GetOrCreate(self,self.OnBuildingCreated))
    g_Game.DatabaseManager:AddEntityDestroyByType(DBEntityType.MapBuilding,Delegate.GetOrCreate(self,self.OnBuildingDestroy))

    g_Game.DatabaseManager:AddEntityNewByType(DBEntityType.DefenceTower,Delegate.GetOrCreate(self,self.OnDefenceTowerCreated))
    g_Game.DatabaseManager:AddEntityDestroyByType(DBEntityType.DefenceTower,Delegate.GetOrCreate(self,self.OnDefenceTowerDestroy))

    g_Game.DatabaseManager:AddEntityNewByType(DBEntityType.TroopChariot,Delegate.GetOrCreate(self,self.OnTroopChariotCreated))
    g_Game.DatabaseManager:AddEntityDestroyByType(DBEntityType.TroopChariot,Delegate.GetOrCreate(self,self.OnTroopChariotDestroy))

    g_Game.DatabaseManager:AddChanged(DBEntityPath.CastleBrief.TroopPresets.MsgPath,Delegate.GetOrCreate(self,self.OnPresetDataChanged))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.Troop.Battle.Group.MsgPath,Delegate.GetOrCreate(self,self.OnTroopGroupDataChanged))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.TroopChariot.MapStates.HideOnMap.MsgPath, Delegate.GetOrCreate(self,self.OnTroopChariotHideOnMapChange))

    g_Game.EventManager:AddListener(EventConst.STORY_TIMELINE_GAME_EVENT_START, Delegate.GetOrCreate(self, self.OnStoryTimelineGameEventStart))
    g_Game.EventManager:AddListener(EventConst.STORY_TIMELINE_GAME_EVENT_END, Delegate.GetOrCreate(self, self.OnStoryTimelineGameEventEnd))

    g_Game.ServiceManager:AddResponseCallback(ProtocolId.PushEntityJump, Delegate.GetOrCreate(self, self.OnEntityJump))

    --更新自己的TroopCtrl
    -- self:UpdateTroopCache()
    -- self:UpdateMyTroopCtrl()
end

function TroopManager:OnDestroy()
    self:DestroyAllEntity()
    ------------------------------
    --Troop Entity wds.Troop | wds.MapMob | wds.MobileFortress | wds.SlgPuppet | wds.MapBuilding
    g_Game.DatabaseManager:RemoveEntityNewByType(DBEntityType.Troop,Delegate.GetOrCreate(self,self.OnTroopCreated))
    g_Game.DatabaseManager:RemoveEntityDestroyByType(DBEntityType.Troop,Delegate.GetOrCreate(self,self.OnTroopDeleted))

    g_Game.DatabaseManager:RemoveEntityNewByType(DBEntityType.MapMob,Delegate.GetOrCreate(self,self.OnMobCreate))
    g_Game.DatabaseManager:RemoveEntityDestroyByType(DBEntityType.MapMob,Delegate.GetOrCreate(self,self.OnMobDestroy))

    g_Game.DatabaseManager:RemoveEntityNewByType(DBEntityType.MobileFortress,Delegate.GetOrCreate(self,self.OnMobileFortressCreate))
    g_Game.DatabaseManager:RemoveEntityDestroyByType(DBEntityType.MobileFortress,Delegate.GetOrCreate(self,self.OnMobileFortressDestroy))

    g_Game.DatabaseManager:RemoveEntityNewByType(DBEntityType.SlgPuppet,Delegate.GetOrCreate(self,self.OnPuppetCreate))
    g_Game.DatabaseManager:RemoveEntityDestroyByType(DBEntityType.SlgPuppet,Delegate.GetOrCreate(self,self.OnPupperDestroy))

    g_Game.DatabaseManager:RemoveEntityNewByType(DBEntityType.MapBuilding,Delegate.GetOrCreate(self,self.OnBuildingCreated))
    g_Game.DatabaseManager:RemoveEntityDestroyByType(DBEntityType.MapBuilding,Delegate.GetOrCreate(self,self.OnBuildingDestroy))

    g_Game.DatabaseManager:RemoveEntityNewByType(DBEntityType.DefenceTower,Delegate.GetOrCreate(self,self.OnDefenceTowerCreated))
    g_Game.DatabaseManager:RemoveEntityDestroyByType(DBEntityType.DefenceTower,Delegate.GetOrCreate(self,self.OnDefenceTowerDestroy))

    g_Game.DatabaseManager:RemoveEntityNewByType(DBEntityType.TroopChariot,Delegate.GetOrCreate(self,self.OnTroopChariotCreated))
    g_Game.DatabaseManager:RemoveEntityDestroyByType(DBEntityType.TroopChariot,Delegate.GetOrCreate(self,self.OnTroopChariotDestroy))

    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.CastleBrief.TroopPresets.MsgPath,Delegate.GetOrCreate(self,self.OnPresetDataChanged))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Troop.Battle.Group.MsgPath,Delegate.GetOrCreate(self,self.OnTroopGroupDataChanged))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.TroopChariot.MapStates.HideOnMap.MsgPath, Delegate.GetOrCreate(self,self.OnTroopChariotHideOnMapChange))

    g_Game.EventManager:RemoveListener(EventConst.STORY_TIMELINE_GAME_EVENT_START, Delegate.GetOrCreate(self, self.OnStoryTimelineGameEventStart))
    g_Game.EventManager:RemoveListener(EventConst.STORY_TIMELINE_GAME_EVENT_END, Delegate.GetOrCreate(self, self.OnStoryTimelineGameEventEnd))

    g_Game.ServiceManager:RemoveResponseCallback(ProtocolId.PushEntityJump, Delegate.GetOrCreate(self, self.OnEntityJump))

    self._entityWillNew = {}
    self._willNewCount = 0
    if self.dirtyHUD then
        table.clear(self.dirtyHUD)
    end
end


---@param dbEntityPath table @from DBEntityPath
function TroopManager:AddTroopDBChanged(dbEntityPath)
    if not dbEntityPath then return end
    ---@class TroopDBTypeCache
    ---@field DBEntityPath table
    ---@field RefCount number
    if not self._troopDBTypeCache then
        ---@type table<string,TroopDBTypeCache>
        self._troopDBTypeCache = {}
    end
    ---@type string
    local msgPath = dbEntityPath.MsgPath
    if not self._troopDBTypeCache[msgPath] then
        self._troopDBTypeCache[msgPath] = {DBEntityPath = dbEntityPath, RefCount = 1}
        g_Game.DatabaseManager:AddChanged(dbEntityPath.MovePathInfo.MsgPath,Delegate.GetOrCreate(self,self.OnTroopMovePathInfoChanged), 1)
        g_Game.DatabaseManager:AddChanged(dbEntityPath.Battle.MsgPath, Delegate.GetOrCreate(self,self.OnBattleChanged))
        g_Game.DatabaseManager:AddChanged(dbEntityPath.MapStates.MsgPath, Delegate.GetOrCreate(self,self.OnMapStateChanged))
        g_Game.DatabaseManager:AddChanged(dbEntityPath.MapBasics.MsgPath, Delegate.GetOrCreate(self,self.OnMapBasicsChanged))
        g_Game.DatabaseManager:AddChanged(dbEntityPath.Skill.SlgBuffs.MsgPath,Delegate.GetOrCreate(self,self.OnBuffChanged))

        if dbEntityPath.TrusteeshipTargetInfo then
            g_Game.DatabaseManager:AddChanged(dbEntityPath.TrusteeshipTargetInfo.MsgPath, Delegate.GetOrCreate(self,self.OnTrusteeshipTargetInfoChanged))
        end
    else
        self._troopDBTypeCache[msgPath].RefCount = self._troopDBTypeCache[msgPath].RefCount + 1
    end
end

---@param dbEntityPath table @from DBEntityPath
function TroopManager:RemoveTroopDBChanged(dbEntityPath)
    if not dbEntityPath then return end
    ---@type string
    local msgPath = dbEntityPath.MsgPath
    if not self._troopDBTypeCache[msgPath] then return end
    self._troopDBTypeCache[msgPath].RefCount = self._troopDBTypeCache[msgPath].RefCount - 1
    if self._troopDBTypeCache[msgPath].RefCount <= 0 then
        self._troopDBTypeCache[msgPath] = nil
        g_Game.DatabaseManager:RemoveChanged(dbEntityPath.MovePathInfo.MsgPath,Delegate.GetOrCreate(self,self.OnTroopMovePathInfoChanged))
        g_Game.DatabaseManager:RemoveChanged(dbEntityPath.Battle.MsgPath, Delegate.GetOrCreate(self,self.OnBattleChanged))
        g_Game.DatabaseManager:RemoveChanged(dbEntityPath.MapStates.MsgPath, Delegate.GetOrCreate(self,self.OnMapStateChanged))
        g_Game.DatabaseManager:RemoveChanged(dbEntityPath.MapBasics.MsgPath, Delegate.GetOrCreate(self,self.OnMapBasicsChanged))
        g_Game.DatabaseManager:RemoveChanged(dbEntityPath.Skill.SlgBuffs.MsgPath,Delegate.GetOrCreate(self,self.OnBuffChanged))

        if dbEntityPath.TrusteeshipTargetInfo then
            g_Game.DatabaseManager:RemoveChanged(dbEntityPath.TrusteeshipTargetInfo.MsgPath, Delegate.GetOrCreate(self,self.OnTrusteeshipTargetInfoChanged))
        end
    end

end

---region DBDataChange Distributors
---@param data wds.Troop | wds.MapMob | wds.MobileFortress
function TroopManager:OnTroopMovePathInfoChanged(data,change)
    local ctrl = self:FindTroopCtrl(data.ID)
    if not ctrl then
        ctrl = self:FindBuildingCtrl(data.ID)
    end

    if ctrl and ctrl:IsValid() then
        ctrl:OnMovePathInfoChanged(data,change)
    end
end

---@param change wds.Battle
function TroopManager:OnBattleChanged(data,change)
    local ctrl = self:FindTroopCtrl(data.ID)
    if not ctrl then
        ctrl = self:FindBuildingCtrl(data.ID)
    end
    
    if ctrl and ctrl:IsValid() then
        ctrl:OnBattleChanged(data,change)
    end

    if change then
        self._module.battleManager:CacheTroopBattleState(data.ID,change)
    end
end

function TroopManager:OnMapStateChanged(data,change)
    local ctrl = self:FindTroopCtrl(data.ID)
    if not ctrl then
        ctrl = self:FindBuildingCtrl(data.ID)
    end
    
    if ctrl and ctrl:IsValid()  then
        ctrl:OnMapStateChanged(data,change)
    end
end

function TroopManager:OnTrusteeshipTargetInfoChanged(data, change)
    local ctrl = self:GetCtrl(data.ID)
    if ctrl then
        ctrl:OnTrusteeshipTargetInfoChanged(data,change)
    end
end

---@param data wds.Troop | wds.MapMob | wds.MobileFortress
function TroopManager:OnMapBasicsChanged(data,change)
    local ctrl = self:FindTroopCtrl(data.ID)
    if not ctrl then
        ctrl = self:FindBuildingCtrl(data.ID)
    end
    if ctrl and ctrl:IsValid()  then
        ctrl:OnMapBasicsChanged(data,change)
    end
end

function TroopManager:OnBuffChanged(data,change)
    local ctrl = self:FindTroopCtrl(data.ID)
    if ctrl and ctrl:IsValid()  then
        ctrl:OnBuffChanged(data,change)
    end
end

function TroopManager:OnTroopGroupChanged(data,change)

end

--region DBListener
--Create a New TroopEntity
---@param troop wds.Troop
---@param dbEntityPath table param of DBEntityPath
---@param priority number
function TroopManager:EnqueueNewTroop(troop,dbEntityPath, priority)
    if troop == nil then
        return
    end

    if priority <= 0 and self._module:IsRunning() then
        self:CreateTroopCtrl(troop,dbEntityPath)
    else
        if self._entityWillNew[troop.ID] == nil then
            self._entityWillNew[troop.ID]={data = troop, entityPath = dbEntityPath}
            self._willNewCount = self._willNewCount + 1
        end
    end
end

---@param troopId number
function TroopManager:DestroyTroopCtrl(troopId)
    local ctrl = self._troops[troopId]
    if ctrl then
        ctrl:ReleaseTroopCtrl()
        self:RemoveTroopDBChanged(ctrl._dbEntityPath)
    
        g_Game.EventManager:TriggerEvent(EventConst.ON_TROOP_DESTROYED, ctrl.ID, ctrl.troopType)
    
        if self._myTroops[troopId] then
            self._myTroops[troopId] = nil
        end
    
        self._troops[troopId] = nil
        self._troopCount = self._troopCount - 1
        self:OnTroopCountChanged()
    else
        if self._entityWillNew[troopId] then
            self._entityWillNew[troopId] = nil
            self._willNewCount = self._willNewCount - 1
        end
    end
end

function TroopManager:TickEntityWillNew()
    if self._willNewCount > 0 then
        local createdIndex = 1
        local createdKeys = {}
        local createdDatas = {}
        for key, value in pairs(self._entityWillNew) do
            createdKeys[createdIndex] = key
            createdDatas[createdIndex] = value
            createdIndex = createdIndex + 1
            if createdIndex >= self._willNewCreateMax then
                break
            end
        end
        for i = 1, createdIndex-1 do
            self._entityWillNew[createdKeys[i]] = nil
            self._willNewCount = self._willNewCount - 1
            self:CreateTroopCtrl(createdDatas[i].data,createdDatas[i].entityPath)
        end
    end
end

---@param fortress wds.MobileFortress
function TroopManager:OnMobileFortressCreate(typeHash,fortress)
    if fortress == nil then return end
    if ModuleRefer.PlayerModule:IsFriendly(fortress.Owner) then
        self:UpdateMyMobileFortress()
    else
        self:EnqueueNewTroop(fortress, DBEntityPath.MobileFortress,0)
    end
end

---@param fortress wds.MobileFortress
function TroopManager:OnMobileFortressDestroy(typeHash,fortress)
    if fortress == nil then return end
    if ModuleRefer.PlayerModule:IsFriendly(fortress.Owner) then
        self:DestroyTroopCtrl(fortress.ID)
        self:UpdateMyMobileFortress()
    else
        self:DestroyTroopCtrl(fortress.ID)
    end
end

---@param troop wds.MapMob
function TroopManager:OnMobCreate(type,mob)   
    self:EnqueueNewTroop(mob, DBEntityPath.MapMob,3)
end

---@param mob wds.MapMob
function TroopManager:OnMobDestroy(type,mob)
    self:DestroyTroopCtrl(mob.ID)
    if mob and mob.Battle.Hp < 1 then
        g_Game.EventManager:TriggerEvent(EventConst.ON_SLG_MONSTER_DEAD, mob.MobInfo.MobID)
    end
end

---@param troop wds.SlgPuppet
function TroopManager:OnPuppetCreate(type,mob)
    self:EnqueueNewTroop(mob, DBEntityPath.SlgPuppet,0,true)
end

function TroopManager:OnPupperDestroy(type,mob)
    self:DestroyTroopCtrl(mob.ID)
end
--endregion

---@return number
function TroopManager:GetMinMaxLod()
    return self._minLod,self._maxLod
end

---@return number,number
function TroopManager:GetCamSizeRange()
    return self._minCamSize,self._maxCamSize
end

function TroopManager:OnLodChange(lod, oldLod)
    -- if lod >= self._minLod and lod <= self._maxLod then
        for k, v in pairs(self._troops) do
            v:DoOnLodChange(lod, oldLod)
        end
    -- end
end

function TroopManager:OnCamSizeChange(size, oldSize)
    for k, v in pairs(self._troops) do
        v:DoOnCamSizeChange(size, oldSize)
    end
end

function TroopManager:Update()

end

function TroopManager:FindTroopCtrl(id)
    if self._troops and id and id > 0 then
        return self._troops[id]
    end
    return nil
end

function TroopManager:GetTroopCtrlCount()
    return self._troopCount
end

function TroopManager:FindBuildingCtrl(id)
    if self._buildings then
        return self._buildings[id]
    end
    return nil
end

function TroopManager:GetCtrl(id)
    local entity = SlgUtils.GetEntityById(id)
    if entity == nil then
        return nil
    end

    --考虑集结的情况
    if SlgUtils.IsTroopInRally(entity) then
        return self:FindTroopCtrl(entity.TrusteeshipInfo.TroopChariotId)
    end

    --尝试查询行军
    local ctrl = self:FindTroopCtrl(id)
    if ctrl ~= nil then
        return ctrl
    end

    return self:FindBuildingCtrl(id)
end

function TroopManager:FindNearestMob(ctrls)
    local castle = ModuleRefer.PlayerModule:GetCastle()
    local pos = castle.MapBasics.Position
    local worldPosition = MapUtils.CalculateCoordToTerrainPosition(pos.X, pos.Y, KingdomMapUtils.GetMapSystem())

    local nearestLength = math.maxinteger
    local nearestCtrl = nil
    for _, mobCtrl in ipairs(ctrls) do
        local position = mobCtrl:GetPosition()
        if not nearestCtrl then
            nearestCtrl = mobCtrl
            nearestLength = math.abs(position.x - worldPosition.x) + math.abs(position.y - worldPosition.y)
        else
            local length = math.abs(position.x - worldPosition.x) + math.abs(position.y - worldPosition.y)
            if length < nearestLength then
                nearestCtrl = mobCtrl
                nearestLength = length
            end
        end
    end
    return nearestCtrl
end

---@param mobId number @KmonsterDataConfigCell:Id()
function TroopManager:FindMobCtrl(mobId)
    if not self._troops then return nil end
    local ctrls = {}

    for key, value in pairs(self._troops) do
        if value:IsMonster() and value._data and value._data.MobInfo
            and value._data.MobInfo.MobID == mobId 
        then
            local fogUnloked = true
            if not self._module:IsInCity() then
                fogUnloked = ModuleRefer.MapFogModule:IsFogUnlocked(value._data.MapBasics.Position.X, value._data.MapBasics.Position.Y)
            end
            if fogUnloked then
                ctrls[#ctrls + 1] = value
            end
        end
    end
    local ownerCtrl = nil
    for _, ctrl in ipairs(ctrls) do
        if ctrl._data.Owner.ExclusivePlayerId == ModuleRefer.PlayerModule:GetPlayerId() then
            ownerCtrl = ctrl
            break
        end
    end
    return ownerCtrl ~= nil and ownerCtrl or self:FindNearestMob(ctrls)
end

---@param mobId number @KmonsterDataConfigCell:Level()
function TroopManager:FindLvMobCtrl(level, isElite, searchDistance)
    if not self._troops then return nil end
    local ctrls = {}
    local worldPosition
    if searchDistance and searchDistance > 0 then
        local castle = ModuleRefer.PlayerModule:GetCastle()
        local pos = castle.MapBasics.Position
        worldPosition = MapUtils.CalculateCoordToTerrainPosition(pos.X, pos.Y, KingdomMapUtils.GetMapSystem())
    end
    for _, value in pairs(self._troops) do
        if value:IsMonster() and value._data and value._data.MobInfo then
            local config = ConfigRefer.KmonsterData:Find(value._data.MobInfo.MobID)
            
            local fogUnlocked = true
            if not self._module:IsInCity() then
                fogUnlocked = ModuleRefer.MapFogModule:IsFogUnlocked(value._data.MapBasics.Position.X, value._data.MapBasics.Position.Y)
            end

            local tileX, tileZ = KingdomMapUtils.ParseBuildingPos(value._data.MapBasics.Position)
            if config and config:Level() == level and fogUnlocked
              and ModuleRefer.WorldSearchModule:CheckIsInSearchList(level, isElite, value._data.MobInfo.MobID)
              and ModuleRefer.LandformModule:IsLandUnlock(tileX, tileZ) then
                if config:MonsterClass() == MonsterClassType.Normal and not isElite then
                    if searchDistance and searchDistance > 0 then
                        local position = value:GetPosition()
                        local x = math.abs(position.x - worldPosition.x)
                        local y =  math.abs(position.y - worldPosition.y)
                        local length = x * x + y * y
                        if length <= (searchDistance * searchDistance) then
                            ctrls[#ctrls + 1] = value
                        end
                    else
                        ctrls[#ctrls + 1] = value
                    end
                elseif isElite and config:MonsterClass() == MonsterClassType.Elite then
                    if searchDistance and searchDistance > 0 then
                        local position = value:GetPosition()
                        local x = math.abs(position.x - worldPosition.x)
                        local y =  math.abs(position.y - worldPosition.y)
                        local length = x * x + y * y
                        if length <= (searchDistance * searchDistance) then
                            ctrls[#ctrls + 1] = value
                        end
                    else
                        ctrls[#ctrls + 1] = value
                    end
                end
            end
        end
    end
    local ownerCtrl = nil
    for _, ctrl in ipairs(ctrls) do
        if ctrl._data.Owner.ExclusivePlayerId == ModuleRefer.PlayerModule:GetPlayerId() then
            ownerCtrl = ctrl
            break
        end
    end
    return ownerCtrl ~= nil and ownerCtrl or self:FindNearestMob(ctrls)
end

---@class TroopInfo
---@field preset wds.TroopPreset
---@field troopId number
---@field entityData wds.Troop
---@field locked boolean

---@param forceUpdate boolean
---@return table<number,TroopInfo>,TroopInfo[]
function TroopManager:GetMyTroops(forceUpdate)
    if not self.myTroops or forceUpdate then
        self:UpdateTroopCache()
    end
   return self.myTroops,self.gmTroops
end

function TroopManager:GetMyMobileFortress()
    if not self.myMobileFortress then
        self:UpdateMobileFortressCache()
    end
    return self.myMobileFortress
end

---@param troopInfo TroopInfo
---@return boolean
function TroopManager:IsTroopIdle(troopInfo)
    if not troopInfo then return false end

    if not troopInfo.entityData and HUDTroopUtils.DoesPresetHaveAnyHero(troopInfo.preset) then
        return true
    end
    if not SlgUtils.IsTroopSelectable(troopInfo.entityData) then
        return false
    end
    if troopInfo.entityData
        and not troopInfo.entityData.MapStates.Battling
        and not SlgUtils.IsTroopHideOnMap(troopInfo.entityData)
        and not troopInfo.entityData.MapStates.Gathering
        and not troopInfo.entityData.MapStates.Dying
    then
        return true
    end

    return false
end

---@param troopInfo TroopInfo
---@return boolean
function TroopManager:HasInjuredUnit(troopInfo)
    if not troopInfo or (not troopInfo.preset and not troopInfo.entityData) then return false end    
    if SlgUtils.PresetAllHeroInjured(troopInfo.preset,self._module.battleMinHpPct) then
        return true
    end
    return false
end

---@param troopInfo TroopInfo
---@return boolean
function TroopManager:IsTroopCanFreeFight(troopInfo)
    if not troopInfo or (not troopInfo.preset and not troopInfo.entityData) then return false end
    
    if  troopInfo.preset
        and troopInfo.preset.Status ~= wds.TroopPresetStatus.TroopPresetIdle
        and troopInfo.preset.Status ~= wds.TroopPresetStatus.TroopPresetInBigWorld
        and troopInfo.preset.Status ~= wds.TroopPresetStatus.TroopPresetInHome
        and not HUDTroopUtils.DoesPresetHaveAnyHero(troopInfo.preset)
    then
        return false
    end

    if self:HasInjuredUnit(troopInfo) then
        return false
    end

    if troopInfo.entityData
        and (
            troopInfo.entityData.MapStates.Dying
            or troopInfo.entityData.MapStates.Retreating
            or SlgUtils.IsTroopHideOnMap(troopInfo.entityData)
        )
    then
        return false
    end

    return true
end

---@param troop wds.Troop
function TroopManager:OnTroopCreated(type,troop)
    if troop == nil then
        return
    end

    self:SetPlayerTroopCount(self._playerTroopCount + 1)

    if SlgUtils.IsTroopInRally(troop) then
        local ctrl = self._module:GetCtrl(troop.ID)
        if ctrl and ctrl:IsValid() then
            ctrl:RebuildTroopView()
        end
    end

    if self._module:IsMyTroop(troop) and self._module:IsRunning() then
        self:UpdateMyTroopCtrl()
    else
        self:EnqueueNewTroop(troop, DBEntityPath.Troop,2)
    end
end

function TroopManager:OnTroopDeleted(type,troop)
    if troop == nil then
        return
    end

    self:SetPlayerTroopCount(self._playerTroopCount - 1)

    if self._module:IsMyTroop(troop) then
        self:DestroyTroopCtrl(troop.ID)
        self:UpdateMyTroopCtrl()
    else
        self:DestroyTroopCtrl(troop.ID)
    end
end

function TroopManager:InSimpleMode()
    return self._simpleMode
end

function TroopManager:SetPlayerTroopCount(playerTroopCount)
    local modeChanged = false

    if self._simpleMode then
        local exitSimpleMode = playerTroopCount <= ExitSimpleModeLimit
        if exitSimpleMode then
            self._simpleMode = false
            modeChanged = true
        end
    else
        local enterSimpleMode = playerTroopCount > EnterSimpleModeLimit
        if enterSimpleMode then
            self._simpleMode = true
            modeChanged = true
        end
    end

    self._playerTroopCount = playerTroopCount

    if modeChanged then
        self:OnSimpleModeChange()
    end
end

function TroopManager:OnSimpleModeChange()
    g_Game.EventManager:TriggerEvent(EventConst.TROOP_SIMPLE_MODE_CHANGE, self:InSimpleMode())

    for _, ctrl in pairs(self._troops) do
        if ctrl:IsValid() and ctrl:ShouldBeAffectedBySimpleMode() then
            ctrl:RebuildTroopView()
        end
    end
end

---@param data wds.CastleBrief
---@param changed wds.TroopPresets
function TroopManager:OnPresetDataChanged(data,changed)
    if data ~= ModuleRefer.PlayerModule:GetCastle() then return end

    if changed then

		-- 回城提示
		if (changed.Presets) then
			for i, preset in ipairs(changed.Presets) do
				if (self._presetLastBackToCityStatus[i] == nil) then
					self._presetLastBackToCityStatus[i] = false
				end
				local backToCity = preset.BasicInfo and preset.BasicInfo.BackToCity

				-- 回城
				if (backToCity and not self._presetLastBackToCityStatus[i]) then
					-- ModuleRefer.ToastModule:AddSimpleToast(I18N.Get("troop_status_5"))
				end

				-- 停止回城
				if (not backToCity and self._presetLastBackToCityStatus[i]) then
                    -- ModuleRefer.ToastModule:AddSimpleToast(I18N.Get("[*]收到指令，部队停止回城"))
				end

				self._presetLastBackToCityStatus[i] = backToCity

			end
		end
        self:UpdateTroopCache()
    end
end

---@param data1 table<number, wds.PetDataView> | MapField
---@param data2 table<number, wds.PetDataView> | MapField
---@return boolean
function TroopManager:CompareTroopPetsData(data1,data2)
    if not data1 and not data2 then return true end
    if data1 and not data2 then return false end
    if not data1 and data2 then return false end
    if data1:Count() ~= data2:Count() then return false end

    for key, value in pairs(data1) do
        if not data2[key] then
            return false
        end
        if data2[key].PetID ~= value.PetID then
            return false
        end
    end
    return true
end

---@param data wds.Troop
---@param changed wds.Group
function TroopManager:OnTroopGroupDataChanged(data, changed)
    if changed.Heros and SlgUtils.IsTroopSelectable(data) then
        local hasViewChanged = false
        if (changed.Heros.Add and not changed.Heros.Remove) or (not changed.Heros.Add and changed.Heros.Remove) then
           hasViewChanged = true
        end

        if not hasViewChanged and changed.Heros.Add then
            for key, value in pairs(changed.Heros.Add) do
                if not changed.Heros.Remove[key] then
                    hasViewChanged = true
                    break
                elseif changed.Heros.Remove[key].HeroID ~= value.HeroID then
                    hasViewChanged = true
                    break
                elseif not self:CompareTroopPetsData(changed.Heros.Remove[key].Pets,value.Pets) then
                    hasViewChanged = true
                    break
                end
            end
        end

        if hasViewChanged then
            local chariotId = data.TrusteeshipInfo.TroopChariotId
            if chariotId > 0 then -- 集结战车
                local troopCtrl = self:FindTroopCtrl(chariotId)
                if troopCtrl then
                    troopCtrl:RebuildTroopView()
                end
            else -- 普通行军
                local troopCtrl = self:FindTroopCtrl(data.ID)
                if troopCtrl and data then
                    troopCtrl:RebuildTroopView()
                end
            end
        end
    end

end

---@param editModule TroopEditModule
---@param slgModule SlgModule|SlgInterfaceModule
---@return table<number,TroopInfo>
function TroopManager.BuildTroopCache(editModule, slgModule)
    ---@type table<number,TroopInfo>
    local myTroops = {}
    local presetsData = ModuleRefer.PlayerModule:GetCastle().TroopPresets

    local troopCount = presetsData.Presets:Count()
    local unlockPresetCount, maxPresetCount  = editModule:GetMaxPresetCount()

    for i = 1, maxPresetCount do
        ---@type TroopInfo
        myTroops[i] = {}
        if i <= troopCount then 
            myTroops[i].preset = presetsData.Presets[i]
            if presetsData.Presets[i] then

                local troopId = presetsData.Presets[i].TroopId
                if troopId and troopId > 0 then
                    myTroops[i].entityData = g_Game.DatabaseManager:GetEntity(troopId,DBEntityType.Troop)
                    myTroops[i].troopId = troopId
                end

                if not myTroops[i].entityData then
                    troopId = presetsData.Presets[i].CopyTroopId
                    if troopId and troopId > 0 then
                        myTroops[i].entityData = g_Game.DatabaseManager:GetEntity(troopId,DBEntityType.Troop)
                        myTroops[i].troopId = troopId
                    end
                end
            end
        end
        myTroops[i].locked = (i > unlockPresetCount)
    end

    --Get GM troops
    -- Get Troop Create by GM Cmd
    ---@type TroopInfo[]
    local gmTroops = {}
    ---@type wds.Troop[]
    local troops = g_Game.DatabaseManager:GetEntitiesByType(DBEntityType.Troop)
    for _, troop in pairs(troops) do
        if slgModule:IsMyTroop(troop) then
            local hasPreset = false
            for __, value in pairs(myTroops) do
                if value.entityData and value.entityData.ID == troop.ID then
                    hasPreset = true
                    break
                end
            end
            if not hasPreset then
                ---@type TroopInfo
                local troopInfo  = {}
                troopInfo.preset = nil
                troopInfo.entityData = troop
                troopInfo.locked = false
                table.insert(gmTroops, troopInfo)
            end
        end
    end
    return myTroops, gmTroops
end

function TroopManager:UpdateTroopCache()
    self.myTroops, self.gmTroops = TroopManager.BuildTroopCache(self._editModule, self._module)
end

function TroopManager:OnStoryTimelineGameEventStart(args)
    if args[1] == TimelineGameEventDefine.HIDE_SLG_TROOP then
        self._timelineHideTroop = true
        for _, v in pairs(self._troops) do
            local view = v:GetTroopView()
            if view then
                view:SetVisible(false, true)
            end
        end
    end
end

function TroopManager:OnStoryTimelineGameEventEnd(args)
    if args[1] == TimelineGameEventDefine.HIDE_SLG_TROOP then
        self._timelineHideTroop = false
        for _, v in pairs(self._troops) do
            local view = v:GetTroopView()
            if view then
                view:SetVisible(true)
            end
        end
    end
end

function TroopManager:GetOneIdleTroop()
    local myTroops, _ = self:GetMyTroops()
    for key, value in pairs(myTroops) do
        local preset = value.preset
        if preset then
            if preset.Status == wds.TroopPresetStatus.TroopPresetIdle or
                preset.Status == wds.TroopPresetStatus.TroopPresetInBigWorld or
                preset.Status == wds.TroopPresetStatus.TroopPresetInHome then
                if not (preset.BasicInfo.Battling or preset.BasicInfo.BackToCity) then
                    return key, value
                end
            end
        end
    end
    return nil
end

function TroopManager:UpdateMobileFortressCache()
    ---@type wds.MobileFortress[]
    self.myMobileFortress = {}
    ---@type wds.MobileFortress[]
    local troops = g_Game.DatabaseManager:GetEntitiesByType(DBEntityType.MobileFortress)
    local playerModule = ModuleRefer.PlayerModule
    for _, value in pairs(troops) do
        if playerModule:IsFriendly(value.Owner) then
            table.insert(self.myMobileFortress,value)
            self.myMobileFortress[value.ID] = value
        end
    end
end

function TroopManager:UpdateMyTroopCtrl()
    self.needUpdateMyTroop = true
end

function TroopManager:UpdateMyMobileFortress()
    self.needUpdateMyMobileFortress = true
end
---@param troop wds.Troop
function TroopManager:GetTroopPresetIndex(troop)
    if not troop then return -1 end
    if not self.myTroops then
        self:UpdateTroopCache()
    end

    for index, info in ipairs(self.myTroops) do
        if info.entityData and info.entityData.ID == troop.ID then
            return index
        end
    end
    return -1
end

function TroopManager:FindHeroTroopPresetIndex(heroCfgId)
    if not heroCfgId or heroCfgId <= 0 then return -1 end
    if not self.myTroops then
        self:UpdateTroopCache()
    end

    for index, info in ipairs(self.myTroops) do
        if info.preset
            and info.preset.Heroes
        then
            for _, value in pairs(info.preset.Heroes) do
                if value.HeroCfgID == heroCfgId then
                    return index
                end
            end
        end
    end
    return -1
end

---@return TroopInfo
function TroopManager:GetTroopInfoByPresetIndex(index, forceUpdate)
    if not self.myTroops or forceUpdate then
        self:UpdateTroopCache()
    end
    return self.myTroops[index]
end

function TroopManager:Tick()
    if self.needUpdateMyTroop then
        self.needUpdateMyTroop = false
        self:UpdateTroopCache()
        local myTroops,gmTroops = self:GetMyTroops()
        for key, value in pairs(myTroops) do
            if value.entityData then
                self:CreateTroopCtrl(value.entityData, DBEntityPath.Troop)
            else
                self:DestroyTroopCtrl(value.troopId)
            end
        end
        for key, value in pairs(gmTroops) do
            if value.entityData then
                self:CreateTroopCtrl(value.entityData,DBEntityPath.Troop)
            end
        end
        g_Game.EventManager:TriggerEvent(EventConst.MY_TROOP_UPDATE)
    end

    if self.needUpdateMyMobileFortress then
        self.needUpdateMyMobileFortress = false
        self:UpdateMobileFortressCache()
        local myFortress = self:GetMyMobileFortress()
        for key, value in pairs(myFortress) do
            if value then
                self:CreateTroopCtrl(value,DBEntityPath.MobileFortress)
            end
        end
        g_Game.EventManager:TriggerEvent(EventConst.MY_TROOP_UPDATE,{udpateFortress = true})
    end

    self:TickEntityWillNew()
    self:UpateTroopHUD()
    self:TickWatchList()
end

------------------------------------------------------------------------------------------------
---Ceate View In CS

---@param troop wds.Troop | wds.MapMob | wds.MobileFortress | wds.SlgPuppet | wds.TroopChariot
function TroopManager:CreateECSTroopData(troop)
    local extraInfo

    ---@type CS.DragonReborn.SLG.Troop.TroopData
    local troopData = nil
    if troop.TypeHash == DBEntityType.Troop then
        troopData = self:CreatePlayerTroopData(troop)
    elseif troop.TypeHash == DBEntityType.MobileFortress then
        troopData = self:CreateMobileFortressData(troop)
    elseif troop.TypeHash == DBEntityType.SlgPuppet then
        troopData = self:CreatePuppetData(troop)
    elseif troop.TypeHash == DBEntityType.MapBuilding or troop.TypeHash == DBEntityType.DefenceTower then
        troopData = self:CreateBuildingData(troop)
    elseif troop.TypeHash == DBEntityType.TroopChariot then
        troopData, extraInfo = self:CreateTroopChariotData(troop)
    else
        troopData = self:CreateMobData(troop)
    end

    if troopData then
        troopData.troopType = SlgUtils.FigureOutTroopType(troop)
    end

    return troopData, extraInfo
end

---@param data wds.Troop
function TroopManager:CreatePlayerTroopData(data)
    local troopData = g_Game.TroopViewManager:GetTroopEntityData()
    troopData.id = data.ID

    local troopRadius = self:CalcTroopRadius(data)
    troopData.radius = troopRadius

    local heros = data.Battle.Group.Heros
    local slgScale = self._module.slgScale
    local syncUnitStateOff = false

    if SlgUtils.IsTroopRetreating(data.MapStates) then
        heros = 
        {
            [0] =
            {
                HeroID = 509,
                Hp = 100
            }
        }

        syncUnitStateOff = true
    end

    HeroPetFormation.Create(troopData,heros,troopRadius,slgScale,syncUnitStateOff)

    self:SetupTroopMapData(data,troopData,TroopConst.ROTATE_SPEED_NORMAL);
    troopData.heroAIType = SlgUtils.AIType.Hero
    troopData.serverType = SlgUtils.ServerType.Troop
    return troopData
end

---@param data wds.MapMob
---@return CS.DragonReborn.SLG.Troop.TroopData
function TroopManager:CreateMobData(data)

    local mobConfig = ConfigRefer.KmonsterData:Find(data.MobInfo.MobID)
    if not mobConfig then return nil end
    local monsterClass = mobConfig:MonsterClass()
    local visibleType = mobConfig:VisibleTypo()
    ---@type CS.DragonReborn.SLG.Troop.TroopData
    local troopData = g_Game.TroopViewManager:GetTroopEntityData()
    troopData.id = data.ID

    local troopRadius = self:CalcTroopRadius(data)
    troopData.radius = troopRadius

    local heros = data.Battle.Group.Heros
    local rotateSpeed = 0
    local slgScale = self._module.slgScale
    if visibleType == VisibleType.OnlyMainHero or monsterClass == MonsterClassType.Behemoth then
        heros = {[0] = heros[0]}
        rotateSpeed = TroopConst.ROTATE_SPEED_BOSS
    else
        rotateSpeed = TroopConst.ROTATE_SPEED_NORMAL
    end

    HeroPetFormation.Create(troopData, heros,troopRadius,slgScale,false,visibleType)

    self:SetupTroopMapData(data,troopData,rotateSpeed);

    if monsterClass == MonsterClassType.Behemoth then
        troopData.heroAIType = SlgUtils.AIType.Boss
    elseif monsterClass == MonsterClassType.Boss then
        troopData.heroAIType = SlgUtils.AIType.BossStatic
    else
        troopData.heroAIType = SlgUtils.AIType.Hero
    end

    troopData.serverType = SlgUtils.ServerType.Mob

    return troopData
end

---@param data wds.SlgPuppet
---@return CS.DragonReborn.SLG.Troop.TroopData
function TroopManager:CreatePuppetData(data)
    if data.BasicInfo.ConfID < 1 then return end
    local puppetCfg = ConfigRefer.PuppetSlg:Find(data.BasicInfo.ConfID)
    if not puppetCfg then return end
    local mobConfig = ConfigRefer.KmonsterData:Find(puppetCfg:SlgNpc())
    local visibleType = mobConfig:VisibleTypo()

    ---@type CS.DragonReborn.SLG.Troop.TroopData
    local troopData = g_Game.TroopViewManager:GetTroopEntityData()
    troopData.id = data.ID

    local troopRadius = self:CalcTroopRadius(data)
    troopData.radius = troopRadius

    local heros = data.Battle.Group.Heros
    local slgScale = self._module.slgScale

    if visibleType == VisibleType.OnlyMainHero then
        heros = {[0] = heros[0]}
    end

    HeroPetFormation.Create(troopData,heros,troopRadius,slgScale,false,visibleType)

    self:SetupTroopMapData(data,troopData,TroopConst.ROTATE_SPEED_NORMAL)
    if data.BasicInfo.ConfID == 3 then
        troopData.heroAIType = SlgUtils.AIType.BossStatic
    else
        troopData.heroAIType = SlgUtils.AIType.Simple
    end

    troopData.serverType = SlgUtils.ServerType.Puppet

    return troopData
end

---@param data wds.MapBuilding
---@return CS.DragonReborn.SLG.Troop.TroopData
function TroopManager:CreateBuildingData(data)
    ---@type CS.DragonReborn.SLG.Troop.TroopData
    local troopData = g_Game.TroopViewManager:GetTroopEntityData()
    troopData.id = data.ID

    if data.TypeHash == DBEntityType.DefenceTower then
        troopData.radius = self:CalcTroopRadius(data)
    else
        troopData.radius = self:CalcTroopSizeScale(data)
    end

    self:SetupTroopMapData(data,troopData,TroopConst.ROTATE_SPEED_BUILDING)
    troopData.heroAIType = SlgUtils.AIType.None
    troopData.serverType = SlgUtils.ServerType.Building
    return troopData
end

---@param data wds.MobileFortress
---@return CS.DragonReborn.SLG.Troop.TroopData
function TroopManager:CreateMobileFortressData(data)
    ---@type CS.DragonReborn.SLG.Troop.TroopData
    local troopData = g_Game.TroopViewManager:GetTroopEntityData()
    troopData.id = data.ID

    local troopRadius = self:CalcTroopRadius(data)
    troopData.radius = troopRadius

    local behemothTid = data.BehemothTroopInfo.MonsterTid
    local monsterCfg = ConfigRefer.KmonsterData:Find(behemothTid)
    local slgScale = self._module.slgScale
    BehemothFormation.Create(troopData, monsterCfg, slgScale)

    self:SetupTroopMapData(data,troopData,TroopConst.ROTATE_SPEED_BOSS)
    troopData.heroAIType = SlgUtils.AIType.Hero
    troopData.serverType = SlgUtils.ServerType.MobileFortress
    return troopData
end

---@param data wds.TroopChariot
---@return CS.DragonReborn.SLG.Troop.TroopData
function TroopManager:CreateTroopChariotData(data)
    ---@type CS.DragonReborn.SLG.Troop.TroopData
    local troopData = g_Game.TroopViewManager:GetTroopEntityData()
    troopData.id = data.ID

    local troopRadius = self:CalcTroopRadius(data)
    troopData.radius = troopRadius

    local heroPetInfo = RallyFormation.Create(troopData, data.Army, troopRadius)

    self:SetupTroopMapData(data,troopData,TroopConst.ROTATE_SPEED_BOSS)
    troopData.heroAIType = SlgUtils.AIType.Hero
    troopData.serverType = SlgUtils.ServerType.TroopChariot
    return troopData, heroPetInfo
end

---@param data wds.Troop | wds.MobileFortress | wds.MapMob
---@param troopData CS.DragonReborn.SLG.Troop.TroopData
---@param rotateSpeed number
function TroopManager:SetupTroopMapData(data,troopData,rotateSpeed)
    local pos = self._module:ServerCoordinate2Vector3(data.MapBasics.Position)
    troopData.position = self._module:GetTerrainPos(pos)
    troopData.direction =  {x = data.MapBasics.Direction.X, y = 0, z = data.MapBasics.Direction.Y}
    troopData.moveSpeed = self._module:GetTroopMoveSpeed(data) * self._module.slgScale    
    troopData.rotateSpeed = rotateSpeed or 0
    troopData.layerMask = self.unitLayerMask
    troopData.attackRange = 35 * self._module.slgScale
end

function TroopManager:OnTroopCountChanged()
    if self._module:CanShowOtherSkillVfx() then
        self._module:SetupSkillMaxVfxAndPriority(0)
    else
        self._module:SetupSkillMaxVfxAndPriority(-1)
    end
end

---@param troop wds.Troop | wds.MapMob | wds.MobileFortress | wds.SlgPuppet ...
function TroopManager:CreateTroopCtrl(troop, dbEntityPath)
    if self._troops[troop.ID] then
        return
    end

    ---@type TroopCtrl
    local troopCtrl = nil
    if troop.TypeHash == DBEntityType.MapMob and troop.MobInfo then
        local mobConfig = ConfigRefer.KmonsterData:Find(troop.MobInfo.MobID)
        if mobConfig and mobConfig:MonsterClass() == MonsterClassType.Behemoth then
            troopCtrl = BehemothTroopCtrl.new(troop, dbEntityPath)
        end
    end

    if not troopCtrl then
        troopCtrl = TroopCtrl.new(troop, dbEntityPath)
    end

    self._troops[troop.ID] = troopCtrl
    self._troopCount = self._troopCount + 1
    
    self:OnTroopCountChanged()

    if self._module:IsMyTroop(troop) then
        self._myTroops[troop.ID] = troopCtrl
    end

    local troopId = troop.ID

    local holder, name = self:GetHolderAndName(troopCtrl)
    troopCtrl:StartupTroopCtrl(name, holder, function()
        local ctrl = self._troops[troopId]
        if not ctrl then
            return
        end

        self:AddTroopDBChanged(dbEntityPath)
        self:OnTroopMovePathInfoChanged(troop)

        g_Game.EventManager:TriggerEvent(EventConst.ON_TROOP_CREATED, troopId, ctrl.troopType, ctrl.troopView.trans.position)

        if self._timelineHideTroop then
            ctrl.troopView:SetVisible(false, true)
        end
    end)
end

---@param ctrl TroopCtrl
---@return CS.UnityEngine.Transform, string
function TroopManager:GetHolderAndName(ctrl)
    if ctrl:IsMonster() then
        if ctrl:IsBehemothMonster() then
            return self._monsterParent, string.format("Behemoth:%s", ctrl.ID)
        else
            return self._monsterParent, string.format("Monster:%s", ctrl.ID)
        end
    end

    if ctrl:IsPuppet() then
        return self._monsterParent, string.format("Puppet:%s", ctrl.ID)
    end

    if ctrl:IsFortress() then
        return self._troopParent, string.format("Fortress:%s", ctrl.ID)
    end

    if ctrl:IsChariot() then
        return self._troopParent, string.format("Chariot:%s", ctrl.ID)
    end

    return self._troopParent, string.format("Troop:%s", ctrl.ID)
end

function TroopManager:DestroyAllEntity()    
    for k, v in pairs(self._troops) do
        self:DestroyTroopCtrl(v.ID)
    end

    self.myMobileFortress = nil
    self.myTroops = nil
    self._entityWillNew = {}
    self._willNewCount = 0
    if self.dirtyHUD then
        table.clear(self.dirtyHUD)
    end
end

---@param data wds.Troop | wds.MapBuilding
---@return number,number @troop radius, troop scale
function TroopManager:CalcTroopRadius(data)
    local battleRadiusScale = data.Battle.Radius
    if battleRadiusScale < SLGConfig.TroopRadiusOffset then
        battleRadiusScale = SLGConfig.TroopUniScale * ConfigRefer.ConstMain:TroopBodySizeBase()
    end
    return self._module.BaseConfig.TroopRadius * battleRadiusScale
end

---@param data wds.Troop | wds.MapBuilding
---@return number,number @troop radius, troop scale
function TroopManager:CalcTroopSizeScale(data)
    local battleRadiusScale = data.Battle.Radius
    if battleRadiusScale < SLGConfig.TroopRadiusOffset then
        battleRadiusScale = SLGConfig.TroopUniScale * ConfigRefer.ConstMain:TroopBodySizeBase()
    end
    battleRadiusScale = battleRadiusScale * battleRadiusScale * 2 --size of Square
    return self._module.BaseConfig.TroopRadius * battleRadiusScale
end

---@param building wds.MapBuilding
function TroopManager:OnBuildingCreated(type,building)
    local bId = building.ID
    if self._buildings[bId] then
        return
    end

    local buildingCtrl = BuildingTroopCtrl.new(building,DBEntityPath.MapBuilding)
    self._buildings[bId] = buildingCtrl
    buildingCtrl:DoOnNewEntity()
    self:AddTroopDBChanged(DBEntityPath.MapBuilding)
    local updateNotice = false
    local sourceType = building.Base.CityBrief.cityType
    if sourceType == wds.CityBattleObjType.CityBattleObjTypeBuilding then
        self._buildingView[building.Base.CityBrief.EntityCityId] = buildingCtrl
        updateNotice = true
    elseif sourceType == wds.CityBattleObjType.CityBattleObjTypeFurniture then
        self._furnitureView[building.Base.CityBrief.EntityCityId] = buildingCtrl
        updateNotice = true
    elseif sourceType == wds.CityBattleObjType.CityBattleObjTypeWall then
        self._wallView[building.Base.CityBrief.EntityCityId] = buildingCtrl
    elseif sourceType == wds.CityBattleObjType.CityBattleObjTypeElement then
        self._elementView[building.Base.CityBrief.EntityCityId] = buildingCtrl
        updateNotice = true
    end
    if updateNotice then
        g_Game.EventManager:TriggerEvent(EventConst.CITY_SLG_ASSET_UPDATE, sourceType , building.Base.CityBrief.EntityCityId)
    end
    g_Game.EventManager:TriggerEvent(EventConst.ON_TROOP_BUILDING_CREATED,bId)
end

function TroopManager:OnBuildingDestroy(type,building)
    local bId = building.ID
    local ctrl = self._buildings[bId]
    if ctrl and ctrl:IsValid() then
        ctrl:DoOnDestroyEntity()
    end
    self:RemoveTroopDBChanged(DBEntityPath.MapBuilding)
    self._buildings[bId] = nil
    local updateNotice = false
    local sourceType = building.Base.CityBrief.cityType
    if sourceType == wds.CityBattleObjType.CityBattleObjTypeBuilding then
        self._buildingView[building.Base.CityBrief.EntityCityId] = nil
        updateNotice = true
    elseif sourceType == wds.CityBattleObjType.CityBattleObjTypeFurniture then
        self._furnitureView[building.Base.CityBrief.EntityCityId] = nil
        updateNotice = true
    elseif sourceType == wds.CityBattleObjType.CityBattleObjTypeWall then
        self._wallView[building.Base.CityBrief.EntityCityId] = nil
    elseif sourceType == wds.CityBattleObjType.CityBattleObjTypeElement then
        self._elementView[building.Base.CityBrief.EntityCityId] = nil
    end
    if updateNotice then
        g_Game.EventManager:TriggerEvent(EventConst.CITY_SLG_ASSET_UPDATE, sourceType, building.Base.CityBrief.EntityCityId)
    end
    g_Game.EventManager:TriggerEvent(EventConst.ON_TROOP_BUILDING_DESTROYED,bId)
end


---@param building wds.DefenceTower
function TroopManager:OnDefenceTowerCreated(type, building)
    local bId = building.ID
    if self._buildings[bId] then
        return
    end

    local buildingCtrl = KBuildingTroopCtrl.new(building,DBEntityPath.DefenceTower)
    self._buildings[bId] = buildingCtrl
    buildingCtrl:DoOnNewEntity()
    self:AddTroopDBChanged(DBEntityPath.DefenceTower)
end

---@param building wds.DefenceTower
function TroopManager:OnDefenceTowerDestroy(type, building)
    local bId = building.ID
    local ctrl = self._buildings[bId]
    if ctrl and ctrl:IsValid() then
        ctrl:DoOnDestroyEntity()
    end
    self:RemoveTroopDBChanged(DBEntityPath.DefenceTower)
    self._buildings[bId] = nil
end

---@param chariot wds.TroopChariot
function TroopManager:OnTroopChariotCreated(typeHash, chariot)
    if chariot == nil or chariot.MapStates.HideOnMap then
        return
    end

    self:SetPlayerTroopCount(self._playerTroopCount + 1)
    self:EnqueueNewTroop(chariot, DBEntityPath.TroopChariot, 0)
end

---@param chariot wds.TroopChariot
function TroopManager:OnTroopChariotDestroy(typeHash,chariot)
    if chariot == nil then return end

    self:SetPlayerTroopCount(self._playerTroopCount - 1)
    self:DestroyTroopCtrl(chariot.ID)
end

function TroopManager:OnTroopChariotHideOnMapChange(chariot, hideOnMap)
    if hideOnMap == false then
        local ctrl = self._module:GetCtrl(chariot.ID)
        if not ctrl then
            self:EnqueueNewTroop(chariot, DBEntityPath.TroopChariot, 0)
        end
    end
end

---@param isSuccess boolean
---@param msg wrpc.PushEntityJumpRequest
function TroopManager:OnEntityJump(isSuccess, msg)
    if not isSuccess then
        return
    end

    local stepInfo = msg.Info

    ---@type wds.Troop
    local troop = SlgUtils.GetEntityById(stepInfo.EntityId)
    if troop and troop.MapBasics and troop.MapBasics.Position then
        troop.MapBasics.Position.X = stepInfo.Pos.X
        troop.MapBasics.Position.Y = stepInfo.Pos.Y
        troop.MapBasics.Position.Z = stepInfo.Pos.Z

        local ctrl = self:FindTroopCtrl(stepInfo.EntityId) --如果是集结的话也只处理参加集结的Troop
        if ctrl then
            local path = ctrl._dbEntityPath
            self:DestroyTroopCtrl(ctrl.ID)
            self:CreateTroopCtrl(troop, path)
        end
    end
end

---@return BuildingTroopCtrl
function TroopManager:FindBuldingCtrlByViewId(viewId)
    if not self._buildingView then return nil end
    return self._buildingView[viewId]
end

---@return BuildingTroopCtrl
function TroopManager:FindFurnitureCtrlByFunitureId(furnitureId)
    if not self._furnitureView then return nil end
    return self._furnitureView[furnitureId]
end

---@return BuildingTroopCtrl
function TroopManager:FindWallCtrlByWallId(wallId)
    if not self._wallView then return nil end
    return self._wallView[wallId]
end

---@return BuildingTroopCtrl
function TroopManager:FindElementCtrlByConfigId(configId)
    if not self._elementView then return nil end
    return self._elementView[configId]
end

function TroopManager:AddUpdateTroopHUD(hud)
    if not self.dirtyHUD then
        ---@type TroopHUD[]
        self.dirtyHUD = {}
    end
    table.insert(self.dirtyHUD, hud)
end

function TroopManager:UpateTroopHUD()

    if not self.dirtyHUD or #self.dirtyHUD <= 0 then
        return
    end
    for i = 1, #self.dirtyHUD do
        if self.dirtyHUD[i] then

            local state, result = pcall(self.dirtyHUD[i].HUDUpdate, self.dirtyHUD[i])
            if not state then
                g_Logger.ErrorChannel('TroopManager',result)
            end
            self.dirtyHUD[i] = nil
        end
    end
end

function TroopManager:IsAnyTroopMoving()
    local myTroops, _ = self:GetMyTroops()
    if myTroops then
        for _, value in pairs(myTroops) do
            if SlgUtils.IsTroopMoving(value.entityData) then
                return true
            end
        end
    end
    return false
end

---@param troopData wds.Troop
---@param presetIndex number
---@return CheckTroopTrusteeshipStateDefine
function TroopManager:CheckTroopTrusteeshipState(troopData, presetIndex)
    presetIndex = presetIndex or -1
    local presetInfo = self:GetTroopInfoByPresetIndex(presetIndex)
    if not presetInfo then
        if troopData then
            presetIndex = ModuleRefer.SlgModule.troopManager:GetTroopPresetIndex(troopData)
            if presetIndex then
                presetInfo = self:GetTroopInfoByPresetIndex(presetIndex)
            end
        end
    end
    if not presetInfo or not presetInfo.preset or presetInfo.locked then
        goto continue_check_none_escrow_trusteeship
    end

    -- 托管 执行中 需要确认取消
    -- wds.TroopPresetStatus.TroopPresetTeamInTrusteeship 组队 server@haibo
    -- TroopPresetAssembleInTrusteeship 托管执行中 server@jinjie
    if presetInfo.preset.Status == wds.TroopPresetStatus.TroopPresetAssembleInTrusteeship then
        return CheckTroopTrusteeshipStateDefine.State.InEscrowRunning
    end
    -- 托管 计划中 队伍可用
    if (presetInfo.preset.WaitingStateMask & wds.TroopPresetWaitingMask.TroopPresetWaitingMaskAssembleTrusteeship) ~= 0 then
        return CheckTroopTrusteeshipStateDefine.State.InEscrowPreparing
    end

    -- 不是托管 是组队的情况
    ::continue_check_none_escrow_trusteeship::
    if presetInfo and presetInfo.preset and presetInfo.preset.Status == wds.TroopPresetStatus.TroopPresetTeamInTrusteeship then
        if presetInfo.preset.TrusteeshipInfo and presetInfo.preset.TrusteeshipInfo.TrusteeshipStatus > wds.TrusteeshipStatus.TrusteeshipStatus_None then
            if presetInfo.preset.TrusteeshipInfo.TrusteeshipStatus > wds.TrusteeshipStatus.TrusteeshipStatus_Preparing then
                -- 组队 执行中 不能取消
                return CheckTroopTrusteeshipStateDefine.State.InAssembleLaunched
            else
                -- 组队 没发车 可以取消
                return CheckTroopTrusteeshipStateDefine.State.InAssemblePreparing
            end
        end
    end
    if troopData then
        if troopData.TrusteeshipInfo and troopData.TrusteeshipInfo.Status > wds.TrusteeshipStatus.TrusteeshipStatus_None then
            if troopData.TrusteeshipInfo.Status > wds.TrusteeshipStatus.TrusteeshipStatus_Preparing then
                -- 组队 执行中 不能取消
                return CheckTroopTrusteeshipStateDefine.State.InAssembleLaunched
            else
                -- 组队 没发车 可以取消
                return CheckTroopTrusteeshipStateDefine.State.InAssemblePreparing
            end
        end
    end
    return CheckTroopTrusteeshipStateDefine.State.None
end

---@param troopData wds.Troop
---@param presetIndex number
---@return wds.PresetTroopTrusteeshipInfo
function TroopManager:GetTroopTrusteeshipInfo(troopData,presetIndex)
    if troopData then
        return troopData.TrusteeshipInfo
    end
    local presetInfo = self:GetTroopInfoByPresetIndex(presetIndex)
    if not presetInfo or not presetInfo.preset or presetInfo.locked then
        return nil
    end

    return presetInfo.preset.TrusteeshipInfo
end

local CommonConfirmPopupMediatorDefine = require('CommonConfirmPopupMediatorDefine')
local UIMediatorNames = require('UIMediatorNames')
---@param troopData wds.Troop
---@param presetIndex number
---@param callback fun(cancel:boolean)
function TroopManager:CancelTroopTrusteeshipAndGoOn(troopData,presetIndex,callback,isAssemble)
    if troopData == nil and presetIndex < 1 then
        if callback then callback(false) end
        return
    end

    local isTrusteeship = self:CheckTroopTrusteeshipState(troopData,presetIndex)
    if isTrusteeship == CheckTroopTrusteeshipStateDefine.State.None then
        if callback then callback(false) end
        return
    end

    if not CheckTroopTrusteeshipStateDefine.IsStateCanCancel(isTrusteeship) then
        --不能取消的状态
        if callback then callback(false) end
        return
    end

    local presetInfo = self:GetTroopInfoByPresetIndex(presetIndex)

    if not presetInfo then
        if troopData then
            presetIndex = ModuleRefer.SlgModule.troopManager:GetTroopPresetIndex(troopData)
            if presetIndex then
                presetInfo = self:GetTroopInfoByPresetIndex(presetIndex)
            end
        end
    end

     ---@type CommonConfirmPopupMediatorParameter
     local data = {}
     data.styleBitMask = CommonConfirmPopupMediatorDefine.Style.ConfirmAndCancel
     data.title = isAssemble and I18N.Get("jijie_check_hosting_stop_title") or I18N.Get("village_check_hosting_stop_title")
     data.content = isAssemble and I18N.Get("jijie_check_hosting_stop_des") or I18N.Get("village_check_hosting_stop_des")
     data.onConfirm = function(context)
         if isTrusteeship == CheckTroopTrusteeshipStateDefine.State.InEscrowPreparing or isTrusteeship == CheckTroopTrusteeshipStateDefine.State.InEscrowRunning then
             ModuleRefer.VillageModule:CancelEscrowTroop({presetIndex}, function(batchRet)
                 if batchRet then
                     for targetId, v in pairs(batchRet) do
                         if not v.ret then
                             g_Logger.Error("CancelEscrowTroop on target:%s failed, rsp:%s", targetId, v.rsp)
                             if callback then callback(false) end
                             return
                         end
                     end
                     ModuleRefer.ToastModule:AddSimpleToast(I18N.Get("village_toast_hosting_cancel"))
                     if callback then callback(true) end
                 end
             end)
             return true
         elseif isTrusteeship == CheckTroopTrusteeshipStateDefine.State.InAssemblePreparing then
             ModuleRefer.SlgModule:LeaveAllianceTeam(presetIndex, function(cmd, isSuccess, rsp)
                 if callback then callback(isSuccess and true or false) end
             end)
             return true
         end
         if callback then callback(true) end
         return true
     end
     data.onCancel = function(context)
        if callback then callback(false) end
        return true
     end
     g_Game.UIManager:Open(UIMediatorNames.CommonConfirmPopupMediator, data)
end

---@param troopCtrl TroopCtrl
function TroopManager:AddToWatchList(troopCtrl)

    if not self._watchList then
        ---@type TroopCtrl[]
        self._watchList = {}
    end
    self._watchList[troopCtrl.ID] = troopCtrl
end

function TroopManager:RemoveFromWatchList(troopId)
    if not self._watchList or not self._watchList[troopId] then return end
    self._watchList[troopId] = nil
end

function TroopManager:TickWatchList()
    if not self._watchList then return end
    for _, value in pairs(self._watchList) do
        value:TickInWatchList()
    end
end

return TroopManager
