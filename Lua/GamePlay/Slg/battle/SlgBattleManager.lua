---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wupei.
--- DateTime: 2020/11/6
---

local AbstractManager = require("AbstractManager")
local Delegate = require('Delegate')
local ProtocolId = require('ProtocolId')
local UISlgBattleInfo = require("UISlgBattleInfo")
local ConfigRefer = require('ConfigRefer')
local ModuleRefer = require('ModuleRefer')
local DBEntityType = require('DBEntityType')
local ShapeType = require('ShapeType')
local RangeType = require('RangeType')
local SlgLocalConfig = require('SlgLocalConfig')
local I18N = require('I18N')
local SlgUtils = require('SlgUtils')
local TroopConst = require('TroopConst')
local PolicyType = require('PolicyType')
local ExtraInfoType = require("ExtraInfoType")

local Float3_Zero = {x=0,y=0,z=0}

---@class SlgBattleManager : AbstractManager
local SlgBattleManager = class('SlgBattleManager', AbstractManager)
local ShowDebugInfo = false

---@class BuffCacheInfo
---@field buffCfgIds number
---@field fromSelf boolean

---@class DamageCacheData
---@field round number
---@field targetDamage table<number, table> @key: target troop ID,value: {damage number, needShake boolean}


---@class RoundAttackDamageCacheData
---@field triggered boolean
---@field attack wrpc.Attack
---@field target wds.Troop | wds.MapMob

---@class RoundAttackSkillCacheData
---@field fromeSelf boolean
---@field data wrpc.SLGSkillCastRPC
---@field cfg KheroSkillLogicalCache
---@field buffs RoundAttackBuffCacheData[]


---@class RoundAttackCacheData
---@field dmgData table<number, RoundAttackDamageCacheData> @key: target troop ID
---@field skillDatas table<number,RoundAttackSkillCacheData> @key: skill RunnerId

---@class RoundDamageCacheData
---@field damageType number
---@field damage number
---@field position Float3
---@field critical boolean
---@field target wds.Troop | wds.MapMob

---@class RoundCacheData
---@field round number
---@field timestamp number
---@field attackDatas table<number,RoundAttackCacheData> @key: attacker troop ID
---@field otherDamageDatas table<number,table<number,RoundDamageCacheData>> @key: troop ID, value: table<damageType,data>

---@class TroopStateRoundData
---@field heroState table<number,number> @key: heroIndex
---@field petState table<number,number> @key: heroIndex

---@class KheroSkillLogicalCache
---@field Asset number
---@field AssetInCity number
---@field SkillName string
---@field RangeType number
---@field FirstFilterType number
---@field Shape number
---@field ShiftDistance number
---@field Length number
---@field Width number
---@field Angle number
---@field TimeParam number
---@field SkilType number
---@field ShowRange boolean

---@protected
function SlgBattleManager:ctor(...)
    AbstractManager.ctor(self, ...)
        
    ---@type table<number,table<number,DamageCacheData>> @key: troopId value: table<key: skillId,value: DamageCacheData>
    self.skillDamageCache = {}
    ---@type table<number, table<number,number>> @key: round value: table<key: troopId, value: skill damage>
    self.troopDamageCache = {}
    ---@type table
    self.relationTroops = {}
    self.relationTroopsIndex = {}
    ---@type RoundCacheData
    self.roundCache = nil
    ---@type table<number,TroopStateRoundData>
    self.troopDataCache = nil

    if ShowDebugInfo then
        self.roundCacheDataBackup = {}
    end

    self.dmgArray_Normal = {}
    self.dmgArray_Heal = {}
    self.dmgArray_Rage = {}
    self.dmgArray_Back = {}
end

function SlgBattleManager:Awake()
    g_Game.ServiceManager:AddResponseCallback(ProtocolId.PushBattleMessage,Delegate.GetOrCreate(self, self.ProcessBattleMessage))
    g_Game.ServiceManager:AddResponseCallback(ProtocolId.PushBattleCommonData,Delegate.GetOrCreate(self, self.ProcessBattleCommonData))
  
    ---@type SlgDataCacheModule
    self.dataCache = ModuleRefer.SlgDataCacheModule

    -- local slgLocalConfig = require('SlgLocalConfig')
    self._minLod = SlgLocalConfig.TroopMinLod
    self._maxLod = SlgLocalConfig.TroopMaxLod
    
    self._ftRootGo = CS.UnityEngine.GameObject('FloatingTextRoot')
    self._ftRootGo.transform:SetParent(self._module.worldHolder, false)
    self._sceneCam = self._module:GetCamera()
    g_Game.TroopViewManager:InitSkillDamageText(
        self._sceneCam,
        SlgLocalConfig.FloatingTextOrthographicScale,
        SlgLocalConfig.FloatingTextStyle.Skill,
        SlgLocalConfig.FloatingTextLife[SlgLocalConfig.FloatingTextStyle.Skill]
    )
    UISlgBattleInfo.Init(self._ftRootGo)
    g_Game.TroopViewManager:AddSkillDamageEvent(Delegate.GetOrCreate(self,self.OnSkillDamageEvent))
end

function SlgBattleManager:OnDestroy()
    g_Game.ServiceManager:RemoveResponseCallback(ProtocolId.PushBattleMessage,Delegate.GetOrCreate(self, self.ProcessBattleMessage))
    g_Game.ServiceManager:RemoveResponseCallback(ProtocolId.PushBattleCommonData,Delegate.GetOrCreate(self, self.ProcessBattleCommonData))

    UISlgBattleInfo.Clear()
end

function SlgBattleManager:OnLodChange(lod, oldLod)
    
    if lod < 1 and oldLod >= 1 then
        g_Game.TroopViewManager:SetSkillDamageOffset(
            SlgLocalConfig.DamageNumPos[SlgLocalConfig.FloatingTextStyle.Skill] * UISlgBattleInfo.InCityScale
        )
    elseif lod >= 1 and oldLod < 1 then
        g_Game.TroopViewManager:SetSkillDamageOffset(
            SlgLocalConfig.DamageNumPos[SlgLocalConfig.FloatingTextStyle.Skill]
        )
    end
end

function SlgBattleManager:MyPlayerId()
    if not self.myPlayerId then
        self.myPlayerId = ModuleRefer.PlayerModule:GetPlayerId()
    end
    return self.myPlayerId
end


---@return TroopCtrl | BuildingTroopCtrl
function SlgBattleManager:GetTroopCtrl(id)
    return self._module:GetTroopCtrl(id)
end

function SlgBattleManager:GetBuildingCtrl(id)
    return self._module:GetBuildingCtrl(id)
end

function SlgBattleManager:GetCtrl(id)
    return self._module:GetCtrl(id)
end

---@param m wrpc.PushBattleMessageRequest
function SlgBattleManager:ProcessBattleMessage(success,m)
    if not success or not m or not m.Msg or not m.Msg.EntityId then
        return
    end
    
    if not self:CanPopBattleEffect() then
        return
    end    

    local msg = m.Msg
    local curTroopId = msg.EntityId
    local troopEntities = g_Game.DatabaseManager:GetEntitiesById(curTroopId)
    if not troopEntities or not troopEntities[1] then
        return
    end
    ---@type wds.Troop | wds.MapMob | wds.MobileFortress | wds.MapBuilding ...
    local curTroopEntity = troopEntities[1]
    
    if msg.Data and not msg.Data:IsEmpty() then
        --缓存伤害数据，从'受到的伤害'转换为'造成的伤害'
        self:CacheAttackData(curTroopEntity, msg.Data)   
    end

    local skillCastList = msg.SLGSkillCastRPCList
    if skillCastList and #skillCastList > 0 then
        --缓存技能数据
        self:CacheSkillData(curTroopId,skillCastList)
    end
    if ShowDebugInfo then
        if self.roundCache then
            if self.roundCache.battleMessage == nil then
                self.roundCache.battleMessage = {}
            end
            table.insert(self.roundCache.battleMessage,msg)
        end
    end
end


---@param msg wrpc.SkillCastRPC
function SlgBattleManager:SkillMSGFilter(msg)
    if not msg and not msg.SkillInfo  then return false end

    if not self._module:IsInKingdom() then
        return true
    end

    local attEntity = g_Game.DatabaseManager:GetEntitiesById(msg.Attacker)[1]

    if not attEntity then
        return false
    end

    if attEntity.TypeHash == DBEntityType.MobileFortress and self._module:IsMyAlliance(attEntity) then
        return true
    elseif attEntity.Owner.PlayerID == self:MyPlayerId() then
        return true
    elseif attEntity.TypeHash == DBEntityType.MapBuilding then
        return true
    end

    if msg.SkillInfo.Target and msg.SkillInfo.Target > 0 then
        local targetEntity = g_Game.DatabaseManager:GetEntitiesById(msg.SkillInfo.Target)[1]
        if targetEntity and targetEntity.TypeHash == DBEntityType.MobileFortress and self._module:IsMyAlliance(targetEntity) then
            return true
        elseif targetEntity and targetEntity.Owner.PlayerID ==  self:MyPlayerId() then
            return true
        end
    end

    if msg.SkillInfo.TargetIds and #msg.SkillInfo.TargetIds > 0 then
        for index, value in ipairs(msg.SkillInfo.TargetIds) do
            local targetEntity = g_Game.DatabaseManager:GetEntitiesById(value)[1]
            if targetEntity and targetEntity.TypeHash == DBEntityType.MobileFortress and self._module:IsMyAlliance(targetEntity) then
                return true
            elseif targetEntity and targetEntity.Owner.PlayerID ==  self:MyPlayerId() then
                return true
            end
        end
    end

    return false
end

---@param myTroop TroopCtrl
---@param enemyTroop TroopCtrl
function SlgBattleManager:AddToBattleRelation(myTroop,enemyTroop,attack)
    if not myTroop or not enemyTroop then return end
    local myTroopId = myTroop.ID
    local enemyTroopId = enemyTroop.ID
    if not self.relationTroops[myTroopId] then
        self.relationTroops[myTroopId] = {
            att = {},
            beAtt = {}
        }
    end
    if attack then
        if self.relationTroops[myTroopId].att[enemyTroopId] then
            return
        end
        self.relationTroops[myTroopId].att[enemyTroopId] = true
    else
        if self.relationTroops[myTroopId].beAtt[enemyTroopId] then
            return
        end
        self.relationTroops[myTroopId].beAtt[enemyTroopId] = true
    end    
    
    if not self.relationTroopsIndex[enemyTroopId] then
        self.relationTroopsIndex[enemyTroopId] = 1
    else
        self.relationTroopsIndex[enemyTroopId] = self.relationTroopsIndex[enemyTroopId] + 1
    end
   
    local srcView = enemyTroop:GetTroopView()
    if srcView then
        srcView:ShowHUDForBattle()
    end
end

---@param myTroop TroopCtrl
---@param enemyTroop TroopCtrl
function SlgBattleManager:RemoveFromeBattleRelation(myTroop,enemyTroop,attack)
    if not myTroop or not enemyTroop then return end
    local myTroopId = myTroop.ID
    local enemyTroopId = enemyTroop.ID
    if not self.relationTroops[myTroopId] then
        return
    end
   
    if attack then
        if not self.relationTroops[myTroopId].att[enemyTroopId] then
            return
        end
        self.relationTroops[myTroopId].att[enemyTroopId] = nil
    else
        if not self.relationTroops[myTroopId].beAtt[enemyTroopId] then
            return
        end
        self.relationTroops[myTroopId].beAtt[enemyTroopId] = nil
    end    

    if self.relationTroopsIndex[enemyTroopId] then
        self.relationTroopsIndex[enemyTroopId] = self.relationTroopsIndex[enemyTroopId] - 1
        if self.relationTroopsIndex[enemyTroopId] <= 0 then
            self.relationTroopsIndex[enemyTroopId] = nil
        end
    end
    
    local srcView = enemyTroop:GetTroopView()
    if srcView then
        srcView:HideHUDForBattle()
    end
end

function SlgBattleManager:ClearBattleRelation(myTroop)
    if not myTroop then return end
    local myTroopId = myTroop.ID
    if not self.relationTroops[myTroopId] then
        return
    end
    for key, _ in pairs(self.relationTroops[myTroopId].att) do
        local ctrl = self._module:GetTroopCtrl(key)
        if ctrl then
            local view = ctrl:GetTroopView()
            if view then
                view:HideHUDForBattle()
            end
        end
        if self.relationTroopsIndex[key] then
            self.relationTroopsIndex[key] = self.relationTroopsIndex[key] - 1
            if self.relationTroopsIndex[key] <= 0 then
                self.relationTroopsIndex[key] = nil
            end
        end
    end
    for key, _ in pairs(self.relationTroops[myTroopId].beAtt) do
        local ctrl = self._module:GetTroopCtrl(key)
        if ctrl then
            local view = ctrl:GetTroopView()
            if view then
                view:HideHUDForBattle()
            end
        end
        if self.relationTroopsIndex[key] then
            self.relationTroopsIndex[key] = self.relationTroopsIndex[key] - 1
            if self.relationTroopsIndex[key] <= 0 then
                self.relationTroopsIndex[key] = nil
            end
        end
    end
    self.relationTroops[myTroopId] = nil
end

function SlgBattleManager:IsTroopInRelation(troopId)
    if not self.relationTroopsIndex then
        return false
    end  
    return self.relationTroopsIndex[troopId] ~= nil
end

---@class SkillBuffParam
---@field vfxPath string
---@field yOffset number
---@field scale number
---@field nameStr string
---@field nameStyle number

---@class SkillTargetInfo
---@field attackData wrpc.Attack
---@field buffs SkillBuffParam[]
---@field moveTo wrpc.PBVector3
---@field spState number

---@class SkillCastInfo
---@field skillId number
---@field targetId number
---@field targetHeroIndex number
---@field targetPetIndex number
---@field targetPos Float3
---@field targetDir Float3
---@field stage number 
---@field targetType number @RangeType
---@field targetInfos table<number,SkillTargetInfo> @targetid,SkillTargetInfo
---@field rangeType     number
---@field rangeVfxPath  string
---@field rangeVfxScale Float3
---@field rangeOffset       number
---@field rangeVfxDuration number
---@field rangeVfxSpeed     number

---@param data wds.Troop
function SlgBattleManager:IsAttackingBuilding(data)
    if not data or not data.Battle or not data.Battle.TargetArmyUID or data.Battle.TargetArmyUID < 1 then
        return false
    end
    return true
end

---@param attack wrpc.Attack
---@param unitType number
---@return wrpc.Damage
function SlgBattleManager:GetNormalDamageData(runnerId,attack,unitType)
    if not attack then return nil end
    -- local damageData = nil
    if attack.NormalDamageInfos then
        for _, value in pairs(attack.NormalDamageInfos) do
            if value
                and (runnerId < 0 or value.RunnerId == runnerId)
                and (not unitType or value.SourceIndexParam.Typo == unitType)
            then
                return value
            end
        end
    end

    if attack.DurabilityInfos then
        for _, value in pairs(attack.DurabilityInfos) do
            if value
                and (runnerId < 0 or value.RunnerId == runnerId)
                and (not unitType or value.SourceIndexParam.Typo == unitType)
            then
                return value
            end
        end
    end

    return nil
end

local SkillEnum = require("skill_enum")
local RangeOffset = 3
---@param skillCastInfo SkillCastInfo
---@param targetType number
---@param skill KheroSkillLogicalCache
---@param skillCastRPC wrpc.SkillCastRPC
---@param attackerCtrl TroopCtrl
function SlgBattleManager:SetupSkillCastInfoToTroop(skillCastInfo, skill,skillCastRPC,attackerCtrl)
    if not skillCastInfo then return false end

    --目标只选自己时，范围类型改为Self
    local targetType = skill.RangeType
    if skill.FirstFilterType== SkillEnum.FilterType.FilterTypeSelf
    then        
        targetType = RangeType.Self
    end
    local pushSkill = false
    local skillInfo = skillCastRPC.SkillInfo
    
    local rangeShape = skill.Shape
    local rangeOffset = skill.ShiftDistance
    local rangeLength = 0
    local rangeWidth = 0
    local rangeAngle = 0

    if targetType == RangeType.Range then
        if rangeShape == ShapeType.Rectangle or rangeShape == ShapeType.Sector then
            --长方形和扇形只能选择方向
            skillCastInfo.targetPos = attackerCtrl:GetPositionFloat3()
            rangeLength = skill.Length + RangeOffset
            rangeWidth = skill.Width + RangeOffset * 2
            rangeAngle = skill.Angle
        elseif rangeShape == ShapeType.Round then
            --圆形只选择中心位置
            skillCastInfo.targetPos = self._module:ServerCoordinate2Float3(skillInfo.TargetPos)
            rangeLength = skill.Length + RangeOffset
        end
        pushSkill = true 
    elseif targetType == RangeType.TargetRange then
        if rangeShape ~= ShapeType.Round then
            g_Logger.ErrorChannel('SlgBattleManager','Skill TargetType Config as TargetRange, Shape must be Round Shape!')
            return false
        end
        local targetCtrl = self:GetCtrl(skillInfo.Target)
        if targetCtrl then 
            skillCastInfo.targetId = targetCtrl.ID
            skillCastInfo.targetPos = targetCtrl:GetPositionFloat3()
        else
            skillCastInfo.targetPos = self._module:ServerCoordinate2Float3(skillInfo.TargetPos)
        end
        rangeLength = skill.Length + RangeOffset
        pushSkill = true 
    elseif targetType == RangeType.Target then
        local targetCtrl = self:GetCtrl(skillInfo.Target)
        if targetCtrl then 
            skillCastInfo.targetId = targetCtrl.ID
            skillCastInfo.targetHeroIndex = 0
            skillCastInfo.targetPos = targetCtrl:GetPositionFloat3()
            pushSkill = true
        end
        rangeShape = ShapeType.None
    elseif targetType == RangeType.Self then
        skillCastInfo.targetId = attackerCtrl.ID
        skillCastInfo.targetHeroIndex = 0
        skillCastInfo.targetPos = attackerCtrl:GetPositionFloat3()        
        pushSkill = true     
        rangeShape = ShapeType.None
    end   

    local scale = 100 / SlgLocalConfig.TroopUniScale * self._module.slgScale

    local duration = skill.TimeParam
    if skill.ShowRange then
        self:SetupSkillCastInfoRange(skillCastInfo,
            targetType,rangeShape,
            rangeLength*scale,rangeWidth*scale,
            rangeAngle,rangeOffset*scale,
            skill.SkilType,skillCastInfo.stage,duration
        )
    end

    return pushSkill
end

---@param skillCastInfo SkillCastInfo
---@param skillCastMsg wrpc.SkillCastRPC
---@param attackerData wrpc.Troop
function SlgBattleManager:SetupSkillCastInfoToBilding(skillCastInfo,skillCastMsg,attackerData)
    skillCastInfo.targetId = attackerData.Battle.TargetArmyUID

    if skillCastMsg.SkillInfo.TargetPos.X > 0 and skillCastMsg.SkillInfo.TargetPos.Y > 0 then
        skillCastInfo.targetPos = self._module:ServerCoordinate2Float3(skillCastMsg.SkillInfo.TargetPos)
        return true
    else
        local building = SlgUtils.GetEntityById(skillCastInfo.targetId)
        if building and building.MapBasics then
            skillCastInfo.targetPos = self._module:ServerCoordinate2Float3(building.MapBasics.Position)
            return true
        end
    end
    
    return false
end

---@param skillCastInfo SkillCastInfo
---@param targetType number
---@param rangeShape number
---@param rangeLenght number
---@param rangeWidth number
---@param rangeAngle number
function SlgBattleManager:SetupSkillCastInfoRange(
    skillCastInfo,targetType,rangeShape,rangeLenght,rangeWidth,rangeAngle,rangeOffset,    
    skillType, skillStage
    ,duration)

    if skillType == PolicyType.Chant and skillStage == 0 then
        skillCastInfo.rangeType = 0
        return
    end

    if targetType ~= RangeType.Range and targetType ~= RangeType.TargetRange then
        skillCastInfo.rangeType = 0
        return
    end

    local vfxPathSet = skillStage == 1 and SlgLocalConfig.RangeVfxPath.Chant or SlgLocalConfig.RangeVfxPath.Imm
    if duration < 0.1 then
        duration = 1
    end
    local speed = 5 / duration
    if targetType == RangeType.Range then
        skillCastInfo.rangeType = 100 + rangeShape
        if rangeShape == ShapeType.Rectangle then
            skillCastInfo.rangeVfxPath = vfxPathSet[ShapeType.Rectangle]
            skillCastInfo.rangeVfxScale = {x=rangeWidth,y=1,z=rangeLenght}--CS.UnityEngine.Vector3(rangeWidth,1,rangeLenght)
            skillCastInfo.rangeOffset = rangeOffset
            skillCastInfo.rangeVfxDuration = duration
            skillCastInfo.rangeVfxSpeed = speed
        elseif rangeShape == ShapeType.Sector then
            local angleType = math.min(180, math.round(rangeAngle / 45) * 45)
            skillCastInfo.rangeVfxPath = vfxPathSet[ShapeType.Sector][angleType]
            skillCastInfo.rangeVfxScale = {x=rangeLenght * 2,y=rangeLenght * 2,z=rangeLenght * 2}--CS.UnityEngine.Vector3.one * rangeLenght * 2
            skillCastInfo.rangeOffset = rangeOffset
            skillCastInfo.rangeVfxDuration = duration
            skillCastInfo.rangeVfxSpeed = speed
        elseif rangeShape == ShapeType.Round then
            skillCastInfo.rangeVfxPath = vfxPathSet[ShapeType.Round]
            skillCastInfo.rangeVfxScale = {x=rangeLenght * 2,y=rangeLenght * 2,z=rangeLenght * 2}--CS.UnityEngine.Vector3.one * rangeLenght * 2
            skillCastInfo.rangeOffset = rangeOffset
            skillCastInfo.rangeVfxDuration = duration
            skillCastInfo.rangeVfxSpeed = speed
        end
    else
        skillCastInfo.rangeType = 200
        skillCastInfo.rangeVfxPath = vfxPathSet[ShapeType.Round]
        skillCastInfo.rangeVfxScale = {x=rangeLenght,y=1,z=rangeLenght}--CS.UnityEngine.Vector3(rangeLenght,1,rangeLenght)
        skillCastInfo.rangeOffset = rangeOffset
        skillCastInfo.rangeVfxDuration = duration
        skillCastInfo.rangeVfxSpeed = speed
    end
end

---@param slgSkillCastRPC wrpc.SLGSkillCastRPC
---@param skill KheroSkillLogicalCache
---@param dmgDatas table<number, RoundAttackDamageCacheData>
function SlgBattleManager:CreateSkillData(slgSkillCastRPC,skill,dmgDatas)
    if slgSkillCastRPC == nil then
        return
    end

    local skillCastRPC = slgSkillCastRPC.MsgSkill
    if skillCastRPC == nil then
        return
    end
    
    --没有技能配置则不执行
    if skill.Asset < 1 and skill.AssetInCity < 1 then
        return
    end

    --Attacker可能是：
    --1、集结中的部队：获取战车的部队控制层
    --2、建筑：获取建筑的控制层
    --3、野怪、单人部队、巨兽：获取部队控制层
    local attackerCtrl = self:GetCtrl(skillCastRPC.Attacker)
    if not attackerCtrl then
        return
    end

    --集结的情况下，进攻者不是战车，而是战车里的部队
    local attackerData = SlgUtils.GetEntityById(skillCastRPC.Attacker)
    if not attackerData then
        return
    end

    local skillInfo = skillCastRPC.SkillInfo
    local isMyTroop = self._module.troopManager:IsMyExistingTroopId(skillCastRPC.Attacker)

    local skillId = skillInfo.RunnerId
    local stageType = skillInfo.StageType

    ---@type SkillCastInfo
    local skillCastInfo =
    {
        skillId = skillId,
        stage = stageType,
    }

    ---@type CS.UnityEngine.Vector3
    local attackingBuilding =  self:IsAttackingBuilding(attackerData)

    local pushSkill = false
    if attackingBuilding then
        pushSkill = self:SetupSkillCastInfoToBilding(skillCastInfo,skillCastRPC, attackerData)
    else        
        pushSkill = self:SetupSkillCastInfoToTroop(skillCastInfo, skill,skillCastRPC, attackerCtrl)
    end

    if not pushSkill then
        return nil
    end
    
    skillCastInfo.targetInfos = {}
    
    local showAttkerInfo = self:NeedPopBattleInfo(attackerData) 

    --damage floating text
    if dmgDatas and not table.isNilOrZeroNums(dmgDatas) then
        local needShake = self._module.troopManager:IsMyExistingTroopId(skillCastRPC.Attacker)
        for __, dmgTargetId in pairs(skillInfo.TargetIds) do
            local data = dmgDatas[dmgTargetId]
            if data and data.attack then
                data.triggered = true
                skillCastInfo.targetInfos[dmgTargetId] = {}
                skillCastInfo.targetInfos[dmgTargetId].attackData = data.attack

                local showTargetInfo = false
                if not showAttkerInfo then
                    showTargetInfo = self:NeedPopBattleInfoById(dmgTargetId)
                end

                if showAttkerInfo or showTargetInfo then
                    local attLoss,backLoss = self:CalcAttackDamageValue(skillId,data.attack)
                    self:CacheSkillDamage(skillCastRPC.Round,skillId,dmgTargetId,attLoss,needShake)
                    self:CacheSkillDamage(skillCastRPC.Round,skillId,skillCastRPC.Attacker,backLoss,needShake)
                end                
            end
        end
        if skillCastInfo.targetHeroIndex and skillCastInfo.targetHeroIndex < -100 then
            local mainDmg = skillCastInfo.targetInfos[skillCastInfo.targetId]
            if mainDmg then
                local indexParam = self:FindAttackDamageTarget(skillId,mainDmg)
                if indexParam then
                    skillCastInfo.targetHeroIndex, skillCastInfo.targetPetIndex = self:GetUnitIndexInTroop(skillCastRPC.Attacker, indexParam)
                end
            end            
        end
    end
    
    --buff vfx
    if skillCastRPC.MsgResult then
        for __, result in pairs(skillCastRPC.MsgResult) do
            if result.RunnerId == skillId then                                                    
                if not skillCastInfo.targetInfos[result.TargetId] then
                    skillCastInfo.targetInfos[result.TargetId] = {}
                end
                --buff data
                local showBuffName = isMyTroop or self._module.troopManager:IsMyExistingTroopId( result.TargetId)
                if not showBuffName then
                    showBuffName = self:IsTroopInRelation(skillCastRPC.Attacker)
                end
                skillCastInfo.targetInfos[result.TargetId].buffs = self:GetBuffParams(result.Buffs.BuffCfgId, showBuffName)
                skillCastInfo.targetInfos[result.TargetId].spState = SlgUtils.GetSpStateFromBuffCfgIds(result.Buffs.BuffCfgId)
                --movement                    
                skillCastInfo.targetInfos[result.TargetId].moveTo = result.Move.MoveEndPos
            end
        end
    end

    if isMyTroop then                           
        --cam shake
        local assetId = self._module.dataCache:GetSkillAssetId(skillInfo.SkillCfgId)
        if assetId then
            skillCastInfo.camShake = self:GetSkillCamShakeParam(assetId)                            
        end            
        skillCastInfo.skillName =  skill.SkillName
    end
    local assetID = 0
    if self._module:IsInCity() then
        assetID = skill.AssetInCity
        if assetID < 1 then
            assetID = skill.Asset
        end
    else
        assetID = skill.Asset
    end     
    local heroIndex = 0 
    local petIndex = 0
    if attackerData.TypeHash ~= DBEntityType.MapBuilding then 
        heroIndex, petIndex = self:GetUnitIndexInTroop(skillCastRPC.Attacker, skillInfo.ReleaseIndexParam)
    end              

    if ShowDebugInfo then
        g_Logger.ErrorChannel('Exe Skill MSG','CreateSkillData - RunnerId:%d | CfgId:%d | AssetId:%d | Attacker:%d(%d,%d) | Target:%d(%d,%d)',
            skillCastRPC.SkillInfo.RunnerId,
            skillInfo.SkillCfgId,
            assetID,
            skillCastRPC.Attacker,
            heroIndex,
            petIndex,
            skillCastInfo.targetId or 0,
            skillCastInfo.targetHeroIndex or 0,
            skillCastInfo.targetPetIndex or 0)
    end

    return self:CreateECSSkillData(attackerCtrl.ID, heroIndex, petIndex, skillCastInfo,
        assetID, skillCastRPC.SkillInfo.RunnerId, showAttkerInfo)
end

---@param id number
---@param param wrpc.IndexParam
function SlgBattleManager:GetUnitIndexInTroop(id, param)
    local heroIndex, petIndex = SlgBattleManager.GetUnitIndex(param)
    local ctrl = self:GetCtrl(id)
    if ctrl and ctrl.troopView.extraInfo and ctrl.troopView.extraInfo.type == ExtraInfoType.HeroPetIndex then
        local heros = ctrl.troopView.extraInfo.heros[id]
        if heros then
            if heroIndex > 0 then -- wrpc.IndexParam里的索引从1开始
                heroIndex = ctrl.troopView.extraInfo.heros[id][heroIndex]
            end
        end
        
        local pets = ctrl.troopView.extraInfo.pets[id]
        if pets then
            if petIndex > 0 then -- wrpc.IndexParam里的索引从1开始
                petIndex = pets[petIndex]
            end
        end
    end
    return heroIndex, petIndex
end

---@private
---@param attackerCtrl TroopCtrl | BuildingTroopCtrl
---@param heroId number
---@param skillCastInfo SkillCastInfo
---@param assetID number @KheroSkillLogicalConfigCell:Asset() or HeroClientResConfigCell:NormalAttAsset()
---@param showAttkerInfo boolean
---@return CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData
function SlgBattleManager:CreateECSSkillData(attackerId,heroIndex,petIndex,skillCastInfo,assetID,skillId,showAttkerInfo)    
   
    local isInCity = self._module:IsInCity()
    ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData
    local skillData = {}
    skillData.skillId = skillId
    skillData.actorId = attackerId  
    skillData.heroIndex = heroIndex - 1
    skillData.petIndex = petIndex - 1
    skillData.skillType = 2
    skillData.targetId = skillCastInfo.targetId
    skillData.targetHeroIndex = skillCastInfo.targetHeroIndex and skillCastInfo.targetHeroIndex - 1  or -1
    skillData.targetPetIndex = skillCastInfo.targetPetIndex and skillCastInfo.targetPetIndex - 1 or -1
    skillData.stageType = skillCastInfo.stage
    skillData.skillConfigId = assetID
    if showAttkerInfo then
        skillData.skillName = SlgBattleManager.CreatedFloatingTextParam(skillCastInfo.skillName,SlgLocalConfig.FloatingTextStyle.SkillName,isInCity)
    end

    --cam shake params
    if skillCastInfo.camShake then
        skillData.camShake = skillCastInfo.camShake.Shake
        skillData.camNoise = skillCastInfo.camShake.Noise
        skillData.camMoveExtents = skillCastInfo.camShake.MoveExt
        skillData.camRotateExtents = skillCastInfo.camShake.RotateExtents 
        skillData.camSpeed = skillCastInfo.camShake.Speed 
        skillData.camDuration = skillCastInfo.camShake.Time
    else
        skillData.camShake = -1
    end
    local isMyTroopIsTarget = false
    --damage params
    ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillTargetInfo[]
    local damageInfos = {}
    local damageInfosIndex = 1
    ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillMovementInfo[]
    local movementInfos = {}
    local movementInfosIndex = 1

    for targetId, targetInfo in pairs(skillCastInfo.targetInfos) do
        ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillTargetInfo
        local backdmgInfo = nil        
        ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillTargetInfo
        local dmgInfo = {}
        dmgInfo.targetId = targetId        
       
        -- dmgInfo.loss =  SlgBattleManager.CreatedFloatingTextParam('-' .. tostring(targetInfo.loss),floatingTextStyle,isInCity)
        local needShowInfo = showAttkerInfo or self:NeedPopBattleInfoById(targetId)

        if targetInfo.attackData then
            ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillFloatingTextParam[]
            local losses = {}
            local backLosses = {}            

            self.dmgArray_Normal[1] = targetInfo.attackData.NormalDamageInfos
            self.dmgArray_Normal[2] = targetInfo.attackData.ExtraChaseInfos
            self.dmgArray_Normal[3] = targetInfo.attackData.PassiveDamageInfos            
            self.dmgArray_Normal[4] = targetInfo.attackData.FixDamageInfos
            self.dmgArray_Normal[5] = targetInfo.attackData.AttrDamageInfos
            -- self.dmgArray_Normal[7] = nil
            SlgBattleManager.CreateLossDataArray(function(dmg) return dmg.RunnerId == skillId end,
                self.dmgArray_Normal,5,losses,SlgLocalConfig.FloatingTextStyle.Normal,isInCity,needShowInfo)
            
            self.dmgArray_Normal[1] = targetInfo.attackData.DurabilityInfos
            SlgBattleManager.CreateLossDataArray(function(dmg) return dmg.RunnerId == skillId end,
            self.dmgArray_Normal,1,losses,SlgLocalConfig.FloatingTextStyle.Durable,isInCity,needShowInfo)
          
            self.dmgArray_Rage[1] = targetInfo.attackData.RageDamageInfos
            SlgBattleManager.CreateLossDataArray(function(dmg) return dmg.RunnerId == skillId end,
                self.dmgArray_Rage,1,losses,SlgLocalConfig.FloatingTextStyle.Skill,isInCity,needShowInfo)

            self.dmgArray_Heal[1] = targetInfo.attackData.HealInfos
            SlgBattleManager.CreateLossDataArray(function(dmg) return dmg.RunnerId == skillId end,
                self.dmgArray_Heal,1,losses,SlgLocalConfig.FloatingTextStyle.Healing,isInCity,needShowInfo)
            
            self.dmgArray_Back[1] = targetInfo.attackData.BackDamageInfos
            self.dmgArray_Back[2] = targetInfo.attackData.ExtraBackInfos
            SlgBattleManager.CreateLossDataArray(function(dmg) return dmg.RunnerId == skillId end,
                self.dmgArray_Back,2,backLosses,SlgLocalConfig.FloatingTextStyle.Normal,isInCity,needShowInfo)

            if #losses > 0 then
                dmgInfo.losses = losses
            end

            if #backLosses > 0 then
                if not backdmgInfo then
                    ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillTargetInfo
                    backdmgInfo = {} 
                    backdmgInfo.targetId = attackerId
                   
                end
                backdmgInfo.losses = backLosses
            end
        end
        
        if targetInfo.buffs then
            ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillBuffInfo[]
            local buffInfos = {}
            local buffInfosIndex = 1
            for key, value in pairs(targetInfo.buffs) do
                -- body
                ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillBuffInfo
                local buffInfo = {}
                buffInfo.vfxPath = value.vfxPath
                buffInfo.yOffset = value.yOffset
                buffInfo.scale = value.scale                
                if needShowInfo then
                    buffInfo.info = SlgBattleManager.CreatedFloatingTextParam(value.nameStr,value.nameStyle,isInCity)                
                end                
                -- table.insert(buffInfos,buffInfo)
                buffInfos[buffInfosIndex] = buffInfo
                buffInfosIndex = buffInfosIndex + 1
            end
            dmgInfo.buffInfos = buffInfos            
        end
        if targetInfo.spState and targetInfo.spState > TroopConst.SP_STATE_SET_FLAG then
            dmgInfo.spState = targetInfo.spState
        end
        if dmgInfo.losses or dmgInfo.buffInfos then
            -- table.insert(damageInfos,dmgInfo) 
            damageInfos[damageInfosIndex] = dmgInfo
            damageInfosIndex = damageInfosIndex + 1
        end
        if backdmgInfo then
            -- table.insert(damageInfos,backdmgInfo)
            damageInfos[damageInfosIndex] = backdmgInfo
            damageInfosIndex = damageInfosIndex + 1
        end        
        if targetInfo.moveTo and (targetInfo.moveTo.X > 0 or targetInfo.moveTo.Y > 0 ) then
            ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillMovementInfo
            local movementInfo = {} 
            movementInfo.targetId = targetId
            movementInfo.targetPosition = self._module:ServerCoordinate2Vector3(targetInfo.moveTo)           
            -- table.insert(movementInfos,movementInfo)
            movementInfos[movementInfosIndex] = movementInfo
            movementInfosIndex = movementInfosIndex + 1
        end

        if not isMyTroopIsTarget then
            isMyTroopIsTarget = self._module.troopManager:IsMyExistingTroopId(targetId)
        end
    end

    skillData.targetInfo = damageInfos
    skillData.moveInfo = movementInfos
    if skillCastInfo.targetPos then
        skillData.targetPosition = self._module:GetTerrainPos(skillCastInfo.targetPos,0)

    else
        skillData.targetPosition = Float3_Zero
    end

    skillData.priority = (self._module.troopManager:IsMyExistingTroopId(attackerId) or isMyTroopIsTarget )and -1 or 0
    --Warning Range
    if skillCastInfo.rangeType and skillCastInfo.rangeType > 0 then
        skillData.rangeType        = skillCastInfo.rangeType             
        skillData.rangeVfxPath     = skillCastInfo.rangeVfxPath       
        skillData.rangeVfxScale    = skillCastInfo.rangeVfxScale      
        skillData.rangeOffset      = skillCastInfo.rangeOffset          
        skillData.rangeVfxDuration = skillCastInfo.rangeVfxDuration     
        skillData.rangeVfxSpeed    = skillCastInfo.rangeVfxSpeed         
    end

    return skillData
end

---@param attackerId number @attacker troop id
---@param defenderId number @defender troop id
---@param dmgData wrpc.Damage
---@param backDmgInfos wrpc.Damage[]
---@param exBackDmgInfos wrpc.Damage[]
---@param targetEntity wds.Troop | wds.MapMob | wds.MobileFortress | wds.SlgPuppet
---@return CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData
function SlgBattleManager:CreateNormalAttackData(attackerId,defenderId,dmgData,targetEntity)
    if dmgData == nil then return nil end

    local normalAttRunnerId = dmgData.RunnerId
    local heroIndex, petIndex = self:GetUnitIndexInTroop(attackerId, dmgData.SourceIndexParam)
    local targetHeroIndex,targetPetIndex = self:GetUnitIndexInTroop(defenderId, dmgData.TargetIndexParam)

    if normalAttRunnerId < 0 then
        return nil
    end
  
    local targetId = targetEntity.ID
    local targetTypeHash = targetEntity.TypeHash
    local targetPos = nil
    ---@type TroopCtrl | BuildingTroopCtrl
    local targetCtrl = nil

    if targetTypeHash == DBEntityType.Troop --wds.Troop.TypeHash 
        or targetTypeHash == DBEntityType.MapMob
        or targetTypeHash == DBEntityType.SlgPuppet
        or targetTypeHash == DBEntityType.MobileFortress       
    then      
        targetCtrl = self:GetCtrl(targetId)
        if not targetCtrl or not targetCtrl:IsValid() then
            return nil
        end
        targetPos = targetCtrl:GetPositionFloat3()
    else
        targetPos = self._module:ServerCoordinate2Float3(targetEntity.MapBasics.Position)        
    end
  
    local normalAttackAssetId = -1
    local normalAttackConfigId = -1
    
    local srcCtrl = self._module:GetTroopCtrl(attackerId)
    if not srcCtrl then
        local buildCtrl = self._module:GetBuildingCtrl(attackerId)
        if buildCtrl and buildCtrl:IsValid() then                        
            normalAttackAssetId = buildCtrl.normalAttId
            srcCtrl = buildCtrl
            heroIndex = 0
        end             
    else
        srcCtrl:CheckBattleState()
        normalAttackAssetId =  ModuleRefer.SlgModule.dataCache:GetSkillAssetId(dmgData.TemplateId) or 0
        normalAttackConfigId = dmgData.TemplateId
    end

    if srcCtrl == nil then
        return nil
    end
    
    if ShowDebugInfo then
        g_Logger.ErrorChannel('Exe Skill MSG','CreateNormalAttackData - RunnerId:%d | CfgId:%d | AssetId:%d | Attacker:%d(%d,%d) | Target:%d(%d,%d)',
            dmgData.RunnerId,    
            normalAttackConfigId,
            normalAttackAssetId,
            attackerId,
            heroIndex,
            petIndex,
            targetId,
            targetHeroIndex,
            targetPetIndex)        
    end   

    return self:CreateNormalAttackECSSkillData(attackerId,heroIndex,petIndex,normalAttackAssetId,
        normalAttRunnerId,targetId,targetHeroIndex,targetPetIndex,targetPos)
end

---@private
---@param attackerCtrl TroopCtrl | BuildingTroopCtrl
---@param heroId number
---@param skillCastInfo SkillCastInfo
---@param assetID number @KheroSkillLogicalConfigCell:Asset() or HeroClientResConfigCell:NormalAttAsset()
---@param attackData wrpc.Damage
---@return CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData
function SlgBattleManager:CreateNormalAttackECSSkillData(attackerId,heroIndex,petIndex,assetID,skillId,targetId,targetHeroIndex,targetPetIndex,targetPos)
    local attackerCtrl = self:GetCtrl(attackerId)
    local defenderCtrl = self:GetCtrl(targetId)
    
    ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData
    local skillData = {}
    skillData.skillId = skillId
    skillData.actorId = attackerCtrl and attackerCtrl.ID or attackerId  
    skillData.heroIndex = heroIndex - 1
    skillData.petIndex = petIndex - 1
    skillData.skillType = 1
    skillData.targetId = defenderCtrl and defenderCtrl.ID or targetId
    skillData.targetHeroIndex = targetHeroIndex - 1    
    skillData.targetPetIndex = targetPetIndex - 1
    skillData.stageType = 0    
    skillData.skillConfigId = assetID
    skillData.camShake = -1

    local isMyTroopIsTarget = self._module.troopManager:IsMyExistingTroopId(targetId)

    skillData.targetInfo = nil --(damageInfosIndex > 1) and damageInfos or nil
    skillData.moveInfo = nil
    skillData.targetPosition = targetPos or Float3_Zero 
    skillData.priority = (self._module.troopManager:IsMyExistingTroopId(attackerId) or isMyTroopIsTarget )and -1 or 0   

    return skillData
end

function SlgBattleManager:CanPopBattleEffect()
   
    local lod = self._module:GetLodValue()
    if lod < self._minLod or lod > self._maxLod then
        return false
    end
    return true
end


---@param troopEntity wds.Troop | wds.MapMob | wds.MobileFortress | wds.MapBuilding | ...
function SlgBattleManager:AttackDataFilter(troopEntity)
    if not troopEntity then
        return false
    end

    if troopEntity.TypeHash == DBEntityType.MapBuilding
        or troopEntity.TypeHash == DBEntityType.Village
    then
        return true
    end

    if troopEntity.Owner.PlayerID ==  self:MyPlayerId() 
        or (troopEntity.Owner.ExclusivePlayerId == self:MyPlayerId())
    then
        return true
    end

    if self._module:IsMyAlliance(troopEntity) then
        return true
    end
  
    return false
end




---@param entity wds.Troop | wds.MapMob | wds.MobileFortress | wds.MapBuilding | ...
function SlgBattleManager:NeedPopBattleInfo(entity)
    if not entity then return false end
    if self._module:IsInCity() then
        return true
    end
    --在外城只显示自己的部队攻击数据和友方部队受到的伤害数据
    --在内城显示所有部队的攻击数据和受到的伤害数据    
    if self:AttackDataFilter(entity) or self:IsTroopInRelation(entity.ID) then
        return true
    end  
    return false
end

---@param entityId number @ id of wds.Troop | wds.MapMob | wds.MobileFortress | wds.MapBuilding | ...
function SlgBattleManager:NeedPopBattleInfoById(entityId)
    if not entityId then return false end
    if self._module:IsInCity() then
        return true
    end
    --在外城只显示自己的部队攻击数据和友方部队受到的伤害数据
    --在内城显示所有部队的攻击数据和受到的伤害数据    
    if self._module.troopManager:IsMyExistingTroopId(entityId) or self:IsTroopInRelation(entityId) then
        return true
    end  
    return false
end

---@param m wrpc.PushBattleCommonDataRequest
function SlgBattleManager:ProcessBattleCommonData(success,m)
    if not success then
        return
    end

    if not self:CanPopBattleEffect() then return end
    local type = m.Msg.Data   
    if type == wrpc.CommonDataType.CommonDateType_TroopBeDefeated 
        or type == wrpc.CommonDataType.CommonDateType_MobBeDefeated
    then
        --战斗结束        
        local winerId = m.Msg.AttackerId
        local loserId = m.Msg.AttackederId
        local winerCtrl = self._module:GetTroopCtrl(winerId)
        local loserCtrl = self._module:GetTroopCtrl(loserId)

        if (winerCtrl and winerCtrl._data.MapStates.HideOnMap) or (loserCtrl and loserCtrl._data.MapStates.HideOnMap) then
            return
        end 
        
        if winerCtrl and winerCtrl:IsSelf() then
            if winerCtrl.troopView then
                winerCtrl.troopView:SetBattleResult(true)
            end        
            if loserCtrl and loserCtrl.troopView then
                loserCtrl.troopView:SetBattleResult(false)
            end
        elseif loserCtrl and loserCtrl:IsSelf() then
            if winerCtrl and winerCtrl.troopView then
                winerCtrl.troopView:SetBattleResult(true)
            end        
            if loserCtrl.troopView then
                loserCtrl.troopView:SetBattleResult(false)
            end
        end 
    end
end


function SlgBattleManager:GetRoundCacheData(round,troopId)    
    if self.roundCache == nil then
        self.roundCache = {
            round = round,
            timestamp = g_Game.Time.time,
            attackDatas = {},
            otherDamageDatas = {},
        }
    elseif self.roundCache.round ~= round then
        g_Logger.WarnChannel('Exe Skill MSG','Aband Round:' .. tostring(self.roundCache.round))
        if ShowDebugInfo then
            self.roundCacheDataBackup[self.roundCache.round] = self.roundCache
        end
        self.roundCache = {
            round = round,
            timestamp = g_Game.Time.time,
            attackDatas = {},
            otherDamageDatas = {},
        }
    end

    if troopId and troopId > 0 then        
        self:EnsureTroopAttackCacheData(troopId)   
    end
    return self.roundCache
end

function SlgBattleManager:EnsureTroopAttackCacheData(troopId)
    if not self.roundCache or not self.roundCache.attackDatas then
        return
    end
    if not self.roundCache.attackDatas[troopId] then
        self.roundCache.attackDatas[troopId] = {
            ---@type table<number, RoundAttackDamageCacheData>
            dmgData = {}
        }
    end    
end

------------------------------------------------------------------------------------------------
---Process Battle Attack Message
------------------------------------------------------------------------------------------------
---@private
---@param targetEntity wds.Troop | wds.MapMob | wds.MobileFortress | wds.MapBuilding ...
---@param attackDatas table<number,wrpc.Attack>
function SlgBattleManager:CacheAttackData(targetEntity,attackDatas)
    local targetTroopId = targetEntity.ID
    local cacheData = self.roundCache         
    for attTroopId, attack in pairs(attackDatas) do

        if not cacheData or cacheData.round < attack.Round then
            cacheData = self:GetRoundCacheData(attack.Round,attTroopId)              
        elseif cacheData and cacheData.round > attack.Round then
            goto continue_CacheAttackData
        else            
            --检查self.roundCache.attackDatas[attTroopId]是否存在
            self:EnsureTroopAttackCacheData(attTroopId)               
        end
            
        ---cache other damage which not trigger by skill       
        local normalKey = SlgLocalConfig.FloatingTextStyle.Normal
        local buffKey = SlgLocalConfig.FloatingTextStyle.Normal
        local healKey = SlgLocalConfig.FloatingTextStyle.Healing
        local durableKey = SlgLocalConfig.FloatingTextStyle.Durable
        cacheData.attackDatas[attTroopId].dmgData[targetTroopId] = {attack = attack,target = targetEntity}
        self.dmgArray_Normal[1] = attack.NormalDamageInfos
        self.dmgArray_Normal[2] = attack.ExtraChaseInfos
        self.dmgArray_Normal[3] = attack.PassiveDamageInfos
        self.dmgArray_Normal[4] = attack.FixDamageInfos
        self.dmgArray_Normal[5] = attack.AttrDamageInfos
        self.dmgArray_Normal[6] = attack.RageDamageInfos
        -- self.dmgArray_Normal[4] = attack.DurabilityInfos
        --当SkillId == 0 时，为建筑总伤害包中的伤害数据，不绑定特定部队
        --低配模式下，只显示英雄的攻击数据
        local roundDamage,cirtical = SlgBattleManager.SumAllDamage(0,self.dmgArray_Normal)           
        self.dmgArray_Heal[1] = attack.HealInfos
        local roundHeal, healCircal = SlgBattleManager.SumAllDamage(0,self.dmgArray_Heal)
        local durableDamage = SlgBattleManager.SumDamage(0,attack.DurabilityInfos)
        if roundDamage > 0 or roundHeal > 0 or durableDamage > 0 then                       
            if not cacheData.otherDamageDatas[targetTroopId] then
                cacheData.otherDamageDatas[targetTroopId] ={}
            end  
            if roundDamage > 0 then
                if not cacheData.otherDamageDatas[targetTroopId][normalKey] then
                    cacheData.otherDamageDatas[targetTroopId][normalKey] =
                    {
                        target = targetEntity,
                        position = self._module:ServerCoordinate2Float3(targetEntity.MapBasics.Position),
                        damage = 0
                    }
                end              
                cacheData.otherDamageDatas[targetTroopId][normalKey].damage = cacheData.otherDamageDatas[targetTroopId][normalKey].damage + roundDamage                
                cacheData.otherDamageDatas[targetTroopId][normalKey].critical = cirtical  
            end
            
            if roundHeal > 0 then
                if not cacheData.otherDamageDatas[targetTroopId][healKey] then
                    cacheData.otherDamageDatas[targetTroopId][healKey] =
                    {
                        target = targetEntity,
                        position = self._module:ServerCoordinate2Float3(targetEntity.MapBasics.Position),
                        damage = 0
                    }
                end              
                cacheData.otherDamageDatas[targetTroopId][healKey].damage = cacheData.otherDamageDatas[targetTroopId][healKey].damage + roundHeal                
                cacheData.otherDamageDatas[targetTroopId][healKey].critical = healCircal  
            end

            if durableDamage then
                if not cacheData.otherDamageDatas[targetTroopId][durableKey] then
                    cacheData.otherDamageDatas[targetTroopId][durableKey] =
                    {
                        target = targetEntity,
                        position = self._module:ServerCoordinate2Float3(targetEntity.MapBasics.Position),
                        damage = 0
                    }
                end              
                cacheData.otherDamageDatas[targetTroopId][durableKey].damage = cacheData.otherDamageDatas[targetTroopId][durableKey].damage + durableDamage                
                cacheData.otherDamageDatas[targetTroopId][durableKey].critical = false  
            end

        end

        local needShowBuff = true
        if not self._module:IsInCity() then
            --在外城只显示自己的部队攻击数据和友方部队受到的伤害数据
            --在内城显示所有部队的攻击数据和受到的伤害数据
            if not self:NeedPopBattleInfoById(attTroopId) and not self:NeedPopBattleInfo(targetEntity) then
                needShowBuff = false
            end  
        end
         --buff
         if needShowBuff and attack.BuffDamageInfos and attack.BuffDamageInfos[1] then
            local buffDamage = 0
            local isCritical = false
            for key, value in pairs(attack.BuffDamageInfos) do
                buffDamage = buffDamage + value.Value
                if value.IsCritical then
                    isCritical = true
                end
            end

            if buffDamage > 0 then
                if not cacheData.otherDamageDatas[targetTroopId] then
                    cacheData.otherDamageDatas[targetTroopId] ={}
                end  
                if not cacheData.otherDamageDatas[targetTroopId][buffKey] then
                    cacheData.otherDamageDatas[targetTroopId][buffKey] =
                    {
                        target = targetEntity,
                        damage = 0
                    }
                end              
                cacheData.otherDamageDatas[targetTroopId][buffKey].damage = cacheData.otherDamageDatas[targetTroopId][buffKey].damage + buffDamage                
                cacheData.otherDamageDatas[targetTroopId][buffKey].critical = isCritical
            end
        end    
      
        ::continue_CacheAttackData::
    end   
end
---@private
---@param id number @KheroSkillLogicalConfigCell:Id()
---@return KheroSkillLogicalCache
function SlgBattleManager:GetHeroSkillLogicalData(id)
    if self.heroSkillLogicalCaches == nil then
        self.heroSkillLogicalCaches = {}
    end
    if self.heroSkillLogicalCaches[id] ~= nil then
        return self.heroSkillLogicalCaches[id]
    end
    local skill = ConfigRefer.KheroSkillLogical:Find(id)
    if skill then
        ---@type KheroSkillLogicalCache
        local data = {            
            Asset = skill:Asset(),
            AssetInCity = skill:AssetInCity(),
            SkillName = I18N.Get(skill:NameKey()),
            RangeType = skill:RangeType(),
            Shape = skill:Shape(),
            ShiftDistance = skill:ShiftDistance(),
            Length = skill:Length(),
            Width = skill:Width(),
            Angle = skill:Angle(),
            TimeParam = skill:TimeParam(),
            SkilType = skill:SkilType(),
            ShowRange = skill:CircleShow()
        }
        if skill:FilterTypesLength() > 0 then
            data.FirstFilterType = skill:FilterTypes(1)
        end
        self.heroSkillLogicalCaches[id] = data
        return data
    end
end

---@private
---@param curTroopId number
---@param skillCastList wrpc.SLGSkillCastRPC[]
function SlgBattleManager:CacheSkillData(curTroopId,skillCastList)
    local fromSelf = self._module.troopManager:IsMyExistingTroopId(curTroopId)

    local roundData = self.roundCache
    if not roundData then
        roundData = self:GetRoundCacheData(skillCastList[1].MsgSkill.Round,curTroopId)
    elseif not roundData.attackDatas[curTroopId] then
        self:EnsureTroopAttackCacheData(curTroopId)
    end      
    if not roundData.attackDatas[curTroopId].skillDatas then
        roundData.attackDatas[curTroopId].skillDatas = {}
    end
    ---@type table<number,RoundAttackSkillCacheData>
    local cacheDatas = roundData.attackDatas[curTroopId].skillDatas

    for i, skillCastMsg in ipairs(skillCastList) do
        --低配模式下，只显示英雄的攻击数据
        if self._module.LowMode and skillCastMsg.MsgSkill.SkillInfo.ReleaseIndexParam.Typo ~= wrpc.IndexParamType.IndexParamType_Hero then
            goto continue_CacheSkillData
        end
        if skillCastMsg.MsgSkill.Attacker ~= curTroopId then
            g_Logger.WarnChannel("Exe Skill MSG","SkillCastMsg Error,MSG.Target:%d | SkillCastMsg.Attacker:%d",curTroopId,skillCastMsg.MsgSkill.Attacker)
            goto continue_CacheSkillData
        end
        if roundData.round ~= skillCastMsg.MsgSkill.Round then
            g_Logger.WarnChannel('Exe Skill MSG','Skill Cast in Aband Round - cur:' .. tostring(roundData.round) .. 'msg:' .. tostring(skillCastMsg.MsgSkill.Round))
            goto continue_CacheSkillData
        end

        local skillInfo = skillCastMsg.MsgSkill.SkillInfo
        if cacheDatas and cacheDatas[skillInfo.RunnerId] then
            goto continue_CacheSkillData
        end
        local skillcfg = skillInfo and self:GetHeroSkillLogicalData(skillInfo.SkillCfgId) --ConfigRefer.KheroSkillLogical:Find(skillInfo.SkillCfgId) or nil
        if skillcfg then       
            ---@type RoundAttackSkillCacheData
            local skillData= {}
            skillData.data = skillCastMsg
            skillData.cfg = skillcfg
            skillData.fromSelf = fromSelf
            cacheDatas[skillInfo.RunnerId] = skillData
        end
        ::continue_CacheSkillData::
    end    
end

---@param troopId number
---@param changed wds.Battle
function SlgBattleManager:CacheTroopBattleState(troopId,changed)    
    if not changed then
        return
    end
    if not self.troopDataCache then
        self.troopDataCache = {}
    end
    ---@type TroopStateRoundData
    local troopStateData = {}
    local needCache = false
    if changed.Group and changed.Group.Heros then
        ---@type  table<number, wds.TroopHero> | MapField
        local heroDatas = changed.Group.Heros
        troopStateData.heroState = {}
        troopStateData.petState = {}
        for key, value in pairs(heroDatas) do
            if value.Hp and value.Hp < 1 then
                needCache = true
                troopStateData.heroState[key] = 0
                g_Logger.LogChannel('Troop State','Hero-'.. tostring(key) .. ' is Dead!!! ID:' .. tostring(troopId))
            end           
            if value.Pets and value.Pets[0] then
                local pet = value.Pets[0]
                if pet.Hp and pet.Hp < 1 then
                    g_Logger.LogChannel('Troop State','Pet-'.. tostring(key) .. ' is Dead!!! ID:' .. tostring(troopId))
                    needCache = true
                    troopStateData.petState[key] = 0
                end
            end
        end
    end
    --TODO: 检查是否会在同一回合内多次调用
    if needCache then
        self.troopDataCache[troopId] = troopStateData
    end
end

-- 处理后端PUSH数据
function SlgBattleManager:OnExecuteRound()
    if not self.roundCache 
        or g_Game.Time.time - self.roundCache.timestamp < 0.1 --add 100ms delay
    then
        return
    end    
   
    g_Game.TroopViewManager:OnRoundBegin(self.roundCache.round)   
    self:InitCurrentRoundDamage(self.roundCache.round)
    
    local roundData = self.roundCache
    if ShowDebugInfo then
        g_Logger.LogChannel('SlgBattleManager','[OnExecuteRound] Execute Round:' .. tostring(roundData.round))
        self.roundCacheDataBackup[self.roundCache.round] = self.roundCache
    end

    if not self.curRound or self.curRound < roundData.round then
        self.curRound = roundData.round
    end

    self.roundCache = nil
    ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData[]
    local ecsSkillDatas = {}
    local ecsSkillDatasIndex = 0
    local normalKey = SlgLocalConfig.FloatingTextStyle.Normal
    local durableKey = SlgLocalConfig.FloatingTextStyle.Durable
    local healKey = SlgLocalConfig.FloatingTextStyle.Healing
    for attackerId, data in pairs(roundData.attackDatas) do
        ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData     
        local attackerSkillData = nil
        
        local exeSkillCfgIds = {}
        if data.skillDatas and not table.isNilOrZeroNums(data.skillDatas) then
            for skillId, cacheData in pairs(data.skillDatas) do
                ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData                     
                local skillData = self:CreateSkillData(cacheData.data,cacheData.cfg,data.dmgData)
                if skillData then
                    ecsSkillDatas[ecsSkillDatasIndex+1] = skillData
                    ecsSkillDatasIndex = ecsSkillDatasIndex + 1
                    if not attackerSkillData then
                        attackerSkillData = skillData
                    end
                    table.insert(exeSkillCfgIds,cacheData.data.MsgSkill.SkillInfo.SkillCfgId)
                end   
            end
        elseif data.dmgData then        
            for defenderId, attDmgData in pairs(data.dmgData) do
                local attCtrl = self:GetCtrl(attackerId)
                local attData = SlgUtils.GetEntityById(attackerId)
                if attCtrl and (attCtrl:IsVisible() or SlgUtils.IsTroopInRally(attData)) then
                    local heroDmgData = self:GetNormalDamageData(-1,attDmgData.attack, wrpc.IndexParamType.IndexParamType_Hero)
                    if heroDmgData then
                        ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillData 
                        local heroSkillData = nil
                        heroSkillData = self:CreateNormalAttackData(attackerId,defenderId,heroDmgData,attDmgData.target)                
                        if heroSkillData then
                            ecsSkillDatas[ecsSkillDatasIndex+1] = heroSkillData
                            ecsSkillDatasIndex = ecsSkillDatasIndex + 1
                        end
                        attackerSkillData = heroSkillData     
                    end

                    local petDmgData = self:GetNormalDamageData(-1,attDmgData.attack, wrpc.IndexParamType.IndexParamType_Pet)
                    if petDmgData then
                        local petSkillData = nil
                        petSkillData = self:CreateNormalAttackData(attackerId,defenderId,petDmgData,attDmgData.target)                
                        if petSkillData then
                            ecsSkillDatas[ecsSkillDatasIndex+1] = petSkillData
                            ecsSkillDatasIndex = ecsSkillDatasIndex + 1
                        end
                    end
                end 
            end            
        end       
        
        if data.dmgData then
            for targetId, dmg in pairs(data.dmgData) do
                if dmg.triggered then
                    goto continue_OnExecuteRound
                end
                self.dmgArray_Normal[1] = dmg.attack.NormalDamageInfos
                self.dmgArray_Normal[2] = dmg.attack.ExtraChaseInfos
                self.dmgArray_Normal[3] = dmg.attack.PassiveDamageInfos
                self.dmgArray_Normal[4] = dmg.attack.FixDamageInfos
                self.dmgArray_Normal[5] = dmg.attack.AttrDamageInfos
                self.dmgArray_Normal[6] = dmg.attack.RageDamageInfos
                local roundDamage,_ = SlgBattleManager.SumAllDamage(nil,self.dmgArray_Normal)
                local durableDamage,_ = SlgBattleManager.SumDamage(nil,dmg.attack.DurabilityInfos)              
                local healValue,_ = SlgBattleManager.SumDamage(nil,dmg.attack.HealInfos)                
                if roundDamage <= 0 and healValue <= 0 and durableDamage <= 0 then
                    goto continue_OnExecuteRound
                end
                if not roundData.otherDamageDatas[targetId] then
                    roundData.otherDamageDatas[targetId] = {}
                end
                if roundDamage > 0 then
                    if not roundData.otherDamageDatas[targetId][normalKey] then
                        roundData.otherDamageDatas[targetId][normalKey] = {
                            target = dmg.target,
                            position = self._module:ServerCoordinate2Float3(dmg.target.MapBasics.Position),
                            damage = 0
                        }
                    end            
                    roundData.otherDamageDatas[targetId][normalKey].damage = roundData.otherDamageDatas[targetId][normalKey].damage + roundDamage
                    -- if cirtical then
                    --     roundData.otherDamageDatas[targetId][normalKey].critical = true
                    -- end
                end

                if healValue > 0 then
                    if not roundData.otherDamageDatas[targetId][healKey] then
                        roundData.otherDamageDatas[targetId][healKey] = {
                            target = dmg.target,
                            position = self._module:ServerCoordinate2Float3(dmg.target.MapBasics.Position),
                            damage = 0
                        }
                    end 
                    roundData.otherDamageDatas[targetId][healKey].damage = roundData.otherDamageDatas[targetId][healKey].damage + healValue 
                end
                if durableDamage > 0 then
                    if not roundData.otherDamageDatas[targetId][durableKey] then
                        roundData.otherDamageDatas[targetId][durableKey] = {
                            target = dmg.target,
                            position = self._module:ServerCoordinate2Float3(dmg.target.MapBasics.Position),
                            damage = 0
                        }
                    end 
                    roundData.otherDamageDatas[targetId][durableKey].damage = roundData.otherDamageDatas[targetId][durableKey].damage + durableDamage
                end
                --- round = 0 是为了当前回合立即更新，技能的伤害数据在下一回合更新
                self:CacheSkillDamage(0,0,targetId,roundDamage - healValue,false)
                ::continue_OnExecuteRound::
            end
        end
        if attackerSkillData then
            local troopCtrl = self:GetTroopCtrl(attackerId)
            if troopCtrl then
                if #exeSkillCfgIds > 0 then
                    troopCtrl:OnExeSkill(exeSkillCfgIds)
                end
            else
                local buildingCtrl = self._module:GetBuildingCtrl(attackerId)
                if buildingCtrl then
                    if attackerSkillData.skillId > 0 then
                        buildingCtrl:PlaySkill(attackerSkillData.skillConfigId,attackerSkillData.targetPosition,self._module.dataCache)
                    else
                        buildingCtrl:PlayNormalAtt(attackerSkillData.targetPosition,self._module.dataCache)
                    end
                end
            end
        end       
    end
    if ecsSkillDatasIndex > 0 then
        g_Game.TroopViewManager:TransferSkillDatas(ecsSkillDatas)
    end
        
    ---@type table<int,CS.DragonReborn.SLG.Troop.TroopViewManager.TroopRoundData>
    local troopRoundDatas = {}
    local dataIndex = 0
    local isInCity = self._module:IsInCity()
    if roundData.otherDamageDatas then
        for troopId, dataMap in pairs(roundData.otherDamageDatas) do
            ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopRoundData
            local troopRoundData = {}
            troopRoundData.troopId = troopId
            -- troopRoundData.infos = {}
            local infos = {}
            for typeKey, data in pairs(dataMap) do
                if data.position then
                    troopRoundData.position = data.position
                end
                if data.damage > 0 then
                    local style = typeKey
                    if data.critical then
                        style = SlgLocalConfig.FloatingTextStyle.Critical
                    end
                    table.insert(infos,
                        SlgBattleManager.CreatedFloatingTextParam(data.damage,style,isInCity)
                    )     
                    if ShowDebugInfo then
                        g_Logger.LogChannel('Exe Skill MSG','TroopId:' .. tostring(troopId) .. ' | Damage:' .. tostring(data.damage) .. ' | Style:' .. tostring(style))
                    end
                end
            end
            troopRoundData.infos = infos
            troopRoundDatas[troopId] = troopRoundData
            dataIndex = dataIndex + 1
        end
    end
    --同步部队死亡状态
    if self.troopDataCache then
        for troopId, data in pairs(self.troopDataCache) do
            local troopRoundData = troopRoundDatas[troopId]
            if not troopRoundData then
                ---@type CS.DragonReborn.SLG.Troop.TroopViewManager.TroopRoundData
                troopRoundData = {}
                troopRoundData.troopId = troopId
                dataIndex = dataIndex + 1
                troopRoundDatas[troopId] = troopRoundData
            end
            if data.heroState then
                local deadIndex = 1
                local deadHeroIndexes = {}
                local deadHeroState = {}
                for key, value in pairs(data.heroState) do
                    deadHeroIndexes[deadIndex] = key
                    deadHeroState[deadIndex] = value
                    deadIndex = deadIndex + 1
                end
                troopRoundData.heroIndexes = deadHeroIndexes
                troopRoundData.heroStates = deadHeroState
            end
            if data.petState then
                local deadIndex = 1
                local deadPetIndexes = {}
                local deadPetState = {}
                for key, value in pairs(data.petState) do
                    deadPetIndexes[deadIndex] = key
                    deadPetState[deadIndex] = value
                    deadIndex = deadIndex + 1
                end
                troopRoundData.petIndexes = deadPetIndexes
                troopRoundData.petStates = deadPetState
            end
        end
        self.troopDataCache = nil
    end

    if dataIndex > 0 then
        g_Game.TroopViewManager:TransferRoundData(troopRoundDatas)
    end 

    --Sync Troop Hp
    self:SyncTroopHpByDamageCache()    
end
------------------------------------------------------------------------------------------------

function SlgBattleManager:Tick()
    self:OnExecuteRound()
    if self.skillDamageEventList then        
        for i = 1, #self.skillDamageEventList do
            local attId = self.skillDamageEventList[i].attId
            local damageKey = self.skillDamageEventList[i].dmgKey
            local cacheDataTable = self.skillDamageCache[attId]
            local cacheData = cacheDataTable and cacheDataTable[damageKey] or nil
            if cacheData then
                if cacheData.targetDamage then
                    for troopId, data in pairs(cacheData.targetDamage) do
                        if data.damage and data.damage > 0 then
                            local ctrl = self._module.troopManager:FindTroopCtrl(troopId)
                            if ctrl then
                                ctrl:UpdateCurrentHP(data.needShake)
                            end
                        end
                    end
                end
                self.skillDamageCache[attId][damageKey] = nil
            end
        end
        self.skillDamageEventList = nil
        local damageKeys = table.keys(self.skillDamageCache)
        if damageKeys and #damageKeys > 0 then
            for _, key in pairs(damageKeys) do
                local value = self.skillDamageCache[key]
                if value and value.round and self.curRound - value.round > 3 then
                    self.skillDamageCache[key] = nil
                end
            end
        end
   end
end

---@param attackerIds CS.System.Array
---@param damageKeys CS.System.Array
function SlgBattleManager:OnSkillDamageEvent(attackerIds,damageKeys)
    if not damageKeys or damageKeys.Length < 1 then
        return
    end
    
    if not self.skillDamageEventList then
        self.skillDamageEventList = {}        
    end
    local len = #self.skillDamageEventList
    local begin = len + 1;

    local addLength = damageKeys.Length
    for i = 0, addLength - 1 do
        self.skillDamageEventList[i + begin] = {}
        self.skillDamageEventList[i + begin].attId = attackerIds[i]
        self.skillDamageEventList[i + begin].dmgKey = damageKeys[i]
    end    
end
function SlgBattleManager:CreateDamageKeyCache(skillId,round)
    self.skillDamageCache[skillId] = {}
    self.skillDamageCache[skillId].round = round
    self.skillDamageCache[skillId].targetDamage = {}
end

function SlgBattleManager:InitCurrentRoundDamage(round)
    self.troopDamageCache[round] = {}
end

function SlgBattleManager:CacheSkillDamage(round, skillId,troopId,loss,needShake)
    if math.abs(loss) < 0.001 then
        return
    end
    if skillId and skillId > 0 then 
        if not self.skillDamageCache[skillId] then
            self:CreateDamageKeyCache(skillId,round)
        end
        self.skillDamageCache[skillId].targetDamage[troopId] = {damage = loss,needShake = needShake}
    end
    if not self.troopDamageCache[round] then
        self.troopDamageCache[round] = {}
    end
    if not self.troopDamageCache[round][troopId] then
        self.troopDamageCache[round][troopId] = 0
    end
    self.troopDamageCache[round][troopId] = self.troopDamageCache[round][troopId] + loss
end

function SlgBattleManager:SyncTroopHpByDamageCache()
    if not self.curRound then
        return
    end
    local checkRound = self.curRound - 1
    if self.troopDamageCache[checkRound] then        
        for troopId, damage in pairs(self.troopDamageCache[checkRound]) do
            local ctrl = self._module:GetCtrl(troopId)
            if ctrl then
                ctrl:SyncBattleHpAtRoundEnd()
            end            
        end
        self.troopDamageCache[checkRound] = nil
    end
    if table.morethan(self.troopDamageCache,1) then
        local needSyncHpTroopIds = {}
        local needDelKeys = {}
        for round, data in pairs(self.troopDamageCache) do
            if round ~= self.curRound then
                for troopId, damage in pairs(data) do
                    table.insert(needSyncHpTroopIds,troopId)
                end
                table.insert(needDelKeys,round)
            end
        end
        if #needSyncHpTroopIds > 0 then
            for i = 1, #needSyncHpTroopIds do
                local troopId = needSyncHpTroopIds[i]
                local ctrl = self._module:GetCtrl(troopId)
                if ctrl then
                    local curRoundDam = 0
                    if self.troopDamageCache[self.curRound][troopId] then
                        curRoundDam = self.troopDamageCache[self.curRound][troopId]
                    end
                    ctrl:SyncBattleHpAtRoundEnd()                               
                end
            end
        end

        if #needDelKeys > 0 then
            for i = 1, #needDelKeys do
                self.troopDamageCache[needDelKeys[i]] = nil
            end
        end        
    end
end

function SlgBattleManager:GetSkillCamShakeParam(skillId)
    if not skillId or skillId < 1 then return nil end
    local skillCfg = self._module.dataCache:GetSkillAssetCache(skillId)
    if skillCfg and skillCfg.camShake then
        local shakeParam = skillCfg.camShake
        local scale = self._module.slgScale
        local moveExt = {
            x = shakeParam.MoveExtents.x * scale,
            y = shakeParam.MoveExtents.y * scale,
            z = shakeParam.MoveExtents.z * scale
        }
        return {
            Shake = shakeParam.Shake,
            Noise = shakeParam.Noise,
            MoveExt = moveExt,
            RotateExtents = shakeParam.RotateExtents,
            Speed = shakeParam.Speed,
            Time = shakeParam.Time
        }
    end
    return nil
end
---@return SkillBuffParam[]
function SlgBattleManager:GetBuffParams(cfgIds,showBuffName)
    local params = nil
    local index = 1
    for key, cfgId in pairs(cfgIds) do
        if self.buffCfgCache == nil then
            self.buffCfgCache = {}
        end
        local buffCfg = nil
        local buffArt = nil       
        if self.buffCfgCache[cfgId] then
            buffCfg = self.buffCfgCache[cfgId].cfg
            buffArt = self.buffCfgCache[cfgId].art
        else
            local buffCfgCell = ConfigRefer.KheroBuffLogical:Find(cfgId)                
            local buffArtCell = ConfigRefer.ArtResource:Find( buffCfgCell and buffCfgCell:Resource() or 0)        
            buffCfg = {}
            if buffCfgCell then
                buffCfg.name = I18N.Get(buffCfgCell:NameKey())
                buffCfg.isPositive = buffCfgCell:IsPositive()  
            end
            buffArt = {}
            buffArt.yOffset = 0
            if buffArtCell ~= nil then
                if( buffArtCell:ModelPositionLength() > 0) then
                    local yOffsetType = buffArtCell:ModelPosition(1)
                    if yOffsetType >= 0.9 then
                        buffArt.yOffset = 1
                    end
                end
                buffArt.vfxPath = buffArtCell:Path()
                buffArt.scale = buffArtCell:ModelScale()
            end

            self.buffCfgCache[cfgId] = {
                cfg = buffCfg,
                art = buffArt,
            }
        end
        ---@type SkillBuffParam
        local buffParam = {}
        local needCache = false
        if buffArt then
            buffParam.vfxPath = buffArt.vfxPath
            buffParam.yOffset = buffArt.yOffset
            buffParam.scale = buffArt.scale
            needCache = true
        end
        if showBuffName then
            buffParam.nameStr = buffCfg.name 
            local isPositive = buffCfg.isPositive
            if isPositive then
                buffParam.nameStyle = SlgLocalConfig.FloatingTextStyle.BlueName
            else
                buffParam.nameStyle = SlgLocalConfig.FloatingTextStyle.RedName
            end
            if not string.IsNullOrEmpty(buffParam.nameStr) then
                needCache = true
            end
        end
        if needCache then
            if not params then
                params = {}
            end
            params[index] = buffParam
            index = index + 1
        end
    end
    return params
end

---@private
---@return CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillFloatingTextParam
function SlgBattleManager.CreatedFloatingTextParam(content,style,isInCity)
    if string.IsNullOrEmpty(content) then
        return nil
    end   
    return SlgBattleManager.CreatedFloatingTextParamInternal(SlgLocalConfig.FloatingTextValueType.String,0,content,style,isInCity)
end
---@private
---@return CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillFloatingTextParam
function SlgBattleManager.CreateFloatingNumberParam(value,style,isInCity)
    if style == SlgLocalConfig.FloatingTextStyle.Normal then
        return SlgBattleManager.CreatedFloatingTextParamInternal(SlgLocalConfig.FloatingTextValueType.Number,value,'',style,isInCity)
    else        
        return SlgBattleManager.CreatedFloatingTextParamInternal(SlgLocalConfig.FloatingTextValueType.String,0,tostring(value),style,isInCity)
    end
end

---@private
---@return CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillFloatingTextParam
function SlgBattleManager.CreatedFloatingTextParamInternal(valueType,intValue,strValue,style,isInCity)    
    local param = {}
    param.type = valueType
    param.intValue = intValue or 0
    param.strValue = strValue or ''
    style = style or SlgLocalConfig.FloatingTextStyle.Normal
    param.style = style
    param.duration = UISlgBattleInfo.GetTextLifeForStyle(style)
    param.offset = UISlgBattleInfo.GetTextOffsetForStyle(style,isInCity)
    return param
end

---@param skillId number
---@param dmgDatas wrpc.Damage[]
---@param herosIndex table<number,number>
---@return table<number,table> @damageValues
function SlgBattleManager.GetSkillDamageParam(skillId,dmgDatas,herosIndex)
    if not dmgDatas then
        return nil
    end
    local damageValues = {}   
    for key, value in pairs(dmgDatas) do
        if value.RunnerId == skillId then
            if not herosIndex[value.TargetHeroIndex] then
                herosIndex[value.TargetHeroIndex] = 1
            end
            if damageValues[value.NormalAttackIndex] == nil then
                damageValues[value.NormalAttackIndex] = {
                    value = 0,
                    critical = false
                }
            end
            damageValues[value.NormalAttackIndex].value = damageValues[value.NormalAttackIndex].value + value.Value
            if value.IsCritical then
                damageValues[value.NormalAttackIndex].critical = true        
            end        
        end
    end
    return damageValues
end

---@param filter fun(dmg:wrpc.Damage) @return boolean
---@param dmgDatasArray wrpc.Damage[][]
---@param losses CS.DragonReborn.SLG.Troop.TroopViewManager.TroopSkillFloatingTextParam[]
function SlgBattleManager.CreateLossDataArray(filter,dmgDatasArray,length,losses,style,isInCity,showInfo)
    if not dmgDatasArray then
        return
    end
    
    local sumDamage = {}    
    local hasDmg = false
    for i = 1, length do      
        local dmgDatas = dmgDatasArray[i]
        if not dmgDatas then
            goto continue_CreateLossDataArray
        end          
        for key, value in pairs(dmgDatas) do
            if filter(value) then
                local attIndex = value.NormalAttackIndex
                if not sumDamage[attIndex] then
                    sumDamage[attIndex] = {
                        value = 0,
                        critical = false
                    }
                end
                sumDamage[attIndex].value = sumDamage[attIndex].value + value.Value
                if value.IsCritical  then
                    sumDamage[attIndex].critical = true
                end                
                hasDmg = true
            end
        end
        ::continue_CreateLossDataArray::
    end
    if not hasDmg or not showInfo then
        return
    end
    for key, damage in pairs(sumDamage) do
        if damage.critical then
            style = SlgLocalConfig.FloatingTextStyle.Critical
        end
        if damage.value > 0 then
            local loss = SlgBattleManager.CreatedFloatingTextParam(damage.value,style,isInCity)
            table.insert(losses,loss)
        end
    end
end

---@param skillId number
---@param attack wrpc.Attack
---@return number,number @Damage Sum,back damage
function SlgBattleManager:CalcAttackDamageValue(skillId,attack)
    self.dmgArray_Normal[1] = attack.NormalDamageInfos
    self.dmgArray_Normal[2] = attack.ExtraChaseInfos
    self.dmgArray_Normal[3] = attack.PassiveDamageInfos
    self.dmgArray_Normal[4] = attack.FixDamageInfos
    self.dmgArray_Normal[5] = attack.AttrDamageInfos
    self.dmgArray_Normal[6] = attack.RageDamageInfos
    -- self.dmgArray_Normal[4] = attack.DurabilityInfos
    local attDamage,_ = SlgBattleManager.SumAllDamage(skillId,self.dmgArray_Normal)

    self.dmgArray_Heal[1] = attack.HealInfos
    local heal = SlgBattleManager.SumAllDamage(skillId,self.dmgArray_Heal)

    self.dmgArray_Back[1] = attack.BackDamageInfos
    self.dmgArray_Back[2] = attack.ExtraBackInfos
    local backDamage,_ = SlgBattleManager.SumAllDamage(skillId,self.dmgArray_Back)

    return attDamage - heal, backDamage
end

---@param attack wrpc.Attack
---@return wrpc.IndexParam
function SlgBattleManager:FindAttackDamageTarget(skillId,attack)
    self.dmgArray_Normal[1] = attack.NormalDamageInfos
    self.dmgArray_Normal[2] = attack.ExtraChaseInfos
    self.dmgArray_Normal[3] = attack.PassiveDamageInfos
    self.dmgArray_Normal[4] = attack.FixDamageInfos
    self.dmgArray_Normal[5] = attack.AttrDamageInfos
    self.dmgArray_Normal[6] = attack.RageDamageInfos
    local indexParam = SlgBattleManager.FindDamageTarget(skillId,self.dmgArray_Normal)    
    if not indexParam and attack.HealInfos then
        for _, value in pairs(attack.HealInfos) do
            if  not skillId or value.RunnerId == skillId then
                return value.TargetIndexParam
            end
        end
    end
    return indexParam
end

---@param dmgDatasArray wrpc.Damage[][]
---@param ignorePet boolean @低配模式下，只显示英雄的攻击数据
---@return number,boolean @Damage Sum,IsCritical
function SlgBattleManager.SumAllDamage(skillId,dmgDatasArray,ignorePet)
    local sum = 0
    local isCritical = false  
   for _, dmgDatas in pairs(dmgDatasArray) do
        if dmgDatas then
            for _, value in pairs(dmgDatas) do
                if ignorePet and value.SourceIndexParam.Typo == wrpc.IndexParamType.IndexParamType_Pet then
                    goto continue_SumAllDamage
                end
                if not skillId or value.RunnerId == skillId then
                    sum = sum + value.Value
                    if value.IsCritical then
                        isCritical = true
                    end
                end
                ::continue_SumAllDamage::
            end
        end
    end
    return sum,isCritical
end

---@param dmgDatasArray wrpc.Damage[]
---@param ignorePet boolean @低配模式下，只显示英雄的攻击数据
---@return number,boolean @Damage Sum,IsCritical
function SlgBattleManager.SumDamage(skillId,dmgDatas,ignorePet)
    local sum = 0
    local isCritical = false  
   
    if dmgDatas then
        for _, value in pairs(dmgDatas) do
            if ignorePet and value.SourceIndexParam.Typo == wrpc.IndexParamType.IndexParamType_Pet then
                goto continue_SumAllDamage
            end
            if not skillId or value.RunnerId == skillId then
                sum = sum + value.Value
                if value.IsCritical then
                    isCritical = true
                end
            end
            ::continue_SumAllDamage::
        end
    end
    return sum,isCritical
end


---@param dmgDatasArray wrpc.Damage[][]
---@return wrpc.IndexParam
function SlgBattleManager.FindDamageTarget(skillId,dmgDatasArray)
   
   for _, dmgDatas in pairs(dmgDatasArray) do
        if dmgDatas then
            for _, value in pairs(dmgDatas) do
                if  not skillId or value.RunnerId == skillId then
                    return value.TargetIndexParam
                end
            end
        end
    end
    return nil
end 
---@param indexParam wrpc.IndexParam
---@return number,number @HeroIndex,PetIndex
function SlgBattleManager.GetUnitIndex(indexParam)
    -- wrpc.IndexParam里的索引从1开始
    if not indexParam then
        return 0, 0
    end

    if indexParam.Typo == wrpc.IndexParamType.IndexParamType_Hero then
        return indexParam.HeroIndex, 0
    else
        --TODO: 如果需要多于一个宠物，需要加上PetIndex
        return 0, indexParam.HeroIndex
    end
end

return SlgBattleManager
