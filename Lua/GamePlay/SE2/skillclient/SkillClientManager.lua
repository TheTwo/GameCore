---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wupei.
--- DateTime: 2021/6/27
---

local SkillClientGen = require("SkillClientGen")
local SkillClientEnum = require("SkillClientEnum")
local rapidJson = require("rapidjson")
local ConfigRefer = require("ConfigRefer")

---@class SkillClientManager
local SkillClientManager = class("SkillClientManager")
local _instance = nil

SkillClientManager._skillsMap = nil

---@param ... any
---@return SkillClientManager
function SkillClientManager.CreateInstance(...)
    if _instance then
        g_Logger.Error("SkillClientManager has instance")
        return
    end
    _instance = SkillClientManager.new(...)
    return _instance
end

---@return SkillClientManager
function SkillClientManager.GetInstance()
    return _instance
end

---@return void
function SkillClientManager.DestroyInstance()
    if _instance ~= nil then
        _instance:OnDestroy()
        _instance = nil
    end
end

---@param self SkillClientManager
---@param nativePath any
---@return void
function SkillClientManager:ctor(nativePath,configPath)
    ---@type SESkillClientNative
    self.native = require(nativePath).new()
    ---@type table<SkillClientRunner, boolean>
    self._runners = {}
    SkillClientManager.LoadConfig(configPath)

	self._targetCtrlMap = {}
end

---@param configPath string
---@param force boolean
function SkillClientManager.LoadConfig(configPath, force)
	if (SkillClientManager._skillsMap and not force) then return end
    local jsonPath = configPath or 'skill_client'
    local jsonObj = g_Game.AssetManager:LoadTextToJsonObj(jsonPath)
    if not jsonObj then
        g_Logger.Error("skill_client.json parse error.")
        return
    end
    local skills = jsonObj["Skills"]
    local skillsMap = {}
    if skills then
        for i = 1, #skills do
            local skill = skills[i]
            skillsMap[skill["Id"]] = skill
        end
    end
    SkillClientManager._skillsMap = skillsMap
end

function SkillClientManager.GetSkillsMap()
	SkillClientManager.LoadConfig()
	return SkillClientManager._skillsMap
end

---@param self SkillClientManager
---@return void
function SkillClientManager:OnDestroy()
    for runner, _ in pairs(self._runners) do
        runner:Cancel()
        self._runners[runner] = nil
    end
    require("SkillClientUtils").ClearCache()
end

local function ExecCallBack(callback, ...)
    if not callback then return end
    callback(...)
end

---@param self SkillClientManager
---@param skillParam SkillClientParam
---@param runnerEnd fun(skillParam:SkillClientParam)|nil
---@param needCancelHandler boolean
---@return void|fun()
function SkillClientManager:Play(skillParam, runnerEnd, needCancelHandler)
    skillParam:SetSkillClientManager(self)
    local skillId = skillParam:GetSkillId()
    local skill = SkillClientManager._skillsMap[skillId]
    if not skill then
        g_Logger.Warn("skillId not found in skill map. skillId: %s", skillId)
        ExecCallBack(runnerEnd, skillParam)
        return
    end

    local stageType = skillParam:GetStage()
    local stage = skill["Stages"][stageType]
    if not stage then
        g_Logger.Warn("stage not found. skillId: %s, stage: %s", skillId, skillParam:GetStage())
        ExecCallBack(runnerEnd, skillParam)
        return
    end

    self:CancelWithParam(skillParam, stage)
    stage = self:ModifyStageWithModifyConfigId(stage, stageType, skillParam)

    local runner = require("SkillClientRunner").new(skillParam, stage, self)
    runner:Start(function ()
        if SkillClientEnum.Stage.chant == stageType then
            skillParam:SetAttackerPlayingSkill(false)
        end
        self._runners[runner] = nil
        ExecCallBack(runnerEnd, skillParam)
    end)

    if SkillClientEnum.Stage.chant == stageType then
        skillParam:SetAttackerPlayingSkill(true)
    end

    self._runners[runner] = true
    if needCancelHandler and type(needCancelHandler) == 'boolean' then
        return function()
            local inRunning = self._runners[runner]
            if inRunning then
                runner:Cancel()
                self._runners[runner] = nil
            end
        end
    end
end

---@param self SkillClientManager
---@param msg wrpc.PushBattleSkillStopMessageRequest
---@return void
function SkillClientManager:Cancel(msg)
    for runner, _ in pairs(self._runners) do
        if runner:IsMatch(msg) then
            runner:Cancel(msg)
            self._runners[runner] = nil
        end
    end
end

---@param target SEUnit
function SkillClientManager:CancelByTarget(target)
    ---@type wrpc.PushBattleSkillStopMessageRequest
    local dummyMsg = wrpc.PushBattleSkillStopMessageRequest.New()
    dummyMsg.Msg.ForceStopType = wds.enum.ForceStop.ForceStopTypeSkillInterrupt
    for runner, _ in pairs(self._runners) do
        if runner:IsMatchUnitTarget(target) then
            runner:Cancel(dummyMsg)
            self._runners[runner] = nil
        end
    end
end

---@param attacker SEUnit
function SkillClientManager:CancelByAttackerToSelf(attacker)
    ---@type wrpc.PushBattleSkillStopMessageRequest
    local dummyMsg = wrpc.PushBattleSkillStopMessageRequest.New()
    dummyMsg.Msg.ForceStopType = wds.enum.ForceStop.ForceStopTypeSkillInterrupt
    for runner, _ in pairs(self._runners) do
        if runner:IsMatchUnitAttacker(attacker) then
            runner:Cancel(dummyMsg)
            self._runners[runner] = nil
        end
    end
end

---@param skillTarget SkillClientTarget
local cancelFilter = function(data, skillTarget)
    if skillTarget:GetType() == SkillClientEnum.SkillTargetType.Attacker then
        if data.type == SkillClientGen.Type.AnimState or data.type == SkillClientGen.Type.AdjustDirection then
            return true
        end
    end
    return false
end

---@param self SkillClientManager
---@param skillParam SkillClientParam
---@param stageData any
---@return void
function SkillClientManager:CancelWithParam(skillParam, stageData)
    local attackerData = stageData["Attacker"]
    if attackerData and #attackerData > 0 then
        local attacker = skillParam:GetAttacker()
        for runner, _ in pairs(self._runners) do
            local runnerAttacker = runner:GetSkillParam():GetAttacker()
			
			-- 尝试使用查表优化性能
			if (runnerAttacker and not self._targetCtrlMap[runnerAttacker]) then
				self._targetCtrlMap[runnerAttacker] = runnerAttacker:GetCtrl()
			end
			if (attacker and not self._targetCtrlMap[attacker]) then
				self._targetCtrlMap[attacker] = runnerAttacker:GetCtrl()
			end

			--if runnerAttacker and runnerAttacker:EqualCtrl(attacker) then
			if (self._targetCtrlMap[runnerAttacker] == self._targetCtrlMap[attacker]) then
                runner:CancelWithFilter(cancelFilter)
            end
        end
    end
end

function SkillClientManager:Clone(object)
    local lookup_table = {}
    local function _copy(obj)
        if type(obj) ~= "table" then
            return obj
        elseif lookup_table[obj] then
            return lookup_table[obj]
        end
        local new_table = {}
        lookup_table[obj] = new_table
        for key, value in pairs(obj) do
            new_table[_copy(key)] = _copy(value)
        end
        return setmetatable(new_table, getmetatable(obj))
    end
    return _copy(object)
end

---@param self SkillClientManager
---@param stage any
---@param stageType any
---@param skillParam any
---@return void
function SkillClientManager:ModifyStageWithModifyConfigId(stage, stageType, skillParam)
    local modifyConfigId = skillParam:GetModifyConfigId()
    if modifyConfigId <= 0 then
        return stage
    end
    local tModify = ConfigRefer.SkillBehaviourModify:Find(modifyConfigId)
    if not tModify then
        return stage
    end
    local modifySkill = SkillClientManager._skillsMap[tModify.BehaviourId]
    if not modifySkill then
        return stage
    end
    local modifyStage = modifySkill["Stages"][stageType]
    if modifyStage then
        return stage
    end
    local SkillBehaviourModifyType = require("SkillBehaviourModifyType")
    if tModify.IsKeyevent then
        local behaviorKeyEvent = self:GetBehaviorWithType(stage, SkillClientGen.Type.KeyEvent)
        if not behaviorKeyEvent then
            g_Logger.Error("behaviorKeyEvent not found in stage, stage: %s", FormatTable(stage))
            return stage
        end
        stage = self:Clone(stage)
        self:AddBehaviorUseKeyEvent(stage, modifyStage, behaviorKeyEvent)
    else
        if tModify.ModifyType == SkillBehaviourModifyType.StrongReplace then
            local trackNames = self:CollectTrackNames(modifyStage)
            if not trackNames then
                g_Logger.Error("modifyStage trackName = nil, modifyStage: %s", FormatTable(modifyStage))
                return stage
            end
            stage = self:Clone(stage)
            self:RemoveTrackNames(stage, trackNames)
            self:AddBehavior(stage, modifyStage)
        elseif tModify.ModifyType == SkillBehaviourModifyType.WeakReplace then
            local trackNames = self:CollectTrackNames(modifyStage)
            if not trackNames then
                g_Logger.Error("modifyStage trackName = nil, modifyStage: %s", FormatTable(modifyStage))
                return stage
            end
            self:FilterTrackName(stage, trackNames)
            if not trackNames then
                return stage
            end
            stage = self:Clone(stage)
            self:AddBehavior(stage, modifyStage, trackNames)
        elseif tModify.ModifyType == SkillBehaviourModifyType.Add then
            self:AddBehavior(stage, modifyStage)
        else
            return stage
        end
    end
    return stage
end

---@param self SkillClientManager
---@param stage any
---@return void
function SkillClientManager:CollectTrackNames(stage)
    local trackNames
    for type, behaviors in pairs(stage) do
        local typeTrackNames
        for i, behavior in pairs(behaviors) do
            if typeTrackNames == nil then
                typeTrackNames = {}
                if trackNames == nil then
                    trackNames = {}
                end
                trackNames[type] = typeTrackNames
            end
            typeTrackNames[behavior["trackName"]] = true
        end
    end
    return trackNames
end

---@param self SkillClientManager
---@param stage any
---@param trackNames any
---@return void
function SkillClientManager:RemoveTrackNames(stage, trackNames)
    if not trackNames then
        return stage
    end
    for type, behaviors in pairs(stage) do
        local typeTrackNames = trackNames[type]
        if typeTrackNames then
            for i, behavior in pairs(behaviors) do
                if typeTrackNames[behavior["TrackName"]] then
                    behaviors[i] = nil
                end
            end
        end
    end
end

---@param self SkillClientManager
---@param stage any
---@param trackNames any
---@return void
function SkillClientManager:FilterTrackName(stage, trackNames)
    if not trackNames then
        return trackNames
    end
    for type, behaviors in pairs(stage) do
        local typeTrackNames = trackNames[type]
        if typeTrackNames then
            for i, behavior in pairs(behaviors) do
                local trackName = behavior["TrackName"]
                if typeTrackNames[trackName] then
                    typeTrackNames[trackName] = nil
                end
            end
        end
        if next(typeTrackNames) == nil then
            trackNames[type] = nil
        end
    end
    if next(trackNames) == nil then
        return nil
    end
    return trackNames
end

---@param self SkillClientManager
---@param stage any
---@param stageAdd any
---@param trackNames any
---@return void
function SkillClientManager:AddBehavior(stage, stageAdd, trackNames)
    for type, behaviors in pairs(stage) do
        local stageAddBehaviors = stageAdd[type]
        local trackNameSet
        if trackNames then
            trackNameSet = trackNames[type]
        end
        if stageAddBehaviors then
            for i, behavior in pairs(stageAddBehaviors) do
                if trackNameSet then
                    local trackName = behavior["TrackName"]
                    if trackNameSet[trackName] then
                        table.insert(behaviors, behavior)
                    end
                else
                    table.insert(behaviors, behavior)
                end
            end
        end
    end
end

---@param self SkillClientManager
---@param stage any
---@param behaviorType any
---@return void
function SkillClientManager:GetBehaviorWithType(stage, behaviorType)
    for type, behaviors in pairs(stage) do
        for i, behavior in pairs(behaviors) do
            if behavior["type"] == behaviorType then
                return behavior
            end
        end
    end
    return nil
end

---@param self SkillClientManager
---@param stage any
---@param stageAdd any
---@param behaviorKeyEvent any
---@return void
function SkillClientManager:AddBehaviorUseKeyEvent(stage, stageAdd, behaviorKeyEvent)
    for type, behaviors in pairs(stage) do
        local stageAddBehaviors = stageAdd[type]
        if stageAddBehaviors then
            for i, behavior in pairs(stageAddBehaviors) do
                behavior = self:Clone(behavior)
                behavior["TimeBegin"] = behavior["TimeBegin"] + behaviorKeyEvent["TimeBegin"]
                table.insert(behaviors, behavior)
            end
        end
    end
end

return SkillClientManager
