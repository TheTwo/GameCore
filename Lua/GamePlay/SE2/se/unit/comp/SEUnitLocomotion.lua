---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by BE.Tenner.
--- DateTime: 2021/7/14 14:15
---
--- 单位运动组件

local SEUnitComponent = require("SEUnitComponent")
local SEUnitComponentType = require("SEUnitComponentType")
local SEUnitLocomotionMode = require("SEUnitLocomotionMode")
local ConfigRefer = require("ConfigRefer")
local SELogger = require("SELogger")
local MathUtils = require("MathUtils")
local SESceneRoot = require("SESceneRoot")
local SEPreExportDefine = require("SEPreExportDefine")

---@class SEUnitLocomotion:SEUnitComponent
local SEUnitLocomotion = class("SEUnitLocomotion", SEUnitComponent)

local GROUND_RAYCAST_NAVMESH_RADIUS = 0.5
local GROUND_RAYCAST_FROM_OFFSET = CS.UnityEngine.Vector3(0, 1, 0)
local GROUND_RAYCAST_TO_OFFSET = CS.UnityEngine.Vector3(0, -1, 0)
local GROUND_RAYCAST_DIRECTION = (GROUND_RAYCAST_TO_OFFSET - GROUND_RAYCAST_FROM_OFFSET).normalized
local GROUND_RAYCAST_MAX_DISTANCE =
    CS.UnityEngine.Vector3.Distance(GROUND_RAYCAST_FROM_OFFSET, GROUND_RAYCAST_TO_OFFSET)
local GROUND_RAYCAST_LAYERMASK = CS.UnityEngine.LayerMask.GetMask("SEFloor")

local DEST_DIST_THRESHOLD = (ConfigRefer.ConstSe.SeDestDistThreshold and ConfigRefer.ConstSe:SeDestDistThreshold()) or 0.2

---@param self SEUnitLocomotion
---@param unit SEUnit
---@return void
function SEUnitLocomotion:ctor(unit)
    SEUnitLocomotion.super.ctor(self, SEUnitComponentType.Locomotion, unit)
    ---@type UnityEngine.Vector3
    self._currentDir = CS.UnityEngine.Vector3.forward
    self._moving = false
    self._moveSpeed = 0
    ---@type UnityEngine.AI.NavMeshAgent
    self._agent = nil
    ---@type UnityEngine.AI.NavMeshPath
    self._path = nil
    ---@type table<UnityEngine.Vector3>
    self._pendingPath = {}
    self._pendingPathIndex = 1
    self._mode = SEUnitLocomotionMode.NavMesh
    self._forceDirectMode = false
    ---@type UnityEngine.Vector3
    self._destination = nil
    self._groundDetection = true
    self.m_manualInit = true
	self._ignoreMoveRotation = false
	self._shouldMoving = false
end

---@param self SEUnitLocomotion
---@return void
function SEUnitLocomotion:Init()
    self:InitAgent()
end

---@param self SEUnitLocomotion
---@return void
function SEUnitLocomotion:InitAgent()
    --g.Logger.Log("Init locomotion for unit [%s]", self:GetUnit()._id)
    -- local config = self:GetUnit():GetData():GetConfig()
    -- local resConf = ConfigRefer.ArtResource:Find(config:Model())
    -- self._agent = self:GetRootObject():GetComponent(typeof(CS.UnityEngine.AI.NavMeshAgent))
    -- if (not self._agent) then
    --     self._agent = self:GetRootObject():AddComponent(typeof(CS.UnityEngine.AI.NavMeshAgent))
    -- end
    -- self._agent.agentTypeID = resConf:NmaType()
    -- self._agent.autoTraverseOffMeshLink = true
    -- self._agent.autoRepath = true
    -- self._agent.height = resConf:NmaHeight()
    -- self._agent.radius = resConf:NmaRadius()
    -- self._agent.angularSpeed = config:NmaRotatespeed()
    -- self._agent.acceleration = config:NmaAcc()
    -- self._agent.stoppingDistance = config:NmaStopdist()
    -- self._agent.autoBraking = true
    -- self._agent.obstacleAvoidanceType = CS.UnityEngine.AI.ObstacleAvoidanceType.NoObstacleAvoidance
    -- self._path = CS.UnityEngine.AI.NavMeshPath()

    --if (not self:GetUnit():IsPlayer()) then
    self._forceDirectMode = true
    --self._agent.enabled = false
    --end
end

---@param self SEUnitLocomotion
---@param path table<UnityEngine.Vector3>
---@param resetIndex boolean
---@param showWaypoint boolean
---@return void
function SEUnitLocomotion:SetPendingPath(path, resetIndex, showWaypoint)
    self._pendingPath = path
    if (self._pendingPath and #self._pendingPath > 0) then
        if (resetIndex) then
            self._pendingPathIndex = #self._pendingPath
        end
        self._destination = self._pendingPath[self._pendingPathIndex]
		if (not self:IsDestinationReached()) then
			-- 显示路点
			if (self:GetUnit():IsHero()) then
				---@type SEHero
				local hero = self:GetUnit()
                local p = self._pendingPath[1]
                p.y = p.y + SESceneRoot.GetSceneWayPointYOffset()
                if showWaypoint then
				    hero:ShowWaypoint(p)
                end
			end
			if (self._unit._init) then
				self:GetUnit():GetStateMachine():OnMove()
			else
				self._shouldMoving = true
			end
			self._moving = true
		end
    else
        self:Stop()
    end
end

function SEUnitLocomotion:SetPathRenderer()
    if (self:GetUnit():IsCaptain()) then
        if (#self._pendingPath > 0 and self._pendingPathIndex > 0) then
            local pr = self:GetEnvironment():GetPathRenderer()
            if (pr) then
                pr.enabled = true
                pr.positionCount = self._pendingPathIndex + 1
                pr:SetPosition(0, self:GetActor():GetPosition())
                for i = 1, self._pendingPathIndex do
                    pr:SetPosition(i, self._pendingPath[self._pendingPathIndex - i + 1])
                end
            end
        end
    end
end

-- function SEUnitLocomotion:ClearPathRenderer()
-- 	local pr = self:GetEnvironment():GetPathRenderer()
-- 	if (pr) then
-- 		pr.enabled = false
-- 	end
-- end

---@param self SEUnitLocomotion
---@return void
function SEUnitLocomotion:RemoveAgent()
    --g.Logger.Log("Remove locomotion for unit [%s]", self:GetUnit()._id)
    if (self._agent) then
        CS.UnityEngine.GameObject.Destroy(self._agent)
        self._agent = nil
    end
end

---@param self SEUnitLocomotion
---@return number
function SEUnitLocomotion:GetMoveSpeed()
    return self._moveSpeed
end

---@param self SEUnitLocomotion
---@param speed number
---@return void
function SEUnitLocomotion:SetMoveSpeed(speed)
    self._moveSpeed = speed
    self:UpdateSpeed()
end

---@param self SEUnitLocomotion
---@return void
function SEUnitLocomotion:UpdateSpeed()
    if (self._agent) then
        self._agent.speed = self._moveSpeed * SESceneRoot.GetClientScale()
    end
end

---@param self SEUnitLocomotion
---@param pos UnityEngine.Vector3
---@param nonstop boolean
---@return void
function SEUnitLocomotion:TeleportTo(pos, nonstop)
    if (not nonstop) then
        self:Stop()
    end

    -- 直接模式下直接到达
    --if (self:IsDirectMode()) then
        self:GetActor():SetPosition(pos)
        self:GetActor():SetServerPosition(pos)
        --g.Logger.Log("%s teleport to %s", self:GetUnit()._id, pos)
        return
    --end

    -- -- NavMesh传送
    -- if (self._agent) then
    --     self._agent:Warp(pos)
    -- --g.Logger.Log("%s teleport to %s", self:GetUnit()._id, pos)
    -- end
end

---@param self SEUnitLocomotion
---@return boolean
function SEUnitLocomotion:IsMoving()
    return self._moving
end

---@param self SEUnitLocomotion
---@param pos UnityEngine.Vector3
---@return boolean
function SEUnitLocomotion:CanMoveTo(pos)
    -- 直接模式下哪都可达
    --if (self:IsDirectMode()) then
        return true
    --end

    -- -- 根据NavMesh判断
    -- if (not self._agent) then
    --     return false
    -- end
    -- self._agent:CalculatePath(pos, self._path)
    -- return self._path.status == CS.UnityEngine.AI.NavMeshPathStatus.PathComplete
end

---@param self SEUnitLocomotion
---@param pos UnityEngine.Vector3
---@param radius number
---@return UnityEngine.Vector3
function SEUnitLocomotion:FindNearestReachablePos(pos, radius)
    -- 直接模式下哪都可达
    --if (self:IsDirectMode()) then
        return pos
    --end

    -- -- 通过NavMesh获取
    -- local result, hit = CS.UnityEngine.AI.NavMesh.SamplePosition(pos, radius, CS.UnityEngine.AI.NavMesh.AllAreas)
    -- if result then
    --     return hit.position
    -- else
    --     return nil
    -- end
end

---@param self SEUnitLocomotion
---@param pos UnityEngine.Vector3
---@param targetPos UnityEngine.Vector3
---@param overrideDistance number
---@return boolean
function SEUnitLocomotion:NeedMove(pos, targetPos, overrideDistance)
    return self:GetEnvironment():IsNearEnough(pos, targetPos, overrideDistance) == false
end

---@param self SEUnitLocomotion
---@param pos UnityEngine.Vector3
---@return void
function SEUnitLocomotion:MoveTo(pos)
    if (self:IsNavMeshMode() and not self._agent) then
        return
    end

    -- 定身检测
    if (self:GetUnit():IsDominated() or self:GetUnit():IsControl()) then
        --g.Logger.Log("Uint %s is dominated or controlled, can't move", self:GetUnit()._id)
        return
    end

    if (self:CanMoveTo(pos)) then
        --g.Logger.Log("Unit %s, agent set dest to %s", self:GetUnit()._id, pos)
        self._destination = pos
        if (self:IsNavMeshMode() and self._agent) then
            self._agent:SetDestination(pos)
        end
    elseif (self._agent) then
        --g.Logger.Log("Unit %s, agent can't move to %s, braking", self:GetUnit()._id, pos)
        self._agent.velocity = (pos - self:GetActor():GetPosition()).normalized * self._moveSpeed * SESceneRoot.GetClientScale()
    end
    if (self:IsNavMeshMode() and self._agent) then
        self._agent.isStopped = false
        self._agent.speed = self._moveSpeed * SESceneRoot.GetClientScale()
    end
    self._moving = true
end

---@param self SEUnitLocomotion
---@return void
function SEUnitLocomotion:Stop()
	self._shouldMoving = false
    if (not self._moving) then
        return
    end
    if (self:GetUnit():IsHero()) then
		---@type SEHero
		local hero = self:GetUnit()
        hero:HideWaypoint()
    end
    self._destination = self:GetActor():GetPosition()
    if (self:IsNavMeshMode() and self._agent) then
        self._agent:SetDestination(self:GetActor():GetPosition())
        self._agent.velocity = CS.UnityEngine.Vector3.zero
        self._agent.isStopped = true
    end
    self._pendingPath = {}
    self._path = nil
    self:GetUnit():GetStateMachine():OnStop()
    self._moving = false
end

---@param self SEUnitLocomotion
---@param value any
---@return void
function SEUnitLocomotion:SetAngularSpeedEnable(value)
    if (not self._agent) then
        return
    end
    if value then
        local config = self:GetUnit():GetData():GetConfig()
        self._agent.angularSpeed = config:NmaRotatespeed()
    else
        self._agent.angularSpeed = 0
    end
end

---@param self SEUnitLocomotion
---@return void
function SEUnitLocomotion:GetVelocity()
    if (not self._agent) then
        return CS.UnityEngine.vector3.zero
    end
    return self._agent.velocity
end

---@param self SEUnitLocomotion
---@param delta number
---@return void
function SEUnitLocomotion:Update(delta)
    if (self._moving) then
		-- 错过移动时机处理
		if (self._shouldMoving and self._unit._init) then
			self._shouldMoving = false
			self._unit:GetStateMachine():OnMove()
		end

        -- 到达目的地或路点
        local cont = true
        if (self:IsDestinationReached(self._agent)) then
            SELogger.LogLow("unit %s reach point %s", self:GetUnit()._id, self._destination)
            --if (self:IsDirectMode()) then
                self._pendingPathIndex = self._pendingPathIndex - 1
                if (not self._pendingPath or self._pendingPathIndex < 1) then
                    SELogger.LogLow("unit %s reach dest", self:GetUnit()._id)
                    self:Stop()
                    cont = false
                else
                    SELogger.LogLow("unit %s next point %s", self:GetUnit()._id, self._destination)
                    self._destination = self._pendingPath[self._pendingPathIndex]
                end
            --end
        end
        -- 路径显示
        --self:SetPathRenderer()

        -- 直接移动模式
        if (cont --[[and self:IsDirectMode()]]) then
            -- -- 电梯判断
            -- if (self:GetUnit():IsHero() and self:GetUnit():IsInElevator()) then
            --     return
            -- end

            local pos = self:GetActor():GetServerPosition()
            local dest = self._destination
            if (dest) then
                -- 方向与距离
                local forward = (dest - pos).normalized
                local dist = MathUtils.Distance(dest, pos)

                -- 移动量
                local moveDelta = self._moveSpeed * SESceneRoot.GetClientScale() * delta

                -- 移动
                local newPos
                if (dist <= moveDelta) then
                    newPos = self._destination
                else
                    newPos = CS.UnityEngine.Vector3.Lerp(pos, dest, moveDelta / dist)
                end
                self:GetActor():SetServerPosition(newPos)

                -- 朝向
				forward.y = 0
				self:GetActor():SetMoveForward(forward)
				local isHero = self._unit:IsHero()
				local isBoss = self._unit:IsBoss()
				local isElite = self._unit:IsElite()
				if (not self._ignoreMoveRotation) then
					
					-- 转向插帧
					if (isHero or isBoss or isElite) then
						local oldEulerAngles = self:GetActor():GetTransform().forward
                        local maxAngle = math.angle2radian(SEPreExportDefine.ROTATE_ANGLE_PER_SECOND * delta)
						forward = CS.UnityEngine.Vector3.RotateTowards(oldEulerAngles, forward, maxAngle, 100)
						--SELogger.Trace("**** rotateTime for %s: %s", self._unit._id, rotateTime)
					end
			
					self:GetActor():SetForward(forward)
				--else
					--SELogger.Trace("**** ignore move rotation for %s", self._unit._id)
				end

                -- 地面检测
                local placed = false
                if (isHero or isBoss or isElite --[[and self._groundDetection]]) then
					-- 先用Raycast
					local origin = newPos + GROUND_RAYCAST_FROM_OFFSET
					local result, hit =
						CS.RaycastHelper.PhysicsRaycastOriginHitWithLayerMask(
						origin,
						GROUND_RAYCAST_DIRECTION,
						GROUND_RAYCAST_MAX_DISTANCE,
						GROUND_RAYCAST_LAYERMASK
					)
					if (result) then
						self:GetActor():SetPosition(hit.point)
						placed = true
					end

					-- 再尝试NavMesh Sample
					if (not placed) then
						local nr, nhit =
							CS.UnityEngine.AI.NavMesh.SamplePosition(
							newPos,
							GROUND_RAYCAST_NAVMESH_RADIUS,
							CS.UnityEngine.AI.NavMesh.AllAreas
						)
						if (nr) then
							self:GetActor():SetPosition(nhit.position)
							placed = true
						end
					end
                end
                if (not placed) then
                    self:GetActor():SetPosition(newPos)
                end
            end
        end

        -- 水花
        --self:GetUnit():GetRenderer():ActivateSplash()

        -- 移动音效区域
        --self:GetUnit():GetRenderer():PlayMovingSound()

	else
		self:GetActor():SetMoveForward(nil)
    end
end

---@param self SEUnitLocomotion
---@param agent UnityEngine.AI.NavMeshAgent
---@return boolean
function SEUnitLocomotion:IsDestinationReached(agent)
    --if (self:IsDirectMode()) then
        return self:GetEnvironment():IsNearEnough(self:GetActor():GetServerPosition(), self._destination, DEST_DIST_THRESHOLD)
    --end
    -- if (not agent) then
    --     return true
    -- end
    -- if (agent.pathPending == false) then
    --     if (agent.remainingDistance <= agent.stoppingDistance) then
    --         if (agent.hasPath == false or agent.velocity.sqrMagnitude == 0) then
    --             return true
    --         end
    --     end
    -- end
    -- return false
end

---@param self SEUnitLocomotion
---@return void
function SEUnitLocomotion:Release()
    --self:RemoveAgent()
end

---@param self SEUnitLocomotion
---@param pos UnityEngine.Vector3
---@return boolean, CS.UnityEngine.AI.NavMeshHit
function SEUnitLocomotion:HasObstacleBetween(pos)
    return CS.UnityEngine.AI.NavMesh.Raycast(self:GetActor():GetPosition(), pos, CS.UnityEngine.AI.NavMesh.AllAreas)
end

---@param self SEUnitLocomotion
---@param enabled boolean
---@return void
function SEUnitLocomotion:SetAgentEnabled(enabled)
    if (self:IsDirectMode()) then
        if (self._agent) then
            self._agent.enabled = false
        end
        return
    end
    if (self._agent) then
        if (not enabled) then
            self:Stop()
        end
        self._agent.enabled = enabled
    end
end

---@param self SEUnitLocomotion
---@param force boolean
---@return void
function SEUnitLocomotion:SetForceDirectMode(force)
    self._forceDirectMode = force
end

---@param self SEUnitLocomotion
---@return boolean
function SEUnitLocomotion:IsDirectMode()
    return true
    -- if (self:GetUnit():IsPlayer()) then
    --     return false
    -- end
    --return self._forceDirectMode or self._mode == SEUnitLocomotionMode.Direct
end

---@param self SEUnitLocomotion
---@return boolean
function SEUnitLocomotion:IsNavMeshMode()
    return false
    -- if (self:GetUnit():IsPlayer()) then
    --     return true
    -- end
    --return not self._forceDirectMode and self._mode == SEUnitLocomotionMode.NavMesh
end

---@param self SEUnitLocomotion
---@param mode number
---@return void
function SEUnitLocomotion:ChangeMode(mode)
    if (self._mode == mode) then
        return
    end

    if (mode == SEUnitLocomotionMode.NavMesh) then
        if (not self._agent) then
            SELogger.LogError("No NavMesh agent on this unit %s, change to NavMesh mode failed!", self:GetUnit()._id)
            return
        end
        self._agent.enabled = true
    elseif (mode == SEUnitLocomotionMode.Direct) then
        if (self._agent) then
            self._agent.enabled = false
        end
    end

    self._mode = mode
end

---@param self SEUnitLocomotion
---@param enabled boolean
---@return void
function SEUnitLocomotion:SetGroundDetectionEnabled(enabled)
    self._groundDetection = enabled
end

---@param self SEUnitLocomotion
---@param ignore boolean
function SEUnitLocomotion:SetIgnoreMoveRotation(ignore)
	self._ignoreMoveRotation = ignore
end

return SEUnitLocomotion
