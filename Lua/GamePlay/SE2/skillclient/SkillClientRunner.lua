---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wupei.
--- DateTime: 2021/6/27
---
---@class SkillClientRunner
local SkillClientRunner = class("SkillClientRunner")
local SkillClientEnum = require("SkillClientEnum")
local SkillClientGen = require("SkillClientGen")
local TableLinkedList = require("TableLinkedList")
local TimerUtility = require("TimerUtility")
local Delegate = require("Delegate")
local ConfigRefer = require('ConfigRefer')

---@param self SkillClientRunner
---@param skillParam any
---@param stage any
---@param manager any
---@return void
function SkillClientRunner:ctor(skillParam, stage, manager)
    ---@type SkillClientManager
    self._manager = manager
    ---@type SkillClientParam
    self._skillParam = skillParam
    self._state = SkillClientEnum.State.NotRunning
    self._isCancel = false
    self._stage = stage
    self._handleList = TableLinkedList.New()
    self._time = 0
    self._deltaTime = 0
    self._timeScale = 1
    self._frameHandle = nil
    self._onEnd = nil
end

---@param self SkillClientRunner
---@return SkillClientParam
function SkillClientRunner:GetSkillParam()
    return self._skillParam
end

---@param self SkillClientRunner
---@return SkillClientManager
function SkillClientRunner:GetManager()
    return self._manager
end

---@param self SkillClientRunner
---@return void
function SkillClientRunner:GetTime()
    return self._time
end

---@param self SkillClientRunner
---@return void
function SkillClientRunner:GetDeltaTime()
    return self._deltaTime
end

---@param self SkillClientRunner
---@return void
function SkillClientRunner:GetUnscaledDeltaTime()
    return self._deltaTime / self._timeScale
end

---@param self SkillClientRunner
---@return void
function SkillClientRunner:GetTimeScale()
    return self._timeScale
end

---@param self SkillClientRunner
---@param timeScale any
---@return void
function SkillClientRunner:SetTimeScale(timeScale)
    if timeScale >= 0 then
        if timeScale ~= self._timeScale then
            self._timeScale = timeScale
        end
    else
        g_Logger.Error("timeScale param error. timeScale: %s", timeScale)
    end
end

---@param self SkillClientRunner
---@param onEnd any
---@return void
function SkillClientRunner:Start(onEnd)
    if self._state ~= SkillClientEnum.State.NotRunning then
        g_Logger.Error("SkillClientRunner._state error. _state: %s", self._state)
        return
    end

    self._state = SkillClientEnum.State.Running
    self._onEnd = onEnd
    -- 技能释放者
    local attackerDatas = self._stage["Attacker"]
    self:ExecuteTarget(attackerDatas, self._skillParam:GetAttacker())

    -- 技能受体
    local targetDatas = self._stage["Target"]
    local target = self._skillParam:GetTarget()
    if not self._skillParam:IsIgnorePlay(target) then
        self:ExecuteTarget(targetDatas, target)
    end

    for _, v in ipairs(self._skillParam:GetOtherTargets()) do
        if not self._skillParam:IsIgnorePlay(v) then
            self:ExecuteTarget(targetDatas, v)
        end
    end

    self:Update(0)
    self._frameHandle = TimerUtility.StartFrameTimer(function()
        return self:Update()
    end, 0, -1, true)
end

---@class SkillClientRunnerHandle : TableLinedListNode
---@field data skillclient.data.Effect
---@field skillTarget SkillClientTarget
---@field behavior Behavior

---@param self SkillClientRunner
---@param dataList any
---@param skillTarget any
---@return void
function SkillClientRunner:ExecuteTarget(dataList, skillTarget)
    if not skillTarget or not dataList then
        return
    end
    for _, data in ipairs(dataList) do
        local handle = { data = data, skillTarget = skillTarget }
        self._handleList:Add(handle)
    end
end

---@param self SkillClientRunner
---@param deltaTime any
---@return void
function SkillClientRunner:Update(deltaTime)
    local timeScale = self._timeScale
    deltaTime = (deltaTime or g_Game.Time.deltaTime) * timeScale
    self._deltaTime = deltaTime
    self._time = self._time + deltaTime

    local list = self._handleList
    local time = self._time

    ---@type SkillClientRunnerHandle
    local handle = list.first
    while handle ~= nil do
        local next = handle.next

        local behavior = handle.behavior
        local data = handle.data
        if behavior then
            if time < data.TimeBegin + data.Time then
                --try_catch(function()
                    behavior:DoOnUpdate()
                --end, function(result)
                --    g_Logger.Error(result)
                --end)
            else
                --try_catch(function()
                    behavior:DoOnEnd(false)
                --end, function(result)
                --    g_Logger.Error(result)
                --end)
                list:Remove(handle)
            end
        else
            if time >= data.TimeBegin then
                behavior = self:CreateBehavior(data.Type, data, handle.skillTarget)
                if behavior then
                    handle.behavior = behavior
                    --try_catch(function()
                        behavior:DoOnStart()
                    --end, function(result)
                    --    g_Logger.Error(result)
                    --end)
                    
                    --try_catch(function()
                        behavior:DoOnUpdate()
                    --end, function(result)
                    --    g_Logger.Error(result)
                    --end)
                else
                    list:Remove(handle)
                end
            end
        end

        handle = next
    end

    if timeScale ~= self._timeScale then
        self:OnTimeScaleChanged()
    end

    if list.count <= 0 then
        self:DoEnd()
    end
end

---@param self SkillClientRunner
---@param msg wrpc.PushBattleSkillStopMessageRequest or nil
---@return void
function SkillClientRunner:Cancel(msg)
    if self._state ~= SkillClientEnum.State.Running then
        g_Logger.Error("Cancel() _state error. _state: %s", self._state)
        return
    end

    self._isCancel = true
    local list = self._handleList
    ---@type SkillClientRunnerHandle
    local handle = list.first
    while handle ~= nil do
        local next = handle.next
        local behavior = handle.behavior
        if behavior then
            --try_catch(function()
                local isCancel = false
                if msg ~= nil then
                    isCancel = msg.Msg.ForceStopType == wds.enum.ForceStop.ForceStopTypeSkillInterrupt
                end
                behavior:DoOnEnd(isCancel)
            --end, function(result)
            --    g_Logger.Error(result)
            --end)
        end
        list:Remove(handle)

        handle = next
    end
    self:DoEnd()
end

---@param self SkillClientRunner
---@param filter any
---@return void
function SkillClientRunner:CancelWithFilter(filter)
    if self._state ~= SkillClientEnum.State.Running then
        return
    end

    self._isCancel = true
    local list = self._handleList
    ---@type SkillClientRunnerHandle
    local handle = list.first
    while handle ~= nil do
        local next = handle.next

        if filter(handle.data, handle.skillTarget) then
            local behavior = handle.behavior
            if behavior then
                --try_catch(function()
                    behavior:DoOnEnd(false)
                --end, function(result)
                --    g_Logger.ErrorChannel(nil, result)
                --end)
            end
            list:Remove(handle)
        end

        handle = next
    end
    self._isCancel = false
end

---@param self SkillClientRunner
---@return void
function SkillClientRunner:DoEnd()
    self._state = SkillClientEnum.State.End
    if self._frameHandle then
        TimerUtility.StopAndRecycle(self._frameHandle)
        self._frameHandle = nil
    end
    --try_catch(function()
        self._onEnd()
    --end, function(result)
    --    g_Logger.ErrorChannel(nil, result)
    --end)
end

---@param self SkillClientRunner
---@return void
function SkillClientRunner:OnTimeScaleChanged()
    local list = self._handleList
    ---@type SkillClientRunnerHandle
    local handle = list.first
    while handle ~= nil do
        local next = handle.next

        local behavior = handle.behavior
        if behavior then
            --try_catch(function()
                behavior.DoOnTimeScaleChanged(behavior)
            --end, function(result)
            --    g_Logger.ErrorChannel(nil, result)
            --end)
        end

        handle = next
    end
end

---@param self SkillClientRunner
---@param typeNum any
---@param data any
---@param skillTarget any
---@return void
function SkillClientRunner:CreateBehavior(typeNum, data, skillTarget)
    local typeName = SkillClientGen.Type2name[typeNum]
    local type = require(typeName)
    if not type then
        g_Logger.Error("behavior type implement not found. typeNum = %s", typeNum)
        return nil
    end
    return type.new(data, skillTarget, self)
end

---@param self SkillClientRunner
---@param msg wrpc.PushBattleSkillStopMessageRequest
---@return void
function SkillClientRunner:IsMatch(msg)
    local serverData = self._skillParam:GetServerData()
    if serverData then
        return serverData.RunnerId == msg.Msg.RunnerId
    end

    g_Logger.Log('SkillClientRunner:IsMatch没有获取到serverData')
    return false
end

---@param seUnit SEUnit
function SkillClientRunner:IsMatchUnitAttacker(seUnit)
    local attacker = self._skillParam:GetAttacker()
    local target = self._skillParam:GetTarget()
    return attacker and target and attacker:GetID() == target:GetID() and seUnit and seUnit:GetID() == target:GetID()
end

---@param seUnit SEUnit
function SkillClientRunner:IsMatchUnitTarget(seUnit)
    local target = self._skillParam:GetTarget()
    return target and seUnit and target:GetID() == seUnit:GetID()
end

return SkillClientRunner
