---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by shoufeng.zhang.
--- DateTime: 2022/5/27 10:38
---
--local KingdomMapUtils = require('KingdomMapUtils')
---@class SlgUtils
local SlgUtils = class('SlgUtils')
local Color = CS.UnityEngine.Color
local MatPool = CS.Kingdom.KingdomUnitMaterialPool
local DBEntityType = require('DBEntityType')
local ModuleRefer = require('ModuleRefer')
local ConfigRefer = require('ConfigRefer')
local TroopConst = require('TroopConst')
local ColorConsts = require('ColorConsts')
local UIHelper = require('UIHelper')
local SlgSkillAIType = require('SlgSkillAIType')
local ObjectType = require("ObjectType")
local MailUtils = require("MailUtils")
local Vector3Calculation = require("Vector3Calculation")

local Vector3 = CS.UnityEngine.Vector3

---@class SlgUtils.TroopType
SlgUtils.TroopType = {
    Invalid = 0,
    MySelf = 1,
    Friend = 2,
    Other = 3,
    Monster = 4,
    Enemy = 5,
    Boss = 6,
    Behemoth = 7,
}

SlgUtils.TargetType = 
{
    None = 0,
    Position = 1,
    Entity = 2,
}

SlgUtils.AIType =
{
    None = -1,
    Pet = 0,
    Hero = 1,
    Simple = 2,
    BossStatic = 4,
    Boss = 5,
}

SlgUtils.ServerType =
{
    Mob = 0,
    Troop = 1,
    TroopChariot = 2,
    MobileFortress = 3,
    Puppet = 4,
    Building = 5,
}

---@class SlgUtils.EntityColor
SlgUtils.EntityColor = {
    [SlgUtils.TroopType.Invalid] = Color(0, 0, 0, 0.5),
    [SlgUtils.TroopType.MySelf] = UIHelper.TryParseHtmlString(ColorConsts.army_green),
    [SlgUtils.TroopType.Friend] = UIHelper.TryParseHtmlString(ColorConsts.army_blue),
    [SlgUtils.TroopType.Other] = UIHelper.TryParseHtmlString(ColorConsts.army_white),
    [SlgUtils.TroopType.Monster] = UIHelper.TryParseHtmlString(ColorConsts.army_red),
    [SlgUtils.TroopType.Enemy] = UIHelper.TryParseHtmlString(ColorConsts.army_red),
}


function SlgUtils.SetGoColor(go,color)
    MatPool.SetColor(go,color)
end

function SlgUtils.ResetGoColor(go)
    MatPool.ResetColor(go)
end

---@param type number @enum from SlgUtils.TroopType
function SlgUtils.GetEntityColor(type)
    if not type then return SlgUtils.EntityColor[SlgUtils.TroopType.Invalid] end
    local color = SlgUtils.EntityColor[type]
    if not color then
        color = SlgUtils.EntityColor[SlgUtils.TroopType.Invalid]
    end
    return color
end

---@param troop wds.Troop|wds.MapMob|wds.ma
function SlgUtils.FigureOutTroopType(troop)
    if troop.TypeHash == DBEntityType.Troop or troop.TypeHash == DBEntityType.TroopChariot then
        local isRelatedToMe = ModuleRefer.SlgModule:IsTroopRelatedToMe(troop)
        if isRelatedToMe then
            return SlgUtils.TroopType.MySelf
        end

        local isFriendly = ModuleRefer.PlayerModule:IsFriendly(troop.Owner)
        if isFriendly then
            return SlgUtils.TroopType.Friend
        else
            return SlgUtils.TroopType.Enemy
        end
    elseif troop.TypeHash == DBEntityType.MapMob then
        if SlgUtils.IsBoss(troop) then
            return SlgUtils.TroopType.Boss
        else
            return SlgUtils.TroopType.Monster
        end
    elseif troop.TypeHash == DBEntityType.SlgPuppet then
        if troop.Owner.MasterID > 0 then
            if ModuleRefer.PlayerModule:IsMineById(troop.Owner.MasterID) then
                return SlgUtils.TroopType.MySelf
            elseif ModuleRefer.PlayerModule:IsFriendlyById(troop.Owner.AllianceID,troop.Owner.MasterID) then
                return SlgUtils.TroopType.Friend
            else
                local masterEntity = g_Game.DatabaseManager:GetEntity(troop.Owner.MasterID,DBEntityType.MapMob)
                if masterEntity then
                    return SlgUtils.TroopType.Monster
                end
            end
        end
    end
    return SlgUtils.TroopType.Enemy
end

function SlgUtils.IsBoss(troop)
    if troop and troop.TypeHash == DBEntityType.MapMob then
        local mobCfgId = troop.MobInfo.MobID
        local mobCfg = ConfigRefer.KmonsterData:Find(mobCfgId)
        if mobCfg and mobCfg:SkillAI() == SlgSkillAIType.BossAI then
            return true
        end
    end
    return false
end

---@param mob wds.MapMob
---@return number @enum from MonsterBattleType
function SlgUtils.GetMonsterBattleType(mob)
    if mob.TypeHash == DBEntityType.MapMob then
        local mobConfig = ConfigRefer.KmonsterData:Find(mob.MobInfo.MobID)
        return mobConfig:BattleType()
    else
        return require('MonsterBattleType').Normal
    end
end

---@param troop wds.Troop | wds.MapMob | wds.MapPuppet
function SlgUtils.IsTroopSelectable(troop)
    if not troop or not troop.MapStates then return false end
    if SlgUtils.IsTroopRetreating(troop.MapStates) then --逃跑状态不能选中
        return false
    end

    return true
end

---@param troop wds.Troop | wds.MapMob | wds.MapPuppet | wds.TroopChariot
function SlgUtils.GetCaptainTroop(troop)
    if troop.TypeHash == DBEntityType.TroopChariot then
        local captainId = 0 --troop.Owner.PlayerID
        local captain = nil

        for _, member in pairs(troop.Army.PlayerTroopIDs) do
            local element = g_Game.DatabaseManager:GetEntity(member.Id, DBEntityType.Troop)
            if element then
                captain = element
                if member.PlayerId == captainId then
                    break
                end
            end
        end

        return captain
    end

    return troop
end

---@param troop wds.Troop | wds.MapMob | wds.MapPuppet
function SlgUtils.IsTroopHideOnMap(troop)
    return troop.MapStates.StateWrapper2.InGarrison or troop.MapStates.HideOnMap
end

---@param troop wds.Troop | wds.MapMob | wds.MapPuppet
function SlgUtils.IsTroopInGarrison(troop)
    return troop and troop.MapStates and troop.MapStates.StateWrapper2.InGarrison
end

---@param troop wds.Troop | wds.MapMob | wds.MapPuppet
function SlgUtils.IsTroopInStrengthen(troop)
    return troop.MapStates.StateWrapper2.InStrengthen
end

---@param troop wds.Troop | wds.MapMob | wds.MapPuppet
function SlgUtils.IsTroopGathering(troop)
    return troop.MapStates.Gathering
end

---@param troop wds.Troop | wds.MapMob | wds.MapPuppet
function SlgUtils.IsTroopInRally(troop)
    return troop and troop.TrusteeshipInfo and troop.TrusteeshipInfo.TroopChariotId > 0
end

---@param data wds.MapMob
function SlgUtils.DoesMobHaveRallyInfo(data, allianceId)
    return data.TrusteeshipTargetInfo and data.TrusteeshipTargetInfo.TrusteeshipAllianceId ~= 0 and
        data.TrusteeshipTargetInfo.TrusteeshipAllianceId == allianceId
end

---@param mapStates wds.MapEntityState
function SlgUtils.IsTroopRetreating(mapStates)
    if mapStates == nil then
        return false
    end

    if mapStates.Retreating then
        return true
    end

    if mapStates.StateWrapper2 and mapStates.StateWrapper2.BackToOrigin then
        return true
    end

    return false
end

---@param troop wds.Troop
function SlgUtils.IsTroopBatting(troop)
    if troop and troop.MapStates and troop.MapStates.Battling then
        return true
    end

    return false
end

---@param troop wds.Troop | wds.TroopChariot
function SlgUtils.IsTroopMoving(troop)
    if troop and troop.MapStates and troop.MapStates.Moving then
        return true
    end

    if SlgUtils.IsTroopInRally(troop) and SlgUtils.IsTroopInGarrison(troop) then
        local chariot = g_Game.DatabaseManager:GetEntity(troop.TrusteeshipInfo.TroopChariotId, DBEntityType.TroopChariot)
        return SlgUtils.IsTroopMoving(chariot)
    end

    return false
end

function SlgUtils.GetEntityById(id)
    local entities = g_Game.DatabaseManager:GetEntitiesById(id)
    if entities == nil then
        return nil
    end
    return entities[1]
end

---@param buffCfgIdList number[] | RepeatedField
---@return number @TroopConst.SP_STATE_NONE | TroopConst.SP_STATE_FLOATING | TroopConst.SP_STATE_STUN
function SlgUtils.GetSpStateFromBuffCfgIds(buffCfgIdList)
    if not buffCfgIdList or buffCfgIdList:Count() < 1 then return TroopConst.SP_STATE_NONE end
    local hasFloating = false
    local hasStuned = false
    for key, cfgId in pairs(buffCfgIdList) do
        if cfgId == TroopConst.FLOATING_BUFF_ID then
            hasFloating = true
        elseif cfgId == TroopConst.STUN_BUFF_ID then
            hasStuned = true        
        end
    end
    
    if hasFloating then
        return TroopConst.SP_STATE_SET_FLAG + TroopConst.SP_STATE_FLOATING
    elseif hasStuned then
        return TroopConst.SP_STATE_SET_FLAG + TroopConst.SP_STATE_STUN
    else
        return TroopConst.SP_STATE_NONE
    end
end

---@param buffList table<number, wds.BuffInfo> | MapField
---@return number @TroopConst.SP_STATE_NONE | TroopConst.SP_STATE_FLOATING | TroopConst.SP_STATE_STUN
function SlgUtils.GetSpStateFromBuffDatas(buffList)
    if not buffList then return TroopConst.SP_STATE_NONE end
    local hasFloating = false
    local hasStuned = false
    for key, buff in pairs(buffList) do
        if buff.ConfigId == TroopConst.FLOATING_BUFF_ID then
            hasFloating = true
            break
        elseif buff.ConfigId == TroopConst.STUN_BUFF_ID then
            hasStuned = true        
            if hasFloating and hasStuned then break end
        end
    end

    if hasFloating then
        return TroopConst.SP_STATE_FLOATING
    elseif hasStuned then
        return TroopConst.SP_STATE_STUN
    else
        return TroopConst.SP_STATE_NONE
    end
end

function SlgUtils.IsMobCanAttackById(mobId)
    if mobId < 1 then return false end
    local mobConfig = ConfigRefer.KmonsterData:Find(mobId)
    return SlgUtils.IsMobCanAttack(mobConfig)
end

---@param mobConfig KmonsterDataConfigCell
---@return boolean,boolean @canAttack,needShowHud
function SlgUtils.IsMobCanAttack(mobConfig)    
    if not mobConfig then return false,false end
    local mobFaction = mobConfig:FactionConf()
    if mobFaction >= 13 then
        return false, mobFaction <= 13
    end
    return true,true
end

---@param troopCtrl BehemothTroopCtrl
---@return wds.BehemothCage
function SlgUtils.GetBehemothCageViaBehemothTroop(troopCtrl)
    if not troopCtrl or troopCtrl then return nil end
    local data = troopCtrl:GetData()
    if not data or not data.MobInfo or not data.MobInfo or data.MobInfo.BehemothCageId <= 0 then return nil end
    return troopCtrl:GetCageEntity()
end

---@param entity wds.MapMob
function SlgUtils.IsMobCanTriggerAutoFinish(entity)        
    if (entity.TypeHash == DBEntityType.MapMob or entity.TypeHash == DBEntityType.SlgInteractor)
        and entity.LevelEntityInfo 
        and entity.LevelEntityInfo.LevelEntityId > 0 
    then
        local levelId = entity.LevelEntityInfo.LevelEntityId
        local expEntity = (levelId ~= 0) and g_Game.DatabaseManager:GetEntity(levelId,DBEntityType.Expedition) or nil
        local expConfig = expEntity and ConfigRefer.WorldExpeditionTemplate:Find(expEntity.ExpeditionInfo.Tid) or nil
        if expConfig and expConfig:ProgressType() == require('ProgressType').Personal then
            return true
        end   
    end
    return false
end

---@param entity wds.Troop
---@param preset wds.TroopPreset
function SlgUtils.GetEcsrowIcon(entity,preset)
    if not entity and not preset then return nil end
    local type = -1

    if preset then
        if preset.Status == wds.TroopPresetStatus.TroopPresetAssembleInTrusteeship
            or ((preset.WaitingStateMask & wds.TroopPresetWaitingMask.TroopPresetWaitingMaskAssembleTrusteeship) ~= 0)
        then
            type = 1
        elseif preset.BasicInfo.AutoBattle then
            type = 2
        elseif preset.BasicInfo.AutoClearExpedition then
            type = 1
        end
    end

    if type < 0 
        and entity and entity.TypeHash == DBEntityType.Troop 
        and entity.MapStates and entity.MapStates.StateWrapper2 
    then
        if entity.MapStates.StateWrapper2.AutoBattle then
            type = 2
        elseif entity.MapStates.StateWrapper2.AutoClearExpedition then
            type = 1
        end
    end

    if type == 1 then
        return 'sp_comp_icon_agency'
    elseif type == 2 then
        return 'sp_troop_icon_status_assemble'
    end
end


---@param preset wds.TroopPreset
function SlgUtils.PresetHasInjuredUnit(preset, injuredHpPct)
    --已经实例化的部队不进入重伤判断
    if not preset 
        or preset.TroopId > 0 
        or preset.Status ~= wds.TroopPresetStatus.TroopPresetIdle
        or injuredHpPct == nil 
        or not preset.Heroes
    then 
        return false 
    end
    for _, value in pairs(preset.Heroes) do
        if value.HeroCfgID > 0 then
            local heroMaxHp,petMaxHp = ModuleRefer.TroopModule:GetTroopHeroAndPetHPMax(value.HeroCfgID, value.PetCompId)
            if value.HP <= math.floor(heroMaxHp * injuredHpPct) then
                return true
            end
            
            if value.PetCompId > 0 then
                if value.PetHP <= math.floor(petMaxHp * injuredHpPct) then
                    return true
                end
            end
        end
    end
    return false
end

---@param preset wds.TroopPreset
function SlgUtils.PresetAllHeroInjured(preset, injuredHpPct)
    --已经实例化的部队不进入重伤判断
    if not preset 
        or preset.TroopId > 0 
        or preset.Status ~= wds.TroopPresetStatus.TroopPresetIdle
        or injuredHpPct == nil 
        or not preset.Heroes
    then 
        return false 
    end

    for _, value in pairs(preset.Heroes) do
        if value.HeroCfgID > 0 then
            local heroMaxHp = ModuleRefer.TroopModule:GetTroopHeroAndPetHPMax(value.HeroCfgID, value.PetCompId)
            if value.HP > math.floor(heroMaxHp * injuredHpPct) then
                return false
            end
        end
    end
    return true
end

---@param hero wds.TroopHero
---@return number
function SlgUtils.GetHeroNormalAttackId(hero)
    if hero and hero.ActiveSkills then                    
        local skill = hero.ActiveSkills[1]
        if skill then
            return ModuleRefer.SlgModule.dataCache:GetSkillAssetId(skill.SkillId) or 0
        end                    
    end

    return 0
end

---@param pet wds.TroopPet
---@return number
function SlgUtils.GetPetNormalAttackId(pet)
    if pet and pet.ActiveSkills then
        local skill = pet.ActiveSkills[1]
        if skill then
            return ModuleRefer.SlgModule.dataCache:GetSkillAssetId(skill.SkillId) or 0
        end
    end
    
    return 0
end

function SlgUtils.GetNameIconPowerByConfigId(objectType, cfgId)
    local name = ""
    local icon = ""
    local level = 1
    local power = 0

    -- 怪物
    if (objectType == ObjectType.SlgMob) then
        name, icon, level = MailUtils.GetMonsterNameIconLevel(cfgId)
        name = "Lv." .. level .. " " .. name
        power = MailUtils.GetMonsterPower(cfgId)
    -- 建筑
    elseif objectType == ObjectType.SlgVillage or 
        objectType == ObjectType.Pass or 
        objectType == ObjectType.SlgCommonBuilding or 
        objectType == ObjectType.SlgResource or 
        objectType == ObjectType.SlgEnergyTower or 
        objectType == ObjectType.SlgTransferTower or 
        objectType == ObjectType.SlgDefenceTower or 
        objectType == ObjectType.SlgMobileFortress or 
        objectType == ObjectType.SlgCastle
    then
        name, icon, level = MailUtils.GetMapBuildingNameIconLevel(cfgId)
        name = "Lv." .. level .. " " .. name
    end

    return name, icon, power
end

---@param movePathInfo wds.MovePathInfo
---@return number
---@return CS.UnityEngine.Vector3[]
---@return CS.UnityEngine.Vector3[]
function SlgUtils.CalculateTroopMovePath(startPosition, movePathInfo)
    if not startPosition or not movePathInfo then
        return 0, nil, nil
    end
    
    local slgModule = ModuleRefer.SlgModule
    local realPath = {}
    local troopLinePoints = {}
    local c = #movePathInfo.Path
    local length = 0
    local lastPos = startPosition
    for i = c, 1, -1 do
        local v = movePathInfo.Path[i]
        local pos = slgModule:ServerCoordinate2Vector3(v)
        pos = slgModule:GetTerrainPos(pos)
        length = length + Vector3.Distance(pos,lastPos)
        lastPos = pos
        table.insert(realPath,  pos)
        table.insert(troopLinePoints,pos)
    end
    return length, realPath, troopLinePoints
end

---@param movePathInfo wds.MovePathInfo
---@return number
function SlgUtils.CalculateTroopMoveSpeed(movePathInfo)
    local speed = ModuleRefer.SlgModule:ServerSpeed2MapSpeed(movePathInfo.Speed)
    return speed
end

---@param mapBasics wds.MapEntityBasicInfo
---@param movePathInfo wds.MovePathInfo
---@return number @行军结束的时间戳（单位：秒）
function SlgUtils.CalculateTroopMoveStopTime(mapBasics, movePathInfo)
    local duration =  SlgUtils.CalculateTroopMoveDuration(mapBasics, movePathInfo)
    local syncTimestamp = mapBasics.PositionChangeTime / 1000
    return duration + syncTimestamp
end

---@param mapBasics wds.MapEntityBasicInfo
---@param movePathInfo wds.MovePathInfo
---@return number @行军剩余时间（单位：秒）
function SlgUtils.CalculateTroopMoveDuration(mapBasics, movePathInfo)
    local speed = movePathInfo.Speed
    if speed <= 0 then
        return 0
    end

    local space = 0
    local lastPos = mapBasics.Position
    local path = movePathInfo.Path
    for i = 1, #path do
        local currPos = path[i]
        local distance = Vector3Calculation.Dist2D(currPos.X, currPos.Y, lastPos.X, lastPos.Y)
        space = space + distance
        lastPos = path[i]
    end

    local duration =  space / speed
    return duration
end

---@param pos1 CS.UnityEngine.Vector3
---@param pos2 CS.UnityEngine.Vector3
---@return number
function SlgUtils.CalcSqrMagnitudeXZ(pos1,pos2)
    return (pos1.x-pos2.x)*(pos1.x-pos2.x) + (pos1.z-pos2.z)*(pos1.z-pos2.z)
end

---@param pos1 CS.UnityEngine.Vector3
---@param pos2 CS.UnityEngine.Vector3
---@return number
function SlgUtils.CalcMagnitudeXZ(pos1,pos2)
    return math.sqrt(SlgUtils.CalcSqrMagnitudeXZ(pos1,pos2))
end

---参考TroopModule:GetTroopLeadHeroId找出带头大哥
---@param heros table<number, wds.TroopHero>
function SlgUtils.GetTroopLeadHeroId(heros)
    local FormationUtility = require("FormationUtility")
    local maxIndex = FormationUtility.GetMaxIndex(heros)

    local ret = 0
	local maxPower = -math.huge
    for i = 0, maxIndex do
        local hero = heros[i]
        if hero then
            local power = hero.Power
            if (power > maxPower) then
                maxPower = power
                ret = hero.HeroID
            end
        end
    end
    return ret
end

return SlgUtils