---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wupei.
--- DateTime: 2021/6/27
---


local Behavior = require("Behavior")
local SkillClientGen = require("SkillClientGen")
local Utils = require("Utils")
local TimerUtility = require("TimerUtility")
local Delegate = require("Delegate")
local ConfigRefer = require("ConfigRefer")
local PolicyType = require("PolicyType")
local SELogger = require('SELogger')
local SESceneRoot = require("SESceneRoot")

---@class Effect:Behavior
---@field super Behavior
local Effect = class("Effect", Behavior)

local Vector3 = CS.UnityEngine.Vector3
local Quaternion = CS.UnityEngine.Quaternion

local VectorMult = function(v1, v2)
    return Vector3(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z)
end

local VectorDiv = function(v1, v2)
    return Vector3(v1.x / v2.x, v1.y / v2.y, v1.z / v2.z)
end

local VectorMultNumber = function(v1, v2)
    return Vector3(v1.x * v2, v1.y * v2, v1.z * v2)
end

local VectorDivNumber = function(v1, v2)
    return Vector3(v1.x / v2, v1.y / v2, v1.z / v2)
end

---@param self Effect
---@param ... any
---@return void
function Effect:ctor(...)
    Effect.super.ctor(self, ...)
    ---@type skillclient.data.Effect
    self._effectData = self._data
    self._effect = nil
    self._isFollow = false
    self._startTime = 0
    self._hasCtrl = nil
end

function Effect:GetBulletSpeed(curPos)
    return self._skillParam:GetBulletSpeed()
end

---@param self Effect
---@return void
function Effect:OnStart()
    if string.IsNullOrEmpty(self._effectData.EffectPath) then
        SELogger.Log('Effect:OnStart return: EffectPath is empty')
        return
    end

    self._hasCtrl = self._skillTarget:HasCtrl()

    local success, parent, pos, rot, scale, isLocalPos = self:CheckTransAndParam()
    if not success then
        SELogger.Log('Effect:OnStart return: CheckTransAndParam fail')
        return
    end

    local targetTrans, targetPos
    if self._effectData.IsBallistic then
        targetTrans = self:GetBallisticTargetTrans()
        if Utils.IsNotNull(targetTrans) then
            targetPos = targetTrans.position
        else
            targetPos = self:GetBallisticTargetPosition()
        end
        if not targetPos then
            SELogger.Log('Effect:OnStart return: targetTrans nil')
            return
        end
        local dis = ConfigRefer.ConstSe:SeBulletEffectHideDis() * SESceneRoot.GetClientScale()
        if CS.UnityEngine.Vector3.SqrMagnitude(targetPos - pos) < dis * dis then
            SELogger.Log('Effect:OnStart return: 弹道技过近不显示')
            return -- 弹道技过近的话, 不显示
        end
    end

    self._startTime = g_Game.Time.time

	self._effect = require("SkillClientBullet").new()
    self._effect:SetSkillClientParam(self._skillParam)
	self._effect:SetData(self._effectData)
	self._effect:SetTarget(self._skillTarget)
    if self._effectData.KeepWorldRotation then
        local worldRotation = self._effectData.WorldRotation
        self._effect:SetLockRotation(Quaternion.Euler(worldRotation.x, worldRotation.y, worldRotation.z))
    end

    if parent then
        self._effect:SetParent(parent)
    else
        self._effect:SetParent(SESceneRoot.GetSceneRoot())
    end
	if (self._effectData.IsBallistic) then
		self._effect:SetPosition(pos)
	else
        if not isLocalPos and Utils.IsNotNull(parent) then
            pos = parent:InverseTransformPoint(pos)
        end
		self._effect:SetLocalPosition(pos)
	end
    self._effect:SetLocalRotation(rot)
    self._effect:SetLocalScale(scale)
    if self._effectData.IsBallistic then
        local bulletSpeed = self:GetBulletSpeed(pos)
        self._effect:SetTargetPosition(targetTrans, targetPos, bulletSpeed)
		self._effect:SetProjectileType(self._effectData.ProjectileType)
    end

	self._effect:CreateEffect(self._effectData.EffectPath)
end

---@param self Effect
---@return void
function Effect:CheckTransAndParam()
    local isHitEffect = self._effectData.IsHitEffect
    if isHitEffect then
        if self._effectData.BeHitTag ~= self._skillTarget:GetCtrlEffectTag() then
            return false
        end
    end
    local clientScale = SESceneRoot.GetClientScale()
    local nilParent = SESceneRoot.GetSceneRoot()
    local dataAttach = self._effectData.Attach
    local dataOffset = Vector3(self._effectData.Offset.x * clientScale, self._effectData.Offset.y * clientScale, self._effectData.Offset.z * clientScale)
    local dataRotation = Quaternion.Euler(self._effectData.Rotation)
    local dataScale = self._effectData.Scale
    ---@type CS.UnityEngine.Transform
    local parent
    local pos, rot, scale
    local offsetRot
    local isLocalPos = false
    if isHitEffect then
        local forward = self._skillTarget:GetForwardFromEnemyToAttacker()
        offsetRot = Quaternion.LookRotation(forward)
    end
    if dataAttach == SkillClientGen.Attach.AttachNodeOther then
        local attachTrans = self:GetTransSubNode(self._skillTarget:GetOtherTransform(), self._effectData.AttachNodeName)
        if attachTrans == nil then
            return false
        end
        if not self._effectData.IsFollow or self._effectData.IsBallistic then
            parent = nilParent
            if isHitEffect then
                pos = attachTrans.position + offsetRot * dataOffset
                rot = offsetRot * dataRotation
            else
                pos = attachTrans.position + attachTrans.rotation * dataOffset
                rot = attachTrans.parent.rotation * (attachTrans.localRotation * dataRotation)
            end
            if self._effectData.HitEffectScaleWithModel then
                scale = VectorMult(attachTrans.lossyScale, dataScale)
                scale = VectorDivNumber(scale, clientScale)
            else
                scale = dataScale
            end
        else
            parent = attachTrans
            if isHitEffect then
                isLocalPos = true
                pos = parent:InverseTransformPoint(parent.position + offsetRot * dataOffset)
				--pos = parent.position + offsetRot * dataOffset
                rot = Quaternion.Inverse(parent.rotation) * (offsetRot * dataRotation)
            else
                pos = dataOffset
                rot = dataRotation
            end
            if self._effectData.HitEffectScaleWithModel then
                scale = dataScale
            else
                scale = VectorDiv(dataScale, attachTrans.lossyScale)
                scale = VectorMultNumber(scale, clientScale)
            end
        end
    elseif dataAttach == SkillClientGen.Attach.AttachNodeSelf then
        local attachTrans = self:GetTransSubNode(self._skillTarget:GetTransform(), self._effectData.AttachNodeName)
        if attachTrans == nil then
            return false
        end
        if not self._effectData.IsFollow or self._effectData.IsBallistic then
            parent = nilParent
            if isHitEffect then
                pos = attachTrans.position + offsetRot * dataOffset
                rot = offsetRot * dataRotation
            else
                pos = attachTrans.position + attachTrans.rotation * dataOffset
                rot = attachTrans.parent.rotation * (attachTrans.localRotation * dataRotation)
            end
            if self._effectData.HitEffectScaleWithModel then
                scale = VectorMult(attachTrans.lossyScale, dataScale)
                scale = VectorDivNumber(scale, clientScale)
            else
                scale = dataScale
            end
        else
            parent = attachTrans
            isLocalPos = true
            if isHitEffect then
                pos = parent:InverseTransformPoint(parent.position + offsetRot * dataOffset)
				--pos = parent.position + offsetRot * dataOffset
                rot = Quaternion.Inverse(parent.rotation) * (offsetRot * dataRotation)
            else
                pos = dataOffset
                rot = dataRotation
            end
            if self._effectData.HitEffectScaleWithModel then
                scale = dataScale
            else
                scale = VectorDiv(dataScale, attachTrans.lossyScale)
                scale = VectorMultNumber(scale, clientScale)
            end
        end
    else
        if not self._effectData.IsFollow or self._effectData.IsBallistic then --不挂节点
            parent = nilParent
            local trans
            if dataAttach == SkillClientGen.Attach.OtherRoot then
                trans = self._skillTarget:GetOtherTransform()
            else
                trans = self._skillTarget:GetTransform()
            end
            if trans then
                if isHitEffect then
                    pos = trans.position + offsetRot * dataOffset
                    rot = offsetRot * dataRotation
                else
                    pos = trans.position + trans.rotation * dataOffset
                    rot = trans.parent.rotation * (trans.localRotation * dataRotation)
                end
                if self._effectData.HitEffectScaleWithModel then
                    scale = VectorMult(trans.lossyScale, dataScale)
                    scale = VectorDivNumber(scale, clientScale)
                else
                    scale = dataScale
                end
            else
                if isHitEffect then
                    if dataAttach == SkillClientGen.Attach.OtherRoot then
                        pos = self._skillTarget:GetOtherPosition(dataOffset, offsetRot)
                        rot = offsetRot * dataRotation
                    else
                        pos = self._skillTarget:GetPosition(dataOffset, offsetRot)
                        rot = dataRotation
                    end
                else
                    if dataAttach == SkillClientGen.Attach.OtherRoot then
                        pos = self._skillTarget:GetOtherPosition(dataOffset)
                        rot = dataRotation
                    else
                        pos = self._skillTarget:GetPosition(dataOffset)
                        rot = dataRotation
                    end
                end
                if not pos then
                    return false
                end
                scale = dataScale
            end
        else  --挂节点
            if dataAttach == SkillClientGen.Attach.OtherRoot then
                parent = self._skillTarget:GetOtherTransform()
            else
                parent = self._skillTarget:GetTransform()
            end
            if parent == nil then
                return false
            end
            isLocalPos = true
            if isHitEffect then
                pos = parent:InverseTransformPoint(parent.position + offsetRot * dataOffset)
				--pos = parent.position + offsetRot * dataOffset
                rot = Quaternion.Inverse(parent.rotation) * (offsetRot * dataRotation)
            else
                pos = dataOffset
                rot = dataRotation
            end
            if self._effectData.HitEffectScaleWithModel then
                scale = dataScale
            else
                scale = VectorDiv(dataScale, parent.lossyScale)
                scale = VectorMultNumber(scale, clientScale)
            end
        end
    end
    return true, parent, pos, rot, scale, isLocalPos
end

---@param self Effect
---@param trans CS.UnityEngine.Transform
---@param name any
---@return CS.UnityEngine.Transform
function Effect:GetTransSubNode(trans, name)
    if Utils.IsNotNull(trans) then
        local findTrans = trans:FirstOrDefaultByName(name)
        if findTrans then
            trans = findTrans
        end
    end
    return trans
end

---@param self Effect
---@return CS.UnityEngine.Transform
function Effect:GetBallisticTargetTrans()
    local effectData = self._effectData
    local skillTarget = self._skillTarget
    local attach = effectData.AttachTarget
    local trans
    if attach == SkillClientGen.Attach.AttachNodeOther then
        trans = self:GetTransSubNode(skillTarget:GetOtherTransform(), self._effectData.AttachTargetNodeName)
    elseif attach == SkillClientGen.Attach.OtherRoot then
        trans = skillTarget:GetOtherTransform()
    else
        SELogger.LogError("isBallistic param error, attach = %s. EffectPath = %s", attach, effectData.EffectPath)
    end
    return trans
end

---@return CS.UnityEngine.Vector3
function Effect:GetBallisticTargetPosition()
    local skillParameter = self._skillParam
    if not skillParameter then return nil end
    local serverData = skillParameter:GetServerData()
    if not serverData then return nil end
    local p = serverData.TargetPos
    local mapInfo = skillParameter:GetMapInfo()
    if Utils.IsNull(mapInfo) then return nil end
    local v3Pos = CS.UnityEngine.Vector3(p.X, p.Y, p.Z)
    return mapInfo:ServerPos2Client(v3Pos)
end

---@param self Effect
---@return void
function Effect:OnUpdate()
    if self._hasCtrl and not self._effectData.IsBallistic and self._effectData.DestroyWhenOwnerDie then
        if self._effect and (not self._skillTarget:IsCtrlValid() or self._skillTarget:HasCtrlAndDead()) then
            self._effect:DestroyEffect()
            self._effect = nil
        end
    end
end

---@param self Effect
---@return void
function Effect:OnEnd()
    if self._effect then
        if self._effectData.IsBallistic then --弹道技自己控制生命周期
            --nothing
        elseif not self._effectData.DestroyWhenSkillCancel then
            local delayTime = self._effectData.Time - (g_Game.Time.time - self._startTime)
            TimerUtility.DelayExecute(Delegate.GetOrCreate(self._effect, self._effect.DestroyEffect), delayTime)
        else
            self._effect:DestroyEffect()
        end
        self._effect = nil
    end
end

return Effect
