---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by BE.Tenner.
--- DateTime: 2021/7/15 18:48
---
--- 单位控制器

local SEUnitComponent = require("SEUnitComponent")
local SEUnitComponentType = require("SEUnitComponentType")
--local SEUnitStateType = require("SEUnitStateType")
--local SEUnitType = require("SEUnitType")

---@class SEUnitController:SEUnitComponent
local SEUnitController = class("SEUnitController",  SEUnitComponent);
local SELogger = require("SELogger")

---@param self SEUnitController
---@param unit SEUnit
---@return void
function SEUnitController:ctor(unit)
    SEUnitController.super.ctor(self, SEUnitComponentType.Controller, unit)
    ---@type SEUnitLocomotion
    self.m_locomotion = self:GetUnit():GetLocomotion()
    ---@type SEUnitLocomotion
    self.m_stateMachine = self:GetUnit():GetStateMachine()
    ---@type UnityEngine.Vector3
    self.m_targetPos = nil
    ---@type table<UnityEngine.Vector3>
    self.m_targetPath = nil
    ---@type UnityEngine.Vector3
    self.m_desiredDir = nil
    self._pendingMove = false
end

---@param self SEUnitController
---@param path table<UnityEngine.Vector3>
---@param showWaypoint boolean
---@return void
function SEUnitController:SetTargetPath(path, showWaypoint)
    SELogger.LogLow("unit %s set path %s", self:GetUnit()._id, path)
    self.m_targetPath = path
    self:TryMove(showWaypoint)
end

---@param self SEUnitController
---@param showWaypoint boolean
---@return boolean
function SEUnitController:TryMove(showWaypoint)
    if (self.m_locomotion == nil or self.m_stateMachine == nil) then
        return
    end
    if (self:GetUnit():IsDead()) then
        return
    end

    if (self.m_targetPath) then
        self.m_locomotion:SetPendingPath(self.m_targetPath, true, showWaypoint)
        return true
    else
        self:StopMove()
    end
    return false
end

---@param self SEUnitController
---@param desiredDir UnityEngine.Vector3
---@return UnityEngine.Vector3
function SEUnitController:TryGetSlideToPos(desiredDir)
    -- 当摇杆移动目标点不可达时“挤”人物的算法：
    -- 1. 从当前人物位置向目标位置进行NavMesh.Raycast获得障碍点坐标与对应法线
    -- 2. 将移动期望朝向与障碍点法线相加得到“挤”的方向
    -- 3. 将人物当前位置与障碍点的距离与该方向规一相乘得到目标点偏移量
    -- 4. 将目标点偏移量与障碍点坐标相加得到最终“挤”的目标点坐标
    local result, hit = CS.UnityEngine.AI.NavMesh.Raycast(
            self:GetActor():GetPosition(),
            self.m_targetPos,
            CS.UnityEngine.AI.NavMesh.AllAreas)
    if (result) then
        local newDir = desiredDir.normalized + hit.normal
        local offset = newDir.normalized * CS.UnityEngine.Mathf.Max(0.5, hit.distance)
        local final = offset + hit.position
        return final
    end
    return nil
end

local Ease = CS.DG.Tweening.Ease

---@param self SEUnitController
---@param pos CS.UnityEngine.Vector3
---@param time number
---@param curve any
---@return void
function SEUnitController:TryPushTo(pos, time, curve)
    if (self:GetUnit():IsDead()) then
        return
    end
	
    SELogger.Trace("TryPush %s from %s to %s in %s", self:GetUnit()._id, self:GetUnit():GetActor():GetPosition(), pos, time)

	if (pos.x == 0 and pos.z == 0) then
		SELogger.Trace("Try push to [0,0], ignored!")
		return
	end

	if curve == nil then
		curve = Ease.Linear
	end
	self:StopMove()
	return self:GetActor():GetTransform():DONavMeshMove(pos, time):SetEase(curve):OnComplete(function ()
		self:GetActor():SetServerPosition(pos)
	end)
end

---@param self SEUnitController
---@return void
function SEUnitController:StopMove()
    if (not self._unit._init) then
        return
    end
    self.m_locomotion:Stop()
    self.m_targetPos = nil
    self._pendingMove = false
    self.m_targetPath = {}
end

---@param self SEUnitController
---@param delta number
---@return void
function SEUnitController:Update(delta)
    if (self.m_locomotion and self._pendingMove) then
        self:TryMove()
    end
end

---@param self SEUnitController
---@return boolean
function SEUnitController:HasPendingMove()
    return self._pendingMove
end

return SEUnitController
