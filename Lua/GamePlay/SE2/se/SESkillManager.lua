---
--- SE技能管理器
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by BE.Tenner.
--- DateTime: 2021/9/17 15:41
---
local ModuleRefer = require("ModuleRefer")
local SESceneRoot = require("SESceneRoot")

---@alias ThrowBallParameter {unit:SEUnit, dir:CS.UnityEngine.Vector3, length:number, color:CS.UnityEngine.Color, isVaild:boolean}

---@class SESkillManager
local SESkillManager = class("SESkillManager");

local SKILL_ALERT_RANGE_OFFSET = CS.UnityEngine.Vector3(0, 1, 0)
local SKILL_RANGE_OFFSET = CS.UnityEngine.Vector3(0, -0.5, 0)

local SKILL_RANGE_COLOR_IN_RANGE = CS.UnityEngine.Color.cyan
local SKILL_RANGE_COLOR_OUT_RANGE = CS.UnityEngine.Color.red
local SKILL_CIRCLE_COLOR_IN_RANGE = CS.UnityEngine.Color.white
local SKILL_CIRCLE_COLOR_OUT_RANGE = CS.UnityEngine.Color.red
local SKILL_RANGE_HEIGHT = 3

local CARD_MAX_COUNT = 4
-- local CARD_NEXT_INDEX = 5
-- local PET_CARD_MAX_COUNT = 3

local SKILL_COVERAGE_UPDATE_INTERVAL = 10
local SKILL_FILTER_ENEMY = 1
local SKILL_FILTER_SELF = 2
local SKILL_FILTER_FRIEND = 3

local SKILL_ATTACH_RADIUS = 1
local SKILL_THROW_BALL_INDICATOR_WIDTH = 1

local SkillEnum = require("skill_enum")
local ConfigRefer = require("ConfigRefer")
local Delegate = require("Delegate")
local DBEntityPath = require("DBEntityPath")
local SELogger = require("SELogger")
local ProtocolId = require("ProtocolId")
local ArtResourceUtils = require("ArtResourceUtils")
local ArtResourceConsts = require("ArtResourceConsts")
local Utils = require("Utils")
local SEUnitType = require("SEUnitType")

---@class SECardRuntimeData
---@field used boolean
---@field cdEndMs number
---@field cdMs number
---@field cardConfigCell CardConfigCell
---@field cardServerId number
---@field fightCardInfo wds.FightCardInfo
---@field canUse boolean

---@param self SESkillManager
---@param env SEEnvironment
---@return void
function SESkillManager:ctor(env)
    self:LoadConsts()
    ---@type SEEnvironment
    self._env = env
    ---@type CS.UnityEngine.GameObject
    self._circleSelectorGo = nil
    self._circleSelectorPending = false
    self._circleSelectorShow = false
    ---@type CS.SECircleAreaSelector
    self._circleSelector = nil
    ---@type CS.UnityEngine.GameObject
    self._skillRangeCircleGo = nil
    self._skillRangeCirclePending = false
    self._skillRangeCircleShow = false
    ---@type CS.SESkillRangeCircle
    self._skillRangeCircle = nil
    ---@type CS.UnityEngine.GameObject
    self._skillRangeRectGo = nil
    ---@type CS.SESkillRangeRect
    self._skillRangeRect = nil
    self._skillRangeRectPending = false
    self._skillRangeRectShow = false
    ---@type CS.UnityEngine.GameObject
    self._skillRangeFanGo = nil
    ---@type CS.SESkillRangeFan
    self._skillRangeFan = nil
    self._skillRangeFanPending = false
    self._skillRangeFanShow = false
    ---@type CS.UnityEngine.GameObject
    self._throwBallGo = nil
    ---@type CS.SESkillRangeRect
    self._throwBall = nil
    self._throwBallPending = false
    self._throwBallShow = false
    ---@type ThrowBallParameter
    self._throwBallShowParameter = {isVaild = false}
    ---@type SEHero
    self._usingSkillHero = nil
    self._usingSkillCardServerId = 0
    self._usingSkill = nil
    self._usingSkillCancelling = false
    self._usingSkillOutOfRange = false
	self._usingSkillNoRange = false
    ---@type CS.UnityEngine.Vector3
    self._usingSkillPos = CS.UnityEngine.Vector3.zero
    ---@type CS.UnityEngine.Vector3
    self._usingSkillOffset = CS.UnityEngine.Vector3.zero
    self._usingSkillDefaultTarget = false
    self._usingSkillDead = false
    self._usingSkillEnergy = 0
    self._skillUseTime = {}
    ---@type table<number, table<number, SECardRuntimeData>>
    self._cardList = {}
    self._createHelper = env:GetCreateHelper()
	---@type CS.UnityEngine.GameObject
	self._skillPreviewModelRoot = nil
	self._lastSkillCoverageUpdateTime = 0
    self._lastThrowBallStatus = false
    ---@type {unit:SEUnit, cancelFunc:fun()}
    self._lastThrowBallAimSkillHandle = nil
    ---@type SEUnit
    self._lastThrowBallTargetUnit = nil
    self._lastThrowBallTargetUnitHudSet = false
    ---@type SEUnit
    self._isInThrowBallTimeOperateUnit = nil
    ---@type SETeam
    self._isInThrowBallTimeOperateUnitTeam = nil
    self._allowThrowBallTimeSlow = ConfigRefer.ConstMain.PetCatchSlowMaxDuration and ConfigRefer.ConstMain:PetCatchSlowMaxDuration() > 0
    self._throwBallTimeSlowSpeed = ConfigRefer.ConstMain:PetCatchSlowValue()
    self._sceneDarkTarget = nil
    self._sceneDarkTargetTime = nil
    self._sceneDarkTimeDef = 0.5

    self:PrecacheCircleSelector()
    self:PrecacheSkillRangeCircle()
    self:PrecacheSkillRangeRect()
    self:PrecacheSkillRangeFan()

    -- Card and energy change
    -- g_Game.DatabaseManager:AddChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.JustForChange.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
    -- g_Game.DatabaseManager:AddChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.CardIds.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
	-- g_Game.DatabaseManager:AddChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.CardInfos.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
	-- g_Game.DatabaseManager:AddChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.PetCardIds.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
    self:GetEnvironment():GetWdsManager():AddOnPlayerCardChange(Delegate.GetOrCreate(self, self.OnPlayerCardChange))
    self:OnPlayerCardChange()

    -- Use skill resp
    g_Game.ServiceManager:AddResponseCallback(ProtocolId.CastCardSkillNew, Delegate.GetOrCreate(self, self.CastSkillResponse))
end

---@param self SESkillManager
function SESkillManager:LoadConsts()
    SKILL_RANGE_COLOR_IN_RANGE = CS.UnityEngine.Color(
        ConfigRefer.ConstSe:SeSkillRangeColorCan(1),
        ConfigRefer.ConstSe:SeSkillRangeColorCan(2),
        ConfigRefer.ConstSe:SeSkillRangeColorCan(3),
        ConfigRefer.ConstSe:SeSkillRangeColorCan(4))
    SKILL_RANGE_COLOR_OUT_RANGE = CS.UnityEngine.Color(
        ConfigRefer.ConstSe:SeSkillRangeColorCannot(1),
        ConfigRefer.ConstSe:SeSkillRangeColorCannot(2),
        ConfigRefer.ConstSe:SeSkillRangeColorCannot(3),
        ConfigRefer.ConstSe:SeSkillRangeColorCannot(4))
    SKILL_CIRCLE_COLOR_IN_RANGE = CS.UnityEngine.Color(
        ConfigRefer.ConstSe:SeSkillCircleColorCan(1),
        ConfigRefer.ConstSe:SeSkillCircleColorCan(2),
        ConfigRefer.ConstSe:SeSkillCircleColorCan(3),
        ConfigRefer.ConstSe:SeSkillCircleColorCan(4))
    SKILL_CIRCLE_COLOR_OUT_RANGE = CS.UnityEngine.Color(
        ConfigRefer.ConstSe:SeSkillCircleColorCannot(1),
        ConfigRefer.ConstSe:SeSkillCircleColorCannot(2),
        ConfigRefer.ConstSe:SeSkillCircleColorCannot(3),
        ConfigRefer.ConstSe:SeSkillCircleColorCannot(4))
    CARD_MAX_COUNT = ConfigRefer.ConstSe.SeFightCardGroupEffectCount and ConfigRefer.ConstSe:SeFightCardGroupEffectCount() or 4
	SKILL_COVERAGE_UPDATE_INTERVAL = ConfigRefer.ConstSe.SeSkillCoverageUpdateInterval and ConfigRefer.ConstSe:SeSkillCoverageUpdateInterval() or SKILL_COVERAGE_UPDATE_INTERVAL
	SKILL_ATTACH_RADIUS = ConfigRefer.ConstSe.SeSkillAttachRadius and ConfigRefer.ConstSe:SeSkillAttachRadius() or SKILL_ATTACH_RADIUS
    SKILL_THROW_BALL_INDICATOR_WIDTH = ConfigRefer.ConstSe:SEJoyStickThrowBallIndicatorWidth()
end

---@param self SESkillManager
---@return SEEnvironment
function SESkillManager:GetEnvironment()
    return self._env
end

---@param self SESkillManager
---@return void
function SESkillManager:Dispose()
    -- g_Game.DatabaseManager:RemoveChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.JustForChange.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
    -- g_Game.DatabaseManager:RemoveChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.CardIds.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
	-- g_Game.DatabaseManager:RemoveChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.CardInfos.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
	-- g_Game.DatabaseManager:RemoveChanged(DBEntityPath.ScenePlayer.ScenePlayerCard.PetCardIds.MsgPath, Delegate.GetOrCreate(self, self.OnPlayerCardChange))
    if self._isInThrowBallTimeOperateUnit then
        self:GetEnvironment():SetThrowBallStart(false, self._isInThrowBallTimeOperateUnit:GetID(), 1)
        self._isInThrowBallTimeOperateUnit = nil
    end
    if self._isInThrowBallTimeOperateUnitTeam then
        self._isInThrowBallTimeOperateUnitTeam:RecoverTick()
    end
    self._isInThrowBallTimeOperateUnitTeam = nil
    self:GetEnvironment():GetWdsManager():RemoveOnPlayerCardChange(Delegate.GetOrCreate(self, self.OnPlayerCardChange))
	g_Game.ServiceManager:RemoveResponseCallback(ProtocolId.CastCardSkillNew, Delegate.GetOrCreate(self, self.CastSkillResponse))
    self:ThrowBallAimingSkillCancel()
    self:CancelSkill(nil, true)
    self._circleSelectorShow = false
    self._skillRangeFanShow = false
    self._skillRangeRectShow = false
    self._throwBallShow = false
    self._throwBallShowParameter.isVaild = false
    if (self._skillRangeCircleGo) then
        self._skillRangeCircle = nil
        CS.UnityEngine.GameObject.Destroy(self._skillRangeCircleGo)
    end
    if (self._circleSelectorGo) then
        self._circleSelector = nil
        CS.UnityEngine.GameObject.Destroy(self._circleSelectorGo)
    end
    if (self._skillRangeFanGo) then
        self._skillRangeFan = nil
        CS.UnityEngine.GameObject.Destroy(self._skillRangeFanGo)
    end
    if (self._skillRangeRectGo) then
        self._skillRangeRect = nil
        CS.UnityEngine.GameObject.Destroy(self._skillRangeRectGo)
    end
    if Utils.IsNotNull(self._throwBallGo) then
        self._throwBall = nil
        CS.UnityEngine.GameObject.Destroy(self._throwBallGo)
    end
    self._sceneDarkTargetTime = 0
    self._sceneDarkTarget = 0
    self:TickSceneDarkTargetTween()
    self._sceneDarkTarget = nil
end

---技能按钮按下
---@param self SESkillManager
---@param hero SEHero
---@param skill KheroSkillLogicalSeConfigCell
---@param cardServerId number
---@param deadSkill boolean
---@param skillEnergy number
---@param noRange boolean
function SESkillManager:OnSkillPress(hero, skill, cardServerId, deadSkill, skillEnergy, noRange)
    if hero == nil then
        self:CancelSkill(nil, true)
        return
    end

    self._usingSkillHero = hero
    self._usingSkill = skill
    self._usingSkillCardServerId = cardServerId
    self._usingSkillCancelling = false
    self._usingSkillEnergy = skillEnergy
	self._usingSkillNoRange = noRange
    if (hero and hero:GetActor()) then
        self._usingSkillPos = hero:GetActor():GetPosition()
    end
    self._usingSkillDead = deadSkill

    if (not self._usingSkillDead) then
        if (skill:UILimitDis()) then
            self:ShowCircleSelector(hero, skill:DistanceMax())
        else
            self:HideCircleSelector()
        end
        self:SkillUsingUpdate()
    end
end

---@param self SESkillManager
---@param callback fun(CS.UnityEngine.Vector3)
function SESkillManager:SetUsingSkillCallback(callback)
	self._usingSkillCallback = callback
end

---技能使用
---@param self SESkillManager
---@param pos CS.UnityEngine.Vector3
---@param cancelling boolean
---@param outOfRange boolean
function SESkillManager:OnSkillUsing(pos, cancelling, outOfRange)
    if (self._usingSkillDead or not self._usingSkillHero or not self._usingSkill) then
        return self._usingSkillPos
    end

    self._usingSkillPos = pos
    self._usingSkillCancelling = cancelling
    self._usingSkillOutOfRange = outOfRange
    if (self._usingSkillCancelling or self._usingSkillNoRange) then
        self:HideSkillRangeCircle()
        self:HideSkillRangeRect()
        self:HideSkillRangeFan()
        self:HideCircleSelector()
		if (self._usingSkillCancelling) then
			return self._usingSkillPos
		end
    end

	self._lastSkillCoverageUpdateTime = 0
    self:SkillUsingUpdate()
end

---技能使用更新
---@param self SESkillManager
---@return void
function SESkillManager:SkillUsingUpdate()
    if (self._usingSkillDead or not self._usingSkillHero or not self._usingSkill) then
        return
    end
    if (self._usingSkillCancelling or self._usingSkillNoRange) then
        self:HideSkillRangeCircle()
        self:HideSkillRangeRect()
        self:HideSkillRangeFan()
        self:HideCircleSelector()
		if (self._usingSkillCancelling) then
			return
		end
    end

	local heroPos = self._usingSkillHero:GetActor():GetPosition()
	
	--- 非摇杆技限定脚下
	if (not self._usingSkill:RockSkill()) then
		self._usingSkillPos = heroPos
	end

	-- 技能吸附
	local filterEnemy = false
	for i = 1, self._usingSkill:FilterTypesLength() do
		if (self._usingSkill:FilterTypes(i) == SKILL_FILTER_ENEMY) then
			filterEnemy = true
			break
		end
	end
	if (filterEnemy) then
		local nearestUnit = self._env._unitManager:GetNearestUnit(self._usingSkillPos, SKILL_ATTACH_RADIUS, true)
		if (nearestUnit) then
			self._usingSkillPos = nearestUnit:GetActor():GetPosition()
		end
	end

    if (self._usingSkill:Shape() == SkillEnum.ShapeType.ShapeTypeRound) then
        local outOfRange = false
        if (self._usingSkill:BlockCheck()) then
            outOfRange = self._usingSkillHero:GetLocomotion():HasObstacleBetween(self._usingSkillPos)
        end
        local dist = CS.UnityEngine.Vector3.Distance(heroPos, self._usingSkillPos) / require("SESceneRoot").GetClientScale()
        if (dist > self._usingSkill:DistanceMax()) then
            -- 圆形技能超出可使用范围时，自动找范围内最近的一点
            local dir = (self._usingSkillPos - heroPos).normalized
            self._usingSkillPos = heroPos + dir * self._usingSkill:DistanceMax()
        end
		if (not self._usingSkillNoRange) then
			self:ShowSkillRangeCircle(self._usingSkillHero, self._usingSkillPos, self._usingSkill:Length(),
				outOfRange or self._usingSkillOutOfRange)
		end
		if (self._usingSkill:PreviewModel() == 0 and
				g_Game.Time.time - self._lastSkillCoverageUpdateTime >= SKILL_COVERAGE_UPDATE_INTERVAL) then
			self._lastSkillCoverageUpdateTime = g_Game.Time.time
			self._env._unitManager:ResetAllSkillCoverage()
			self._env._unitManager:CalcSkillCoverageCircle(self._usingSkillPos, self._usingSkill:Length(),
					self._usingSkill:FilterTypes(1), self._usingSkillHero)
		end
    elseif (self._usingSkill:Shape() == SkillEnum.ShapeType.ShapeTypeRectangle) then
		if (not self._usingSkillNoRange) then
			self:ShowSkillRangeRect(self._usingSkillHero, self._usingSkillPos, self._usingSkill:Width(), self._usingSkill:Length())
		end
		if (self._usingSkill:PreviewModel() == 0 and
				g_Game.Time.time - self._lastSkillCoverageUpdateTime >= SKILL_COVERAGE_UPDATE_INTERVAL) then
			self._lastSkillCoverageUpdateTime = g_Game.Time.time
			self._env._unitManager:ResetAllSkillCoverage()
			local corners = self._skillRangeRect.WorldXZCorners
			if (corners and corners[0] and corners[1] and corners[2]) then
				self._env._unitManager:CalcSkillCoverageRect(corners[0], corners[1], corners[2],
					self._usingSkill:FilterTypes(1), self._usingSkillHero)
			end
		end
    elseif (self._usingSkill:Shape() == SkillEnum.ShapeType.ShapeTypeSector) then
		if (not self._usingSkillNoRange) then
			self:ShowSkillRangeFan(self._usingSkillHero, self._usingSkillPos, self._usingSkill:Length(), self._usingSkill:Angle())
		end
		if (self._usingSkill:PreviewModel() == 0 and
				g_Game.Time.time - self._lastSkillCoverageUpdateTime >= SKILL_COVERAGE_UPDATE_INTERVAL) then
			self._lastSkillCoverageUpdateTime = g_Game.Time.time
			self._env._unitManager:ResetAllSkillCoverage()
			self._env._unitManager:CalcSkillCoverageFan(self._usingSkillHero:GetActor():GetPosition(), self._skillRangeFanGo.transform.forward,
					self._usingSkill:Angle(), self._usingSkill:Length(), self._usingSkill:FilterTypes(1), self._usingSkillHero)
		end
    end
    if (self._usingSkill:UILimitDis()) then
        self:ShowCircleSelector(self._usingSkillHero, self._usingSkill:DistanceMax())
    else
        self:HideCircleSelector()
    end
    self:UpdateCircleSelector()
	if (self._usingSkillCallback) then
		self._usingSkillCallback(self._usingSkillPos)
	end
end

---@param self SESkillManager
---@param cancelling boolean
function SESkillManager:SetUsingSkillCancelling(cancelling)
    self._usingSkillCancelling = cancelling
end

---技能结束
---@param self SESkillManager
---@return boolean
function SESkillManager:OnSkillFinish()
	self._env._unitManager:ResetAllSkillCoverage()

    if (not self._usingSkillHero or not self._usingSkill or self._usingSkillCardServerId <= 0) then
        self:CancelSkill(nil, true)
        return false
    end

    local result = true
    if (self._usingSkillCancelling) then
        SELogger.Trace("Skill cancelled!")
        result = false
    else
        -- Dead card
        if (self._usingSkillDead) then
            self:UseSkill(self._usingSkillCardServerId, self._usingSkillHero, CS.UnityEngine.Vector3.zero)
        else
            -- 阻挡检查
            local blocked = false
            if (self._usingSkill:BlockCheck()) then
                blocked = self._usingSkillHero:GetLocomotion():HasObstacleBetween(self._usingSkillPos)
                if (blocked) then
                    SELogger.Trace("Skill is blocked!")
                    result = false
                end
            end
            if (not blocked) then
                SELogger.Trace("Skill used! %s %s", self._usingSkill:Id(), self._usingSkill:Asset())
                self:UseSkill(self._usingSkillCardServerId, self._usingSkillHero, self._usingSkillPos)
            end
        end
    end
    self:CancelSkill(nil, true)
    return result
end

---使用技能
---@param self SESkillManager
---@param cardId number
---@param user SEUnit
---@param pos CS.UnityEngine.Vector3
---@param target SEUnit
---@return void
function SESkillManager:UseSkill(cardId, user, pos, target)
    if (not cardId or not user or not pos) then
        SELogger.LogError("Error using skill! cardId: %s, user: %s, pos: %s", cardId, user, pos)
        return
    end
    SELogger.Trace("*** UseCardSkill: time: %s, cardId: %s, userId: %s, pos: %s", g_Game.Time.time, cardId, user._id, pos)

    -- self._energy = self._energy - self._usingSkillEnergy

    local msg = require("CastCardSkillNewParameter").new()
    msg.args.ReleaserId = user._id
	msg.args.CardCompId = cardId

    local userPos = CS.UnityEngine.Vector3.zero
    if (user and user:GetActor()) then
        userPos = user:GetActor():GetPosition()
    end
    local userSPos = self:GetEnvironment():ClientPos2Server(userPos)
    local dir = (pos - userPos).normalized
    if (dir.x == 0 and dir.z == 0) then
        dir = user:GetActor():GetForward()
    end
    local tpos = self:GetEnvironment():ClientPos2Server(pos)
    local tdir = self:GetEnvironment():ClientPos2Server(dir)
    msg.args.ReleaserPos.X = userSPos.x
    msg.args.ReleaserPos.Y = userSPos.y
    msg.args.ReleaserPos.Z = userSPos.z
    msg.args.TargetPos.X = tpos.x
    msg.args.TargetPos.Y = tpos.y
    msg.args.TargetPos.Z = tpos.z
    msg.args.TargetDir.X = tdir.x
    msg.args.TargetDir.Y = tdir.y
    msg.args.TargetDir.Z = tdir.z
    if (target) then
        msg.args.TargetId = target._id
    end
    msg:Send()
end

---通过定义获取技能
---@param self SESkillManager
---@param skillCds KheroSkillLogicalSeConfigCell
---@param def number
---@return KheroSkillLogicalSeConfigCell,number
function SESkillManager:GetSkillByDef(skillCds, def)
    if (not skillCds) then
        return nil
    end

    for id, cd in pairs(skillCds) do
        local skill = ConfigRefer.KheroSkillLogicalSe:Find(id)
        if (skill) then
            if (skill.SkillDef == def) then
                return skill, cd
            end
        end
    end

    return nil
end

---取消技能
---@param self SESkillManager
---@param hero SEHero
---@param force boolean
---@return void
function SESkillManager:CancelSkill(hero, force)
	if (not self._usingSkill) then return end
    SELogger.LogLow("Cancel Skill %s %s", hero, force)
    if (force or self._usingSkillHero == hero) then
		if (self._usingSkill:PreviewModel() > 0) then
			self:GetEnvironment():GetUiBattlePanel():RecycleModelRoot()
		end
		self:GetEnvironment():GetUiBattlePanel():CancelCardUsingByHero(hero or self._usingSkillHero)
        self:HideSkillRangeCircle()
        self:HideSkillRangeRect()
        self:HideCircleSelector()
        self:HideSkillRangeFan()
        self._usingSkillHero = nil
        self._usingSkill = nil
        self._usingSkillCancelling = false
        self._usingSkillCardServerId = 0
        self._usingSkillEnergy = 0
    end
end

---预载扇形技能区域
---@param self SESkillManager
---@return void
function SESkillManager:PrecacheSkillRangeFan()
    if (self._skillRangeFanGo or self._skillRangeFanPending) then
        return
    end
    self._skillRangeFanPending = true
    self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_skill_range_fan), require("SESceneRoot").GetSceneRoot(), function(go)
        self._skillRangeFanGo = go
        self._skillRangeFan = self._skillRangeFanGo:GetComponent(typeof(CS.SESkillRangeFan))
        self._skillRangeFanGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
        self._skillRangeFanGo:SetActive(false)
        self._skillRangeFanPending = false
    end)
end

---预载圆形技能区域
---@param self SESkillManager
---@return void
function SESkillManager:PrecacheSkillRangeCircle()
    if (self._skillRangeCircleGo or self._skillRangeCirclePending) then
        return
    end
    self._skillRangeCirclePending = true
    self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_skill_range_circle), require("SESceneRoot").GetSceneRoot(), function(go)
        self._skillRangeCircleGo = go
        self._skillRangeCircle = self._skillRangeCircleGo:GetComponent(typeof(CS.SESkillRangeCircle))
        self._skillRangeCircleGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
        self._skillRangeCircleGo:SetActive(false)
        self._skillRangeCirclePending = false
    end)
end

---显示圆形技能区域
---@param self SESkillManager
---@param unit SEUnit
---@param pos CS.UnityEngine.Vector3
---@param radius number
---@param outOfRange boolean
---@return void
function SESkillManager:ShowSkillRangeCircle(unit, pos, radius, outOfRange)
    self._skillRangeCircleShow = true
    if (not self._skillRangeCircleGo) then
        if (self._skillRangeCirclePending) then
            return
        end
        self._skillRangeCirclePending = true
        self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_skill_range_circle), require("SESceneRoot").GetSceneRoot(), function(go)
            self._skillRangeCircleGo = go
            self._skillRangeCircle = self._skillRangeCircleGo:GetComponent(typeof(CS.SESkillRangeCircle))
            self._skillRangeCircleGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
            self._skillRangeCircleGo:SetActive(false)
            self:ShowSkillRangeCircleCallback(unit, pos, radius, outOfRange)
            self._skillRangeCirclePending = false
        end)
    else
        self:ShowSkillRangeCircleCallback(unit, pos, radius, outOfRange)
    end
end

---显示圆形技能区域回调
---@param self SESkillManager
---@param unit SEUnit
---@param pos CS.UnityEngine.Vector3
---@param radius number
---@param outOfRange boolean
---@return void
function SESkillManager:ShowSkillRangeCircleCallback(unit, pos, radius, outOfRange)
    if (not self._skillRangeCircleShow) then
        return
    end
    if (not unit) then
        return
    end
    local actor = unit:GetActor()
    if (not actor) then
        return
    end
    if (not pos) then
        return
    end
    local color = SKILL_RANGE_COLOR_IN_RANGE
    if (outOfRange) then
        color = SKILL_RANGE_COLOR_OUT_RANGE
    end
    local clientScale = SESceneRoot.GetClientScale()
    self._skillRangeCircleGo.transform.position = pos + CS.UnityEngine.Vector3.up * SKILL_RANGE_HEIGHT * 0.5 * clientScale + SKILL_RANGE_OFFSET * clientScale
    self._skillRangeCircle:SetRadius(radius)
    self._skillRangeCircle.Color = color
    self._skillRangeCircleGo:SetActive(true)
end

---隐藏圆形技能区域
---@param self SESkillManager
---@return void
function SESkillManager:HideSkillRangeCircle()
    self._skillRangeCircleShow = false
    if (self._skillRangeCircleGo) then
        self._skillRangeCircleGo:SetActive(false)
    end
end

---预载矩形技能区域
---@param self SESkillManager
---@return void
function SESkillManager:PrecacheSkillRangeRect()
    if (self._skillRangeRectGo or self._skillRangeRectPending) then
        return
    end
    self._skillRangeRectPending = true
    self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_skill_range_rect), require("SESceneRoot").GetSceneRoot(), function(go)
        self._skillRangeRectGo = go
        self._skillRangeRect = self._skillRangeRectGo:GetComponent(typeof(CS.SESkillRangeRect))
        self._skillRangeRectGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
        self._skillRangeRectGo:SetActive(false)
        self._skillRangeRectPending = false
    end)
end

---显示矩形技能区域
---@param self SESkillManager
---@param unit SEUnit
---@param pos CS.UnityEngine.Vector3
---@param width number
---@param length number
---@return void
function SESkillManager:ShowSkillRangeRect(unit, pos, width, length)
    self._skillRangeRectShow = true
    if (not self._skillRangeRectGo) then
        if (self._skillRangeRectPending) then
            return;
        end
        self._skillRangeRectPending = true
        self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_skill_range_rect), require("SESceneRoot").GetSceneRoot(), function(go)
            self._skillRangeRectGo = go
            self._skillRangeRect = self._skillRangeRectGo:GetComponent(typeof(CS.SESkillRangeRect))
            self._skillRangeRectGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
            self._skillRangeRectGo:SetActive(false)
            self:ShowSkillRangeRectCallback(unit, pos, width, length)
            self._skillRangeRectPending = false
        end)
    else
        self:ShowSkillRangeRectCallback(unit, pos, width, length)
    end
end

---显示矩形技能区域
---@param self SESkillManager
---@param unit SEUnit
---@param pos CS.UnityEngine.Vector3
---@param width number
---@param length number
---@return void
function SESkillManager:ShowSkillRangeRectCallback(unit, pos, width, length)
    if (not self._skillRangeRectShow) then
        if (self._skillRangeRectGo) then
            self._skillRangeRectGo:SetActive(false)
        end
        return
    end
    if (not unit) then
        return
    end
    local actor = unit:GetActor()
    if (not actor) then
        return
    end
    local actorPos = actor:GetPosition()
    if (self._skillRangeRectGo) then
        local clientScale = SESceneRoot.GetClientScale()
        self._skillRangeRectGo.transform.position = actorPos + CS.UnityEngine.Vector3.up * SKILL_RANGE_HEIGHT * 0.5 * clientScale + SKILL_RANGE_OFFSET * clientScale
        ---@type CS.UnityEngine.Vector3
        local lookAtPos
        if (pos == actorPos) then
            lookAtPos = actor:GetTransform().forward * length + actorPos
        else
            lookAtPos = (pos - actorPos).normalized * length + actorPos
        end
        self._skillRangeRectGo.transform:LookAt(lookAtPos)
        local la = self._skillRangeRectGo.transform.localEulerAngles
        self._skillRangeRectGo.transform.localEulerAngles = CS.UnityEngine.Vector3(0, la.y, 0)
        --SELogger.Trace("Rect forward: %s", self._skillRangeRectGo.transform.forward)
        self._skillRangeRect:SetRect(width, length)
		self._skillRangeRect.Color = SKILL_RANGE_COLOR_IN_RANGE
        self._skillRangeRectGo:SetActive(true)
    end
end

---隐藏矩形技能区域
---@param self SESkillManager
---@return void
function SESkillManager:HideSkillRangeRect()
    self._skillRangeRectShow = false
    if (self._skillRangeRectGo) then
        self._skillRangeRectGo:SetActive(false)
    end
end

---预载圆形技能范围
---@param self SESkillManager
---@return void
function SESkillManager:PrecacheCircleSelector()
    if (self._circleSelectorGo or self._circleSelectorPending) then
        return
    end
    self._circleSelectorPending = true
    self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_circle_selector), require("SESceneRoot").GetSceneRoot(), function(go)
        self._circleSelectorGo = go
        self._circleSelector = self._circleSelectorGo:GetComponent(typeof(CS.SECircleAreaSelector))
        self._circleSelectorGo:SetActive(false)
        self._circleSelectorGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
        self._circleSelectorPending = false
    end)
end

---更新圆形技能范围
---@param self SESkillManager
---@return void
function SESkillManager:UpdateCircleSelector()
    if (not self._circleSelectorShow or not self._circleSelectorGo or not self._circleSelector) then
        return
    end
    local color = SKILL_CIRCLE_COLOR_IN_RANGE
    if (self._usingSkillOutOfRange) then
        color = SKILL_CIRCLE_COLOR_OUT_RANGE
    else
        local blocked = false
        if (self._usingSkill:BlockCheck()) then
            blocked = self._usingSkillHero:GetLocomotion():HasObstacleBetween(self._usingSkillPos)
        end
        if (blocked) then
            color = SKILL_CIRCLE_COLOR_OUT_RANGE
        end
    end
    self._circleSelector.Color = color
end

---显示圆形技能范围
---@param self SESkillManager
---@param hero SEHero
---@param radius number
---@return void
function SESkillManager:ShowCircleSelector(hero, radius)
    self._circleSelectorShow = true
    if (not self._circleSelectorGo) then
        if (self._circleSelectorPending) then
            return
        end
        self._circleSelectorPending = true
        self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_circle_selector), require("SESceneRoot").GetSceneRoot(), function(go)
            self._circleSelectorGo = go
            self._circleSelector = self._circleSelectorGo:GetComponent(typeof(CS.SECircleAreaSelector))
            self._circleSelectorGo:SetActive(false)
            self:ShowCircleSelectorCallback(hero, radius)
            self._circleSelectorPending = false
        end)
    else
        self:ShowCircleSelectorCallback(hero, radius)
    end
end

---显示圆形技能范围回调
---@param self SESkillManager
---@param hero SEUnit
---@param radius number
---@return void
function SESkillManager:ShowCircleSelectorCallback(hero, radius)
    if (not self._circleSelectorShow or not hero or not hero:GetActor()) then
        self:HideCircleSelector()
        return
    end
    local actor = hero:GetActor()
    if (self._circleSelectorGo) then
        self._circleSelectorGo.transform:SetParent(actor:GetTransform())
        local clientScale = SESceneRoot.GetClientScale()
        self._circleSelectorGo.transform.localPosition = CS.UnityEngine.Vector3.up * SKILL_RANGE_HEIGHT * 0.5 * clientScale + SKILL_RANGE_OFFSET * clientScale
        self._circleSelector:SetRadius(radius)
        self._circleSelectorGo:SetActive(true)
    end
end

---隐藏圆形技能范围
---@param self SESkillManager
---@return void
function SESkillManager:HideCircleSelector()
    self._circleSelectorShow = false
    if (self._circleSelectorGo) then
        self._circleSelectorGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
        self._circleSelectorGo:SetActive(false)
    end
end

---显示扇形技能范围
---@param self SESkillManager
---@param unit SEUnit
---@param pos CS.UnityEngine.Vector3
---@param radius number
---@param angle number
---@return void
function SESkillManager:ShowSkillRangeFan(unit, pos, radius, angle)
    self._skillRangeFanShow = true
    if (not self._skillRangeFanGo) then
        if (self._skillRangeFanPending) then
            return
        end
        self._skillRangeFanPending = true
        self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_skill_range_fan), require("SESceneRoot").GetSceneRoot(), function(go)
            self._skillRangeFanGo = go
            self._skillRangeFan = self._skillRangeFanGo:GetComponent(typeof(CS.SESkillRangeFan))
            self._skillRangeFanGo:SetActive(false)
            self:ShowSkillRangeFanCallback(unit, pos, radius, angle)
            self._skillRangeFanPending = false
        end)
    else
        self:ShowSkillRangeFanCallback(unit, pos, radius, angle)
    end
end

---显示扇形技能范围回调
---@param self SESkillManager
---@param unit SEUnit
---@param pos CS.UnityEngine.Vector3
---@param radius number
---@param angle number
---@return void
function SESkillManager:ShowSkillRangeFanCallback(unit, pos, radius, angle)
    if (not self._skillRangeFanShow) then
        self._skillRangeFanGo:SetActive(false)
        return
    end
    if (not unit) then
        return
    end
    local actor = unit:GetActor()
    if (not actor) then
        return
    end
    local actorPos = actor:GetPosition()
    if (self._skillRangeFanGo) then
        self._skillRangeFanGo.transform:SetParent(actor:GetTransform())
        self._skillRangeFan:SetRadiusAngle(radius, angle)
        local clientScale = SESceneRoot.GetClientScale()
        self._skillRangeFanGo.transform.position = actorPos + CS.UnityEngine.Vector3.up * SKILL_RANGE_HEIGHT * 0.5 * clientScale + SKILL_RANGE_OFFSET * clientScale
        ---@type CS.UnityEngine.Vector3
        local lookAtPos
        if (pos == actorPos) then
            lookAtPos = actor:GetTransform().forward * radius + actorPos
        else
            lookAtPos = (pos - actorPos).normalized * radius + actorPos
        end
        self._skillRangeFanGo.transform:LookAt(lookAtPos)
        local la = self._skillRangeFanGo.transform.localEulerAngles
        self._skillRangeFanGo.transform.localEulerAngles = CS.UnityEngine.Vector3(0, la.y, 0)
		self._skillRangeFan.Color = SKILL_RANGE_COLOR_IN_RANGE
        self._skillRangeFanGo:SetActive(true)
    end
end

---隐藏扇形技能范围
---@param self SESkillManager
---@return void
function SESkillManager:HideSkillRangeFan()
    self._skillRangeFanShow = false
    if (self._skillRangeFanGo) then
        self._skillRangeFanGo.transform:SetParent(self:GetEnvironment():GetMapRoot())
        self._skillRangeFanGo:SetActive(false)
    end
end

---显示扔球指示器
function SESkillManager:ShowThrowBallIndicator(unit, dir, length, color)
    self._throwBallShow = true
    ---@type ThrowBallParameter
    local par = self._throwBallShowParameter
    par.unit = unit
    par.dir = dir
    par.length = length
    par.color = color
    par.isVaild = true
    if Utils.IsNull(self._throwBallGo) then
        if self._throwBallPending then
            return
        end
        self._throwBallPending = true
        self._createHelper:Create(ArtResourceUtils.GetItem(ArtResourceConsts.se_throw_ball_indicator), require("SESceneRoot").GetSceneRoot(), function(go)
            self._throwBallGo = go
            self._throwBall = self._throwBallGo:GetComponent(typeof(CS.SESkillRangeRect))
            self._throwBallGo:SetActive(false)
            self:ShowThrowBallIndicatorCallback()
            self._throwBallPending = false
        end)
    else
        self:ShowThrowBallIndicatorCallback()
    end
end

---显示扔球指示器回调
function SESkillManager:ShowThrowBallIndicatorCallback()
    if Utils.IsNull(self._throwBallGo) then
        return
    end
    local par = self._throwBallShowParameter
    if not par or not par.isVaild or (not self._throwBallShow) or (not self._throwBall) then
        self._throwBallGo:SetActive(false)
        return
    end
    local unit, dir, length, color = par.unit, par.dir, par.length, par.color
    if (not unit) then
        return
    end
    local actor = unit:GetActor()
    if (not actor) then
        return
    end
    local actorPos = actor:GetPosition()
    if not actorPos then return end
    local clientScale = SESceneRoot.GetClientScale()
    local trans = self._throwBallGo.transform
    trans.position = actorPos + CS.UnityEngine.Vector3.up * SKILL_RANGE_HEIGHT * 0.5 * clientScale  + SKILL_RANGE_OFFSET * clientScale
    ---@type CS.UnityEngine.Vector3
    local lookAtPos = dir * length + actorPos
    trans:LookAt(lookAtPos)
    local la = trans.localEulerAngles
    trans.localEulerAngles = CS.UnityEngine.Vector3(0, la.y, 0)
    self._throwBall:SetRect(SKILL_THROW_BALL_INDICATOR_WIDTH, length)
	self._throwBall.Color = color
    self._throwBallGo:SetVisible(true)
end

---隐藏扔球指示器
function SESkillManager:HideThrowBallIndicator()
    self._throwBallShow = false
    self._throwBallShowParameter.isVaild = false
    if Utils.IsNull(self._throwBallGo) then
        return
    end
    self._throwBallGo:SetVisible(false)
end

---施放技能表现
---@param self SESkillManager
---@param skillId number
---@param stage number
---@param attacker SEActor
---@param attackerPos CS.UnityEngine.Vector3
---@param target SEActor
---@param targetPos CS.UnityEngine.Vector3
---@param targets table
---@param skill table
---@param msg wrpc.PushBattleCastSkillMessageRequest
---@param callback fun()|nil
---@return void|fun()
function SESkillManager:CastSkillPerform(
        skillId, stage, attacker, attackerPos, target, targetPos, targets, skill, msg, callback, needCancelHandle)
    local instance = require("SkillClientManager").GetInstance()
    if instance then
        if (not stage) then
            stage = wds.enum.SkillStageType.SkillStageTypeDefault
        end
        SELogger.LogLow("CastSkillAoe id: %s, stage: %s, attacker: %s, target: %s, attackerPos: %s, targetPos: %s",
            skillId, stage, attacker, target, attackerPos, targetPos)
        local param = require("SkillClientParam").new(skillId)
        param:SetTargetClass(require("SESkillClientTarget"))
        param:SetStage((require "SkillClientEnum").StageProtocol[stage])
        param:SetAttacker(attacker, attackerPos)
        param:SetTarget(target, targetPos)
        param:SetDataTable(skill)
        param:SetServerData(msg)
        param:SetMapInfo(self:GetEnvironment():GetMapInfo())
        if (targets) then
            for _, v in pairs(targets) do
                param:AddOtherTarget(v)
            end
        end
        return instance:Play(param, callback, needCancelHandle)
    else
        if callback then callback() end
    end
end

---推送技能打断
---@param self SESkillManager
---@param msg wrpc.PushBattleSkillStopMessageRequest
---@return void
function SESkillManager:PushBattleSkillStop(msg)
    local instance = require("SkillClientManager").GetInstance()
    if instance then
        instance:Cancel(msg)
    end
end

---@param seUnit SEUnit
function SESkillManager:ManualLocalCancelSkillToAttackerSelf(seUnit)
    local instance = require("SkillClientManager").GetInstance()
    if instance then
        instance:CancelByAttackerToSelf(seUnit)
    end
end

---@param seUnit SEUnit
function SESkillManager:ManualLocalCancelSkillToTarget(seUnit)
    local instance = require("SkillClientManager").GetInstance()
    if instance then
        instance:CancelByTarget(seUnit)
    end
end

---获取预警圈偏移
---@param self SESkillManager
---@return CS.UnityEngine.Vector3
function SESkillManager:GetAlertOffset()
    return SKILL_ALERT_RANGE_OFFSET
end

---@param self SESkillManager
---@param delta number
---@return void
function SESkillManager:Update(delta)
    self:SkillUsingUpdate()
    self:ThrowBallUpdate()
end

---@param self SESkillManager
---@param entity table
---@param changedData table
function SESkillManager:OnPlayerCardChange(entity, changedData)
	local scenePlayer = self:GetEnvironment():GetWdsManager():GetScenePlayer()
	if (not scenePlayer) then return end

    ---@type table<number, table<number, SECardRuntimeData>>
    self._cardList = {}

    local playerCardInfos = scenePlayer.ScenePlayerCard.Infos
    for presetIndex, value in pairs(playerCardInfos) do
        ---@type table<number, SECardRuntimeData>
        local cardList = {}
        self._cardList[presetIndex] = cardList
        ---@type table<number, wds.FightCardInfo>
        local petCardInfos = {}
        local cardInfos = value.CardInfos or {}
	    local petCardIds = value.PetCardIds or {}
        for i = 1, #petCardIds do
            petCardInfos[i] = cardInfos[petCardIds[i]]
        end
        for i = 1, #petCardInfos do
            if (petCardInfos[i] and petCardInfos[i].CardCfgId) then
                local fightCardInfo = petCardInfos[i]
                local cardConfigCell = ConfigRefer.Card:Find(fightCardInfo.CardCfgId)
                if (cardConfigCell) then
                    local cdTime = cardConfigCell:PetCardCD()
                    if (not cdTime or cdTime <= 0) then
                        cdTime = 10000
                    end

                    ---@type SECardRuntimeData
                    local runtimeCardData = {}
                    runtimeCardData.used = fightCardInfo.Used
                    runtimeCardData.cdEndMs = fightCardInfo.CanUseTime
                    runtimeCardData.cdMs = cdTime
                    runtimeCardData.cardConfigCell = cardConfigCell
                    runtimeCardData.cardServerId = fightCardInfo.ID
                    runtimeCardData.fightCardInfo = fightCardInfo

                    cardList[i] = runtimeCardData
                end
            end
        end
    end

    local ui = self:GetEnvironment():GetUiBattlePanel()
    if (ui) then
        ui:RefreshCardList(true)
        ui:RefreshCardAvailable()
    end
end

--- 获取卡牌列表
---@param self SESkillManager
---@return table<number, SECardRuntimeData>
function SESkillManager:GetCardList()
    local currentFocusIndex = self:GetEnvironment():GetCurrentFocusPresetIndex() or self:GetEnvironment():GetFallbackPresetIndex()
    if currentFocusIndex then
        return self._cardList[currentFocusIndex] or {}
    end
    for _, value in pairs(self._cardList) do
        return value
    end
    return {}
end

---获取卡牌最大数量
---@param self SESkillManager
---@return number
function SESkillManager:GetCardMaxCount()
	--- 7Day+ 版本改动
	return 3
    --return CARD_MAX_COUNT
end

function SESkillManager:CastSkillResponse(isSucceed, resp)
    if (not isSucceed) then
        self:GetEnvironment():GetUiBattlePanel():CancelUsingSkill()
    end
end

function SESkillManager:GetSkillPreviewModelRoot()
	if (Utils.IsNull(self._skillPreviewModelRoot)) then
		self._skillPreviewModelRoot = CS.UnityEngine.GameObject("_skill_preview")
		self._skillPreviewModelRoot.transform:SetParent(self:GetEnvironment():GetMapRoot())
        self._skillPreviewModelRoot.transform.localScale = CS.UnityEngine.Vector3.one
	end
	return self._skillPreviewModelRoot
end

function SESkillManager:TickSceneDarkTargetTween()
    if not self._sceneDarkTarget or not self._sceneDarkTargetTime then return end
    local nowTime = g_Game.ServerTime:GetServerTimestampInSecondsNoFloor()
    local leftTime = self._sceneDarkTargetTime - nowTime
    if leftTime < 0 then
        self._sceneDarkTargetTime = nil
        leftTime = 0
    end
    local progress = math.inverseLerp(self._sceneDarkTimeDef, 0, leftTime)
    local targetValue = math.lerp(1-self._sceneDarkTarget, self._sceneDarkTarget, progress) * 0.5
    CS.UnityEngine.Shader.SetGlobalFloat(CS.RenderExtension.ShaderConst.GlobalSceneDarken, targetValue)
end

function SESkillManager:ThrowBallUpdate()
    self:TickSceneDarkTargetTween()
    local seEnv = self:GetEnvironment()
    local teamMgr = seEnv:GetTeamManager()
    ---@type SETeam
    local team = teamMgr:GetOperatingTeam()
    local hero = team and team:GetRightOfBallControlHero()
    local joyStickModule = ModuleRefer.SEJoystickControlModule
    local currentJoyStickStatus, isPressDown = joyStickModule:IsJoystickThrowIndicatorShow()
    if self._allowThrowBallTimeSlow then
        if self._isInThrowBallTimeOperateUnit and (not isPressDown or not hero) then
            self._sceneDarkTarget = 0
            self._sceneDarkTargetTime = g_Game.ServerTime:GetServerTimestampInSecondsNoFloor() + self._sceneDarkTimeDef
            self._isInThrowBallTimeOperateUnit:SetGlobalFocusSwitch(false)
            seEnv:SetThrowBallStart(false, self._isInThrowBallTimeOperateUnit:GetID(), 1)
            self._isInThrowBallTimeOperateUnit = nil
            if self._isInThrowBallTimeOperateUnitTeam then
                self._isInThrowBallTimeOperateUnitTeam:RecoverTick()
            end
            self._isInThrowBallTimeOperateUnitTeam = nil
        elseif not self._isInThrowBallTimeOperateUnit and isPressDown and hero then
            self._sceneDarkTarget = 1
            self._sceneDarkTargetTime = g_Game.ServerTime:GetServerTimestampInSecondsNoFloor() + self._sceneDarkTimeDef
            self._isInThrowBallTimeOperateUnit = hero
            self._isInThrowBallTimeOperateUnit:SetGlobalFocusSwitch(true)
            self._isInThrowBallTimeOperateUnitTeam = team
            self._isInThrowBallTimeOperateUnitTeam:PauseTickForCatchPetBall()
            seEnv:SetThrowBallStart(true, hero:GetID(), self._throwBallTimeSlowSpeed)
        end
    end
    local needCastAimingSkill = false
    if self._lastThrowBallStatus ~= currentJoyStickStatus then
        self._lastThrowBallStatus = currentJoyStickStatus
        if not currentJoyStickStatus then
            local _, _, _, isCancel, _  = joyStickModule:GetThrowBallParam()
            self:HideThrowBallIndicator()
            if not isCancel and not isPressDown then
                self:CheckThrowCanHitAndSendCmd(joyStickModule, hero)
                self:ThrowBallAimingSkillCancel(false)
            else
                self:ThrowBallAimingSkillCancel(true)
            end
            return
        else
            needCastAimingSkill = true
        end
    elseif not currentJoyStickStatus then
        return
    elseif hero and self._lastThrowBallAimSkillHandle and self._lastThrowBallAimSkillHandle.unit ~= hero then
        self:ThrowBallAimingSkillCancel(true)
        needCastAimingSkill = true
    end
    local result, heroPos, dir, _, pocketBallId, ballHidPos, _, hitUnit = self:CastRayToCatchUnit(joyStickModule, hero)
    if not result then return end
    local _, _, _, isCancel,_  = joyStickModule:GetThrowBallParam()
    local color = isCancel and CS.UnityEngine.Color.red or CS.UnityEngine.Color.cyan
    hero:GetActor():SetForward(dir)
    local clientScale = require("SESceneRoot").GetClientScale()
    local indicatorLength = (ballHidPos and heroPos) and ((ballHidPos - heroPos).magnitude / clientScale) or ConfigRefer.ConstSe:SeThrowBallMaxDistance()
    self:ShowThrowBallIndicator(hero, dir, indicatorLength, color)
    if needCastAimingSkill then
        self:ThrowBallAimingSkill(hero, pocketBallId)
    end
    if hitUnit ~= self._lastThrowBallTargetUnit then
        self:HideLastThrowBallTargetUnitHud()
        if hitUnit then
            self._lastThrowBallTargetUnit = hitUnit
            local hud = hitUnit:GetPetCatchHud()
            local show = hitUnit:IsInCanCatchState()
            if hud then
                hud:ResetToNormal()
                hud:ShowAsCatchTarget(ConfigRefer.PetPocketBall:Find(pocketBallId), show)
                self._lastThrowBallTargetUnitHudSet = true
            end
            local render = hitUnit:GetRenderer()
            if render then
                render:SetSelected(show)
            end
        end
    elseif self._lastThrowBallTargetUnit and not self._lastThrowBallTargetUnitHudSet then
        local hud = self._lastThrowBallTargetUnit:GetPetCatchHud()
        local show = self._lastThrowBallTargetUnit:IsInCanCatchState()
        if hud then
            hud:ResetToNormal()
            hud:ShowAsCatchTarget(ConfigRefer.PetPocketBall:Find(pocketBallId), show)
            self._lastThrowBallTargetUnitHudSet = true
        end
    end
end

SESkillManager.CheckLayerMask = CS.UnityEngine.LayerMask.GetMask("CityStatic", "City", "SEFloor", "Character", "Selected")

if UNITY_EDITOR then
    ---@class DebugBox
    ---@field origin CS.UnityEngine.Vector3
    ---@field frontTopLeft CS.UnityEngine.Vector3
    ---@field frontTopRight CS.UnityEngine.Vector3
    ---@field frontBottomLeft CS.UnityEngine.Vector3
    ---@field frontBottomRight CS.UnityEngine.Vector3
    ---@field backTopLeft CS.UnityEngine.Vector3
    ---@field backTopRight CS.UnityEngine.Vector3
    ---@field backBottomLeft CS.UnityEngine.Vector3
    ---@field backBottomRight CS.UnityEngine.Vector3
    
    function SESkillManager.MakeBox(origin, halfExtents)
        
        local localFrontTopLeft = CS.UnityEngine.Vector3(-halfExtents.x, halfExtents.y, -halfExtents.z)
        local localFrontTopRight = CS.UnityEngine.Vector3(halfExtents.x, halfExtents.y, -halfExtents.z)
        local localFrontBottomLeft = CS.UnityEngine.Vector3(-halfExtents.x, -halfExtents.y, -halfExtents.z)
        local localFrontBottomRight = CS.UnityEngine.Vector3(halfExtents.x, -halfExtents.y, -halfExtents.z)
        ---@type DebugBox
        local ret = {}
        ret.origin = origin
        ret.frontTopLeft = origin + localFrontTopLeft
        ret.frontTopRight = origin + localFrontTopRight
        ret.frontBottomLeft = origin + localFrontBottomLeft
        ret.frontBottomRight = origin + localFrontBottomRight
        ret.backTopLeft = origin - localFrontBottomRight
        ret.backTopRight = origin - localFrontBottomLeft
        ret.backBottomLeft = origin - localFrontTopRight
        ret.backBottomRight = origin - localFrontTopLeft
        return ret
    end
    function SESkillManager.DrawBoxCast(origin, halfExtents, direction, maskDistance, color)
        local bottomBox = SESkillManager.MakeBox(origin, halfExtents)
        local topBox  = SESkillManager.MakeBox(origin + direction * maskDistance, halfExtents)
        CS.UnityEngine.Debug.DrawLine(bottomBox.backBottomLeft, topBox.backBottomLeft, color)
        CS.UnityEngine.Debug.DrawLine(bottomBox.backBottomRight, topBox.backBottomRight, color)
        CS.UnityEngine.Debug.DrawLine(bottomBox.backTopLeft, topBox.backTopLeft, color)
        CS.UnityEngine.Debug.DrawLine(bottomBox.backTopRight, topBox.backTopRight, color)
        CS.UnityEngine.Debug.DrawLine(bottomBox.frontTopLeft, topBox.frontTopLeft, color)
        CS.UnityEngine.Debug.DrawLine(bottomBox.frontTopRight, topBox.frontTopRight, color)
        CS.UnityEngine.Debug.DrawLine(bottomBox.frontBottomLeft, topBox.frontBottomLeft, color)
        CS.UnityEngine.Debug.DrawLine(bottomBox.frontBottomRight, topBox.frontBottomRight, color)
    end
end

---@param joyStickModule SEJoystickControlModule
---@param hero SEUnit
---@return boolean, CS.UnityEngine.Vector3, CS.UnityEngine.Vector3, number, number, CS.UnityEngine.Vector3, number, SEUnit
function SESkillManager:CastRayToCatchUnit(joyStickModule, hero)
    if not hero then return false end
    local mainCamera = self:GetEnvironment():GetCamera()
    local cameraRotation = mainCamera.transform.rotation.eulerAngles
    local x, y, _, _, pocketBallId  = joyStickModule:GetThrowBallParam()
    if not pocketBallId or pocketBallId <= 0 then return false end
    local dir = (CS.UnityEngine.Quaternion.Euler(0, cameraRotation.y, 0) * CS.UnityEngine.Vector3(x,0,y).normalized).normalized
    local seEnv = self:GetEnvironment()
    local position = hero:GetActor():GetPosition()
    if not position then return false end
    local clientScale = SESceneRoot.GetClientScale()
    local distance =  ConfigRefer.ConstSe:SeThrowBallMaxDistance() * clientScale
    local origin = position + CS.UnityEngine.Vector3(0, 0.5 * clientScale, 0)
    local halfExtents = CS.UnityEngine.Vector3(0.5 * SKILL_THROW_BALL_INDICATOR_WIDTH, 0.5 * SKILL_THROW_BALL_INDICATOR_WIDTH, 0.1) * SESceneRoot.GetClientScale()
    if UNITY_EDITOR then
        SESkillManager.DrawBoxCast(origin, halfExtents, dir, distance, CS.UnityEngine.Color.red)
    end
    local result, retArray, hitPointArray = physics.boxcastNonAlloc(origin,halfExtents, dir, CS.UnityEngine.Quaternion.identity ,distance, SESkillManager.CheckLayerMask)
    if not result then return false end
    local hitUnitResult
    local hitTargetId
    local ballHitPos
    for i = 1, result do
        local find, entityId, goPosition = SESkillManager.GetHitTransSEEntity(retArray[i])
        if find then
            local hitUnit = seEnv:GetUnitManager():GetUnit(entityId)
            if not hitUnit then
                hitUnit = seEnv:GetUnitManager():GetDeadUnit(entityId)
            end
            if not hitUnit then
                goto continue
            end
            if self:CheckIsNotBlockCatch(hitUnit) then
                goto continue
            end
            if self:CheckIsCanCaptureByConfig(hitUnit) then
                hitTargetId = entityId
                ballHitPos = goPosition
                hitUnitResult = hitUnit--hitUnit:IsInCanCatchState() and hitUnit or nil
            end
        else
            ballHitPos = hitPointArray and hitPointArray[i] or goPosition
        end
        break
        ::continue::
    end
    return true, position, dir, distance, pocketBallId, ballHitPos, hitTargetId, hitUnitResult
end

---@param joyStickModule SEJoystickControlModule
function SESkillManager:CheckThrowCanHitAndSendCmd(joyStickModule, hero)
    local seEnv = self:GetEnvironment()
    local result, position, dir, distance, pocketBallId, ballHitPos, hitTargetId, hitUnit = self:CastRayToCatchUnit(joyStickModule, hero)
    if not result then return end
    --没打到任何会挡住球的东西， 落点是最远位置
    if not ballHitPos then
        ballHitPos = position + dir * distance
    elseif UNITY_EDITOR then
        CS.UnityEngine.Debug.DrawLine(position, ballHitPos, CS.UnityEngine.Color.green, 5)
    end
    local serverTargetCoord = seEnv:ClientPos2Server(ballHitPos)
    seEnv:SendCapaturePetCmd(hero:GetID(), hitTargetId, pocketBallId, serverTargetCoord, function(cmd, isSuccess, rsp) 
        if not isSuccess then return end
        if not hitUnit then return end
        local catchHud = hitUnit:GetPetCatchHud()
        if not catchHud then return end
        if rsp.Result.Type == wrpc.CatchPetBallResultType.CatchPetBallResultTypeSuccess then
            catchHud:PlaySuccess(ConfigRefer.PetPocketBall:Find(pocketBallId))
        elseif rsp.Result.Type == wrpc.CatchPetBallResultType.CatchPetBallResultTypeFail then
            catchHud:PlayFail(ConfigRefer.PetPocketBall:Find(pocketBallId), rsp.Result.PendingNum)
        end
    end)
end

---@param unit SEUnit
function SESkillManager:CheckIsNotBlockCatch(unit)
    if not unit then return false end
    local unitType = unit:GetType()
    if unitType == SEUnitType.Monster then
        local entityData = unit:GetEntity()
        -- 正在被捕捉的就可以穿过了
        if entityData and entityData.MapStates.StateWrapper3.Catching then
            return true
        end
    end
    if unitType ~= SEUnitType.Player and unitType ~= SEUnitType.Hero and unitType ~= SEUnitType.Pet then return false end
    return true
end

---@param unit SEUnit
function SESkillManager:CheckIsCanCaptureByConfig(unit)
    if not unit then return false end
    local config = unit:GetConfig()
    if not config or not config.CanCatch then return false end
    return config:CanCatch()
end

---@param hitGo CS.UnityEngine.GameObject
---@return boolean, number
function SESkillManager.GetHitTransSEEntity(hitGo)
    if Utils.IsNull(hitGo) then return false, nil, nil end
    local queryType = typeof(CS.SEUnitDataComp)
    ---@type CS.SEUnitDataComp
    local dataComp = hitGo:GetComponent(queryType)
    if Utils.IsNotNull(dataComp) then return true, dataComp.ID, hitGo.transform.position end
    dataComp = hitGo:GetComponentInParent(queryType)
    if Utils.IsNotNull(dataComp) then return true, dataComp.ID, hitGo.transform.position end
    return false, nil, hitGo.transform.position
end

function SESkillManager:ThrowBallAimingSkill(heroUnit, petPocketBallId)
    self:ThrowBallAimingSkillCancel()
    if not heroUnit or not petPocketBallId or petPocketBallId <= 0 then return end
    local ballConfig = ConfigRefer.PetPocketBall:Find(petPocketBallId)
    if not ballConfig then return end
    local skillId = ballConfig:AimingSkill()
    if skillId <= 0 then return end
    local seEnv = self:GetEnvironment()
    local skillConfig = seEnv:GetWdsManager():GetSkillConfig(skillId)
    if not skillConfig then return end
    local cancelSkillId = ballConfig:AimingCancelSkill()
    local target = heroUnit:GetActor()
    local targetPos = heroUnit:GetActor():GetPosition()
    local cancelHandle = self:CastSkillPerform(skillConfig:Asset(), wds.enum.SkillStageType.SkillStageTypeDefault, target,targetPos , target, targetPos, nil, skillConfig, nil, nil, true)
    self._lastThrowBallAimSkillHandle = {}
    self._lastThrowBallAimSkillHandle.unit = heroUnit
    self._lastThrowBallAimSkillHandle.cancelFunc = function(playCancelSkill)
        if cancelHandle then cancelHandle() end
        if not cancelSkillId or cancelSkillId <= 0 then return end
        if not playCancelSkill then return end
        local wdsMgr = seEnv:GetWdsManager()
        if not wdsMgr then return end
        local cancelSkillConfig = wdsMgr:GetSkillConfig(cancelSkillId)
        if not cancelSkillConfig then return end
        self:CastSkillPerform(cancelSkillConfig:Asset(), wds.enum.SkillStageType.SkillStageTypeDefault, target, targetPos , target, targetPos, nil, cancelSkillConfig, nil, nil, false)
    end
end

function SESkillManager:ThrowBallAimingSkillCancel(playCancelSkill)
    self:HideLastThrowBallTargetUnitHud()
    if self._lastThrowBallAimSkillHandle then
        local v = self._lastThrowBallAimSkillHandle.cancelFunc
        self._lastThrowBallAimSkillHandle = nil
        v(playCancelSkill)
    end
end

function SESkillManager:HideLastThrowBallTargetUnitHud()
    if self._lastThrowBallTargetUnit then
        local hud = self._lastThrowBallTargetUnit:GetPetCatchHud()
        if hud then
            hud:ResetToNormal()
            hud:ShowAsCatchTarget(nil)
        end
        local render = self._lastThrowBallTargetUnit:GetRenderer()
        if render then
            render:SetSelected(false)
        end
        self._lastThrowBallTargetUnit = nil
        self._lastThrowBallTargetUnitHudSet = false
    end
end

return SESkillManager