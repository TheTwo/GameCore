---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by shoufeng.zhang.
--- DateTime: 2022/1/12 11:02
---
local Delegate = require("Delegate")
local ConfigRefer = require("ConfigRefer")
local ModuleRefer = require('ModuleRefer')
local I18N = require('I18N')
local DBEntityType = require('DBEntityType')
local TaskOperationParameter = require("PlayerTaskOperationParameter")
local ChapterRewardParameter = require("GetChapterRewardParameter")
local GroupRewardParameter = require('GetChapterGroupRewardParameter')
local TouchMenuBasicInfoDatum = require("TouchMenuBasicInfoDatum")
local TouchMenuCellNpcTaskDatum = require("TouchMenuCellNpcTaskDatum")
local TouchMenuHelper = require("TouchMenuHelper")
local TouchMenuUIMediator = require("TouchMenuUIMediator")
local QuestStateConstant = require('QuestStateConstant')
local Utils = require('Utils')
local OnChangeHelper = require('OnChangeHelper')
local TimerUtility = require('TimerUtility')
local TaskRewardType = require('TaskRewardType')
local TaskCondType = require('TaskCondType')
local DBEntityPath = require('DBEntityPath')
local UIMediatorNames = require('UIMediatorNames')
local EventConst = require('EventConst')
local TaskType = require('TaskType')
local NpcServiceObjectType = require("NpcServiceObjectType")
---缓存任务状态，用于打开窗口时检测状态变化
---@class CachedChapterTaskItem
---@field unit wds.TaskUnit
---@field config TaskConfigCell
---@field state wds.TaskState
---@field inChain boolean
---@field preId number @前置任务Id
---@field nextId number @后续任务Id
---@field finishBranch number @任务完成的分支

---@class Chapter_task_cache
---@field isNpc boolean
---@field cityElementNpcId number|nil
---@field citizenId number|nil
---@field taskId number
---@field newChapterId number
---@field dialogueGroupId number
---@field chatNpcId number
---@field priority number
---@field isAutoAccept boolean
---@field unlockTask number

---@class QuestModule_Chapter
---@field stateCtrl PageStateCtrl
---@field parentModule QuestModule
---@field taskItemCache table<number,CachedChapterTaskItem> @key is TaskConfigCell:ID()
local QuestModule_Chapter = class('QuestModule_Chapter')


function QuestModule_Chapter:OnRegister(parent)
    self.parentModule = parent
    self.curChapter = 0
    self.taskItemCache = {}
    ---@type table<number, Chapter_task_cache>
    self.npc2TasksCache = {}
    ---@type table<number, Chapter_task_cache>
    self.citizen2TasksCache = {}
    self.dialogueGruopId2Ids = {}
    self.newChapterMainDialogueCache = {}
    self.newChapterDialogueCache = {}
    self.chapterChatNpcCache = {}
    self:UpdateQuestCache(true)
    g_Game.ServiceManager:AddResponseCallback(TaskOperationParameter.GetMsgId(),Delegate.GetOrCreate(self, self.OnChapterQuestClaimCallback))
    g_Game.ServiceManager:AddResponseCallback(ChapterRewardParameter.GetMsgId(),Delegate.GetOrCreate(self, self.OnChapterClaimCallback))
    g_Game.ServiceManager:AddResponseCallback(GroupRewardParameter.GetMsgId(),Delegate.GetOrCreate(self,self.OnChapterGroupRewardCallback))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper.Chapter.MsgPath,Delegate.GetOrCreate(self,self.OnChapterDBChanged))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper2.NpcServices.MsgPath, Delegate.GetOrCreate(self, self.OnNpcChapterChanged))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.CastleBrief.Castle.CastleCitizens.MsgPath, Delegate.GetOrCreate(self, self.OnCitizenDataChanged))
    --g_Game.ServiceManager:AddResponseCallback(
    --        ChapterQuestShowQuestParameter.GetEventName(),
    --        Delegate.GetOrCreate(self, self.OnChapterQuestUnlocked)
    --)
    self._lastUpdateQuestCacheFrame = nil
end

function QuestModule_Chapter:OnRemove()
    g_Game.ServiceManager:RemoveResponseCallback(TaskOperationParameter.GetMsgId(),Delegate.GetOrCreate(self, self.OnChapterQuestClaimCallback))
    g_Game.ServiceManager:RemoveResponseCallback(ChapterRewardParameter.GetMsgId(),Delegate.GetOrCreate(self, self.OnChapterClaimCallback))
    g_Game.ServiceManager:RemoveResponseCallback(GroupRewardParameter.GetMsgId(),Delegate.GetOrCreate(self,self.OnChapterGroupRewardCallback))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper.Chapter.MsgPath,Delegate.GetOrCreate(self,self.OnChapterDBChanged))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper2.NpcServices.MsgPath, Delegate.GetOrCreate(self, self.OnNpcChapterChanged))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.CastleBrief.Castle.CastleCitizens.MsgPath, Delegate.GetOrCreate(self, self.OnCitizenDataChanged))
    --g_Game.ServiceManager:RemoveResponseCallback(
    --        ChapterQuestShowQuestParameter.GetEventName(),
    --        Delegate.GetOrCreate(self, self.OnChapterQuestUnlocked)
    --)
end

---GetQuestRewards
---@param configCell TaskConfigCell
---@param branch number @Branch index (0~n)
---@return ItemGroupInfo[] Items,Nums,Weights
function QuestModule_Chapter:GetQuestRewards(configCell,branch,index)
    if not configCell then  return nil end
    branch = branch or 0
    branch = math.min(branch+1, configCell:FinishBranchLength())
    if branch < 1 then
        return nil
    end
    local finish = configCell:FinishBranch(branch)
    if not finish then
        return nil
    end
    index = index or 0
    index = math.min(index+1,finish:BranchRewardLength())
    if index < 1 then
        return nil
    end
    local reward = finish:BranchReward(index)
    if not reward or reward:Typ() ~= TaskRewardType.RewardItem then
        return nil
    end
    return self.parentModule.GetItemGroupInfoByStringId(reward:Param())
end

--拿到排序最高的任务
---@return wds.TaskUnit
function QuestModule_Chapter:GetFirstTask()
    local questCache = self:GetChapterQuests();

    local minPriority = math.maxinteger
    local ret = nil
    for key, value in pairs(questCache) do
        local p = QuestModule_Chapter.CalcQuestPriority(value)
        if p < minPriority then
            minPriority = p
            ret = value
        end
    end

    return ret.unit
end

---@return wds.TaskUnit,wds.TaskUnit
function QuestModule_Chapter:GetFirstTwoChapterQuest()
    local questCache = self:GetChapterQuests();
    local minPriority = math.maxinteger
    local minMainPriority = math.maxinteger
    local mainTask = nil
    local subTask = nil
    local devTasks = {}
    for _, value in pairs(questCache) do
        if value.unit.State < wds.TaskState.TaskStateFinished and value.unit.State > wds.TaskState.TaskStateCanReceive then
            if value.config:Property():TaskType() == TaskType.MainChapter then
                local m = QuestModule_Chapter.CalcQuestPriority(value)
                if m < minMainPriority then
                    minMainPriority = m
                    mainTask = value
                end
            else
                local p = QuestModule_Chapter.CalcQuestPriority(value)
                if p < minPriority then
                    minPriority = p
                    subTask = value
                end
            end
        end
    end

    for _, taskId in ipairs(ModuleRefer.QuestModule.growUpQuests) do
        local config = ConfigRefer.Task:Find(taskId)
        local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
        if taskState < wds.TaskState.TaskStateFinished and taskState > wds.TaskState.TaskStateCanReceive then
            local player = ModuleRefer.PlayerModule:GetPlayer()
            local taskDB = player.PlayerWrapper.Task
            local unit = taskDB.Processing[taskId]
            if unit then
                local value = {unit = unit, config = config}
                local t = QuestModule_Chapter.CalcQuestPriority(value)
                devTasks[#devTasks + 1] = {task = value, priority = t}
            end
        end
	end

    local sortFunc = function(a, b)
        if a.priority == b.priority then
            return a.task.unit.TID < b.task.unit.TID
        end
        return a.priority < b.priority
    end
    table.sort(devTasks, sortFunc)
    if subTask and subTask.unit then
        return mainTask and mainTask.unit or nil , subTask and subTask.unit or nil, devTasks[1] and devTasks[1].task.unit or nil
    else
        return mainTask and mainTask.unit or nil , devTasks[1] and devTasks[1].task.unit or nil, devTasks[2] and devTasks[2].task.unit or nil
    end
end


---当前章节用户数据
---@return wds.Chapter
function QuestModule_Chapter:CurrentChapterDBData()
    return ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper.Chapter
end

---@return ChapterGroupConfigCell
function QuestModule_Chapter:CurrentChapterGroup()
    local curChapter = self:CurrentChapterConfig()
    if not curChapter then return end
    return ConfigRefer.ChapterGroup:Find(curChapter:Group())
end

---当前章节数据
---@return ChapterConfigCell
function QuestModule_Chapter:CurrentChapterConfig()
    -- ---@type wds.Chapter
    -- local chapter = self:CurrentChapterDBData();
    -- if not chapter then return nil end
    -- local chapterId = chapter.ChapterID
    -- if not self._minChapterId then
    --     self._minChapterId = ConfigRefer.Chapter.iids[1]
    -- end
    -- if chapterId < self._minChapterId then
    --     chapterId = self._minChapterId
    -- end
    -- if self.curChapter ~= chapterId then
    --     self.lastChapterId = self.curChapter
    --     self.curChapter = chapterId
    -- end
    if not self.curChapter or self.curChapter < 1 then
        self:OnChapterDBChanged()
    end
    return ConfigRefer.Chapter:Find(self.curChapter)
end

function QuestModule_Chapter:GetEndChapterInGroup(groupId)
    ---@type table<number,ChapterConfigCell>
    local chapters = {}
    for key, value in ConfigRefer.Chapter:ipairs() do
        if value:Group() == groupId then
            chapters[value:Id()] = value
        end
    end

    local endChapter = nil
    for key, value in pairs(chapters) do
        local nextId = value:NextChapter()
        if not nextId or nextId < 1 or chapters[nextId] == nil then
            endChapter = value
            break
        end
    end

    return endChapter
end

function QuestModule_Chapter:LastChapterConfig()
    if self.lastChapterId and self.lastChapterId > 0 then
        return ConfigRefer.Chapter:Find(self.lastChapterId)
    end
end

--当前章节序号
function QuestModule_Chapter:CurrentChapterId()
    ---@type ChapterConfigCell
    local curGroupCell = self:CurrentChapterConfig()
    return (curGroupCell ~= nil) and curGroupCell:Id() or 1
end

-- function QuestModule_Chapter:IsCurrentChapterSpecial()
--     local chapter = self:CurrentChapterConfig()
--     if chapter then
--         return chapter:IsSpecial()
--     else
--         return false
--     end
-- end

function QuestModule_Chapter:IsAllChapterFinished()
    local chapter = self:CurrentChapterDBData();
    if not chapter then return false end

    local chapterCfg = ConfigRefer.Chapter:Find(chapter.ChapterID)
    if not chapterCfg then return false end

    if chapter.GetReward and chapterCfg:NextChapter() < 1 and not self:HasChapterGroupReward() then
        return true
    end
    return false
end

function QuestModule_Chapter:IsCurrentChapterIsFirstChapter()
    ---@type ChapterConfigCell
    local curChapter = self:CurrentChapterConfig()
    if not curChapter then return true end
    local curId = curChapter:Id()
    local ret = true
    for key, value in ConfigRefer.Chapter:ipairs() do
        if value:NextChapter() == curId then
            ret = false
            break
        end
    end
    return ret
end

local ChapterGroupUnlockWinKey = 'CHAPTER_UNLOCK_WIN_SHOWED'
---当前章节组是不是已经解锁(客户端播放过解锁效果)
---@return boolean
function QuestModule_Chapter:IsCurrentChapterGroupUnlockAnimPlayed()
    ---@type ChapterConfigCell
    local chapter = self:CurrentChapterConfig()
    if not chapter then return false end
    local gid = chapter:Group()
    if gid < 1 then
        return false
    end

    local lastGid = g_Game.PlayerPrefsEx:GetIntByUid(ChapterGroupUnlockWinKey,0)
    return lastGid == gid
end
---当前章节组解锁
function QuestModule_Chapter:OnChapterGroupUnlockAnimPlayed()
    local chapter = self:CurrentChapterConfig()
    if not chapter then return end
    local gid = chapter:Group()
    if gid > 0 then
        g_Game.PlayerPrefsEx:SetIntByUid(ChapterGroupUnlockWinKey,gid)
    end
end

function QuestModule_Chapter:PlayCurrentGroupStory(callback)
    local chapter = self:CurrentChapterConfig()
    if not chapter then
        if callback then callback() end
        return
    end
    local gid = chapter:Group()
    if gid < 1 then
        if callback then callback() end
        return
    end
    local groupCfg = ConfigRefer.ChapterGroup:Find(gid)
    if not groupCfg then
        if callback then callback() end
        return
    end
    local storyId = groupCfg:StartStory()
    if storyId and storyId > 0 then
        ModuleRefer.StoryModule:StoryStart(storyId,function(id,result)
            --if id ~= storyId then return end
            if callback then callback() end
        end)
        return
    end
    if callback then callback() end
end

function QuestModule_Chapter:PlayStoryOnQuestFinish(iQuest)
    local item = self:GetQuestCacheItem(iQuest)
    if not item then
        return false
    end
    local questConfig = item.config
    if not questConfig then
        return false
    end

    local branchLength = questConfig:FinishBranchLength()
    if item.finishBranch > branchLength - 1 then
        return false
    end

    local branchCfg = questConfig:FinishBranch(item.finishBranch + 1)
    if not branchCfg then
        return false
    end

    local rewardLength = branchCfg:BranchRewardLength()
    for i = 1, rewardLength do
        local reward = branchCfg:BranchReward(i)
        if reward:Typ() == TaskRewardType.RewardStoryTask then
            local storyID = tonumber(reward:Param())
            if storyID and storyID > 0 then
                g_Game.UIManager:CloseByName(UIMediatorNames.QuestUIMediator)
                ModuleRefer.StoryModule:StoryStart(storyID ,function(id,result)
                    if id ~= storyID then return end
                    if result == require('StartStoryCallbackResult').Success then
                        ModuleRefer.GuideModule:CallGuide(require('GuideConst').CallID.ChapterQuestStoryFinish)
                    end
                end)
                return true
            end
        end
    end
    return false
end

function QuestModule_Chapter:StartSequence_NewChapterUnlock()
    if not self.finStoryTask then
        self.finStoryTask = require('QueuedTask').new()
    elseif self.finStoryTask:IsExecuting() then
        self.finStoryTask:Release()
    end

    local storyEnd = false
    self.finStoryTask:DoAction( function()
        g_Game.UIManager:SetInputEnabled(false)
        g_Game.UIManager:CloseByName(UIMediatorNames.QuestUIMediator)
        g_Game.UIManager:SetInputEnabled(true)
        self:PlayCurrentGroupStory(function()
            g_Game.UIManager:SetInputEnabled(false)
            storyEnd = true
        end)
    end):WaitTrue(function()
        return storyEnd
    end):DoAction(function()
        g_Game.UIManager:SetInputEnabled(true)
        ModuleRefer.GuideModule:CallGuide(require('GuideConst').CallID.ChapterQuestStoryFinish)
    end):Start()
end

---GetChpaterRewardConfig
---@param chapterConfig ChapterConfigCell
---@return ItemGroupInfo[]
function QuestModule_Chapter:GetChpaterRewardConfig(chapterConfig)
    if not chapterConfig then  return nil end
    return self.parentModule.GetItemGroupInfoById(chapterConfig:Reward())
end

---GetChpaterRewardList
---@return ItemGroupInfo[]
function QuestModule_Chapter:GetChpaterRewardList()
    local chapterConfig = self:CurrentChapterConfig();
    return self:GetChpaterRewardConfig(chapterConfig);
end

---CalcQuestPriority
---@param taskItem CachedChapterTaskItem
function QuestModule_Chapter.CalcQuestPriority(taskItem)
    local taskUnit = taskItem.unit
    local taskConfig = taskItem.config
    --local taskState = taskItem.state
    -- if taskConfig == nil then
    --     taskConfig = QuestModule_Chapter.FindTaskConfig(taskUnit.TID)
    -- end
    if taskConfig == nil then
        return 999999
    end

    local state = taskUnit.State -- (taskState ~= nil) and taskState or taskUnit.State

    local flag = state >= wds.TaskState.TaskStateCanFinish
    local claimed = state == wds.TaskState.TaskStateFinished
    local flag2 = not table.IsNullOrEmpty( taskUnit.Counters )
    local num = taskConfig:Id()*0.001 --TaskId from 1 to 100000
    local hidden = state <= wds.TaskState.TaskStateCanReceive -- questConfig.IsHidden
    local isRecommend = taskConfig:Property():Recommend()
    if not isRecommend then
        num = num + 500
    end
    if flag and not claimed then
        num = num + 1000
    elseif not flag and not claimed and not hidden then
        num = num + 2000
    elseif not flag2 then
        num = num + 3000
    elseif hidden then
        num = num + 4000
    elseif flag and claimed then
        num = num + 5000
    else
        num = num + 9999
    end
    return num;
end

---拿到当前所有的章节任务
---@return table<number,CachedChapterTaskItem>
function QuestModule_Chapter:GetChapterQuests()
    ---@type ChapterConfigCell
    -- local chapter = self:CurrentChapterConfig()
    -- if not chapter then
    --     return nil
    -- end
    -- if self.curChapter ~= chapter:Id() then
    --     self.curChapter = chapter:Id()
    --     self.taskItemCache = {}
    --     self:UpdateQuestCache()
    -- end

    return self.taskItemCache
end

function QuestModule_Chapter:UpdateQuestCache(updateLocalState)
    if self._lastUpdateQuestCacheFrame == g_Game.Time.frameCount then
        return
    end

    local player = ModuleRefer.PlayerModule:GetPlayer()
    if not player then return nil end

    local taskDB = player.PlayerWrapper.Task
    if not taskDB or not taskDB.Processing or not taskDB.FinishedBitMap then
        return nil
    end


    -- ---@type ChapterConfigCell
    -- local chapter = self:CurrentChapterConfig()
    -- if not chapter then
    --     return nil
    -- end

    -- local length = chapter:TaskListLength()
    -- if length < 1 then
    --     return nil
    -- end

    if table.isNilOrZeroNums(self.taskItemCache) then
        for _, task in ConfigRefer.Task:ipairs() do
            if task:Property():TaskType() ~= TaskType.MainChapter and
            task:Property():TaskType() ~= TaskType.SubChapter then
                goto continue
            end
            local taskID = task:Id()
            local cachedData = self.taskItemCache[taskID]
            if cachedData == nil then
                cachedData = {}
                self.taskItemCache[taskID] = cachedData
            end
            self:SyncCacheItem(taskID,cachedData,taskDB,true)
            ::continue::
        end
    else
        for key, value in pairs(self.taskItemCache) do
            self:SyncCacheItem(key,value,taskDB,updateLocalState)
        end
    end

    for key, value in pairs(self.taskItemCache) do
        self:SetupChainData(key,value)
    end

    self._lastUpdateQuestCacheFrame = g_Game.Time.frameCount
end


function QuestModule_Chapter:GetQuestCacheItem(taskID)
    if self.taskItemCache then
        return self.taskItemCache[taskID]
    end
    return nil
end

---@param taskID number
---@return CachedChapterTaskItem
function QuestModule_Chapter:UpdateQuestCasheItem(taskID)
    local player = ModuleRefer.PlayerModule:GetPlayer()
    if not player then return end

    local taskDB = player.PlayerWrapper.Task
    if not taskDB or not taskDB.Processing or not taskDB.FinishedBitMap then
        return
    end
    local cachedData = self.taskItemCache[taskID]
    if cachedData == nil then
        cachedData = {}
        self.taskItemCache[taskID] = cachedData
    end

    self:SyncCacheItem(taskID,cachedData,taskDB,true)
    return cachedData
end

---private
---@param taskID number
---@param cachedData CachedChapterTaskItem
---@param taskDB wds.Task
function QuestModule_Chapter:SyncCacheItem(taskID,cachedData,taskDB,updateLocalState)
    if not cachedData then
        return
    end
    local taskDBCell = taskDB.Processing[taskID]

    if taskDBCell then
        cachedData.unit = taskDBCell
        --因为任务完成后，DB信息会丢弃，所以在本地缓存一份分支信息
        cachedData.finishBranch = taskDBCell.FinishBranch
    else
        if self.parentModule:IsInBitMap(taskID,taskDB.FinishedBitMap) then
            cachedData.unit ={
                    TID = taskID,
                    State = wds.TaskState.TaskStateFinished
                }
            cachedData.state = wds.TaskState.TaskStateFinished
        else
            cachedData.unit ={
                TID = taskID,
                State = wds.TaskState.TaskStateInit
            }
        end
    end

    if cachedData.state == nil or updateLocalState then
        cachedData.state = cachedData.unit.State
    end

    if not cachedData.config then
        cachedData.config = ConfigRefer.Task:Find(taskID)
    end
end


---private
---任务链信息
---@param cachedData CachedChapterTaskItem
function QuestModule_Chapter:SetupChainData(taskId,cachedData)
    if cachedData == nil or cachedData.config == nil then return end
    local receiveCondGroup = cachedData.config:ReceiveCondition()
    if receiveCondGroup == nil or receiveCondGroup:FixedConditionLength() < 1 then return end

    local fixCond = receiveCondGroup:FixedCondition(1)
    if fixCond == nil or fixCond:Typ() ~= TaskCondType.TaskFinished then return end

    local depTaskId = tonumber( fixCond:Param() )
    if depTaskId then
        local depTask = self.taskItemCache[depTaskId]
        if depTask and depTask.config:Property():Chain() and cachedData.config:Property():Chain() then
            depTask.inChain = true
            depTask.nextId = taskId
            cachedData.inChain = true
            cachedData.preId = depTaskId
        end
    end
end


--当前章节任务完成情况
--返回值 任务总数，完成任务数，已经领取奖励的任务数
function QuestModule_Chapter:ChapterQuestCompleteCount()
    local chapterQuests = self:GetChapterQuests()
    local complete = 0
    local claimed = 0
    local questCount = 0

    for key, value in pairs(chapterQuests) do
        if value.unit.State >= wds.TaskState.TaskStateCanFinish then
            complete = complete + 1
        end
        if value.unit.State == wds.TaskState.TaskStateFinished then
            claimed = claimed + 1
        end
        questCount = questCount + 1
    end

    return questCount, complete, claimed
end

function QuestModule_Chapter:IsCurrentChapterAllFinish()
    local questCount, complete, claimed = self:ChapterQuestCompleteCount()
    return questCount <= claimed
end

--得到当前阶段目标的任务
---@return table<number,ChapterConfigCell> key is ChapterID
function QuestModule_Chapter:GetStageDataCache()
    if self.curStageData == nil then
        local curChapter = self:CurrentChapterConfig()
        local gid = curChapter:Group()
        local chapterGroups = {}
        for key, value in ConfigRefer.Chapter:ipairs() do
            if value:Group() == gid then
                chapterGroups[value:Id()] = value
            end
        end

        self.curStageData = chapterGroups
    end
    return self.curStageData
end
function QuestModule_Chapter:ClearStageDataCache()
    self.curStageData = nil
end

--得到当前阶段目标的任务数
function QuestModule_Chapter:GetQuestCountInStage()
    ---@type table<number,ChapterConfigCell>
    local stageData = self:GetStageDataCache()
    local count = 0
    for i, v in pairs(stageData) do
        count = count + v:TaskListLength()
    end
    return count
end

function QuestModule_Chapter:GetCompleteQuestCountInStage()
    ---@type table<number,ChapterConfigCell>
    local stageData = self:GetStageDataCache()
    local curChapter = self:CurrentChapterConfig()
    local curId = curChapter:Id()
    local count = 0
    for k, v in pairs(stageData) do
        count = count + v:TaskListLength()
    end

    --Not Finished quest cout
    local num = 0
    local chapterQuests = self:GetChapterQuests()
    if not Utils.IsNull(chapterQuests) then
        for _, item in pairs(chapterQuests) do
            if item.unit.State ~= wds.TaskState.TaskStateFinished then
                num = num + 1
            end
        end
    end

    local nextChapterIdSet = {}
    local nextChapterId = stageData[curId]:NextChapter()
    while nextChapterId > 0  do
        if nextChapterIdSet[nextChapterId] then
            if UNITY_EDITOR then
                require("WarningToolsForDesigner").DisplayEditorDialog("配置出问题了!!!", ("ChapterConfigCell NextChapter 配成循环的啦！！！！id:%s->id:%s"):format(curId, nextChapterId), "岂有此事！")
            end
            g_Logger.Error("ChapterConfigCell NextChapter 配成循环的啦！！！id:%s->id:%s", curId, nextChapterId)
            break
        end
        nextChapterIdSet[nextChapterId] = true
        local nextStageData = stageData[nextChapterId]
        if nextStageData then
            num = num + nextStageData:TaskListLength()
            nextChapterId = nextStageData:NextChapter()
        else
            nextChapterId = 0
        end
    end

    count = count - num
    return count
end

---@param cachedQuestItem CachedChapterTaskItem
---@return number
function QuestModule_Chapter:GetQuestHideFlag(cachedQuestItem)
    local hideFlag = 0
    if cachedQuestItem.config:Property():TaskType() ~= TaskType.MainChapter and
    cachedQuestItem.config:Property():TaskType() ~= TaskType.SubChapter then
        return 3
    end
    if not cachedQuestItem.inChain then
        if cachedQuestItem.state < wds.TaskState.TaskStateReceived then
            -- if info.cachedQuestItem.unit.State ~= info.cachedQuestItem.state then
            --     info.hideFlag = 1 --等待解锁任务
            -- else
            --     info.hideFlag = 2 --锁定任务
            -- end
            hideFlag = 3
        end
    else
        if cachedQuestItem.state < wds.TaskState.TaskStateFinished then
            --任务链隐藏判断
            --当任务未完成时，判断是否隐藏
            if cachedQuestItem.preId then
                local preTask = self.taskItemCache[cachedQuestItem.preId]
                if preTask and preTask.state < wds.TaskState.TaskStateFinished then
                    --有前置任务且前置任务未完成，需要隐藏
                    hideFlag = 3
                end
            elseif cachedQuestItem.state < wds.TaskState.TaskStateReceived then
                -- if info.cachedQuestItem.unit.State ~= info.cachedQuestItem.state then
                --     info.hideFlag = 1 --等待解锁任务
                -- else
                --     info.hideFlag = 2 --锁定任务
                -- end
                hideFlag = 3
            end
        else
            --当任务完成时，判断是否隐藏
            if cachedQuestItem.nextId ~= nil then
                --当不是链尾时，需要隐藏
                hideFlag = 3
            end
        end
    end
    return hideFlag
end

---@param num number
---@return CachedChapterTaskItem[]
function QuestModule_Chapter:GetRecommendQuests(num)
    local questCache = self:GetChapterQuests()
    local bigStack = {}
    local smallStack = {}
    for _, value in pairs(questCache) do
        local hideFlag = self:GetQuestHideFlag(value)
        if hideFlag == 3 then
            goto continue
        end
        local state = self.parentModule:GetQuestFinishedStateLocalCache(value.config:Id())
        if state >= wds.TaskState.TaskStateFinished or state == 0 then
            goto continue
        end
        local p = value.config:Property():RecommendPriority()
        if state == wds.TaskState.TaskStateCanFinish then
            p = p - 999999
        end
        if #bigStack < num then
            table.insert(bigStack, {task = value, priority = p})
        else
            while #bigStack > 0 and bigStack[#bigStack].priority > p do
                smallStack[#smallStack] = bigStack[#bigStack]
                table.remove(bigStack, #bigStack)
            end
            if #bigStack < num then
                table.insert(bigStack, {task = value, priority = p})
            end
            while #smallStack > 0 and #bigStack < num do
                table.insert(bigStack, smallStack[#smallStack])
                table.remove(smallStack, #smallStack)
            end
        end
        ::continue::
    end
    local ret = {}
    for i = 1, #bigStack do
        ret[i] = bigStack[i].task
    end
    return ret
end

---------------------------------------------------------------------------

---Network Interfaces
--获取章节任务奖励
--从QuestClaim状态调用
function QuestModule_Chapter:RequestChapterQuestReward(iTask, lockable)
    self.currentRequestTaskId = iTask
    local operationParameter = TaskOperationParameter.new()
    operationParameter.args.Op = wrpc.TaskOperation.TaskOpGetReward
    operationParameter.args.CID = iTask
    operationParameter:Send(lockable)
end

function QuestModule_Chapter:OnChapterQuestClaimCallback(ret, response)
    local questRewardSender = self.currentRequestTaskId
    g_Game.EventManager:TriggerEvent(EventConst.ON_QUEST_FINISH)
    if not self.stateCtrl then
        self:PlayStoryOnQuestFinish(questRewardSender)
        return
    end
    if ret then
        self.currentRequestTaskId = nil
        if questRewardSender ~= nil then

            if self:PlayStoryOnQuestFinish(questRewardSender) then
                return
            end

            if self.stateCtrl ~= nil then
                if not self.stateCtrl:IsInState(QuestStateConstant.StateName.QuestClaim)
                and not self.stateCtrl:IsInState(QuestStateConstant.StateName.ChapterTargetComplete)
                then
                    --call frome HUD
                    return
                end
                self.stateCtrl:WriteBlackboard('cmd',QuestStateConstant.StateCmd.QuestReward)
                self.stateCtrl:WriteBlackboard('iQuest',questRewardSender)
                self.stateCtrl:GoNext(true)
            end
        end
    else
        self.stateCtrl:WriteBlackboard('cmd',QuestStateConstant.StateCmd.NextState)
        self.stateCtrl:GoNext(true)
    end
end

--获取章节奖励或章节目标奖励
--从PartComplete或ChapterTargetComplete状态调用
function QuestModule_Chapter:RequestChapterReward(lockable)
    local serviceParameter = ChapterRewardParameter.new()
    serviceParameter:Send(lockable)
end

function QuestModule_Chapter:OnChapterClaimCallback(ret, response)
    if ret then
        self:ClearStageDataCache()
        if self.stateCtrl ~= nil
            and( self.stateCtrl:IsInState(QuestStateConstant.StateName.PartComplete)
                or self.stateCtrl:IsInState(QuestStateConstant.StateName.ChapterTargetComplete)
            )
        then
            self.stateCtrl:WriteBlackboard('cmd',QuestStateConstant.StateCmd.PartReward)
            self.stateCtrl:GoNext(true)
        end
        g_Game.EventManager:TriggerEvent(EventConst.QUEST_CHAPTER_FINISH)
    end
end

function QuestModule_Chapter:HasChapterGroupReward()
    local chapterDB = self:CurrentChapterDBData()
    return chapterDB and chapterDB.ChapterGroupID and chapterDB.ChapterGroupID > 0
end

function QuestModule_Chapter:RequestChapterGroupReward(lockable)
    local chapterDB = self:CurrentChapterDBData()
    if chapterDB.ChapterGroupID > 0 then
        local parameter = GroupRewardParameter.new()
        parameter.args.GroupID = chapterDB.ChapterGroupID
        parameter:Send(lockable)
    end
end

function QuestModule_Chapter:OnChapterGroupRewardCallback(ret,response)

    if ret and self.stateCtrl then
        if self.stateCtrl:IsInState(QuestStateConstant.StateName.GroupComplete) then
            self.stateCtrl:WriteBlackboard('cmd',QuestStateConstant.StateCmd.ChapterGroupReward)
            self.stateCtrl:GoNext()
        end
    end
end

function QuestModule_Chapter:OnChapterDBChanged(data, changedTable)
    ---@type wds.Chapter
    local chapter = self:CurrentChapterDBData();
    if not chapter then return nil end
    local chapterId = chapter.ChapterID
    if not self._minChapterId then
        self._minChapterId = ConfigRefer.Chapter.firstIid
    end
    if not self._minChapterId then
        self._minChapterId = 0
    end
    if chapterId < self._minChapterId then
        chapterId = self._minChapterId
    end
    if self.curChapter ~= chapterId
        or (changedTable ~= nil and changedTable.ChapterGroupID and changedTable.ChapterGroupID > 0) --Chapter Group has Finished
    then
        self.lastChapterId = self.curChapter
        self.curChapter = chapterId
        self.taskItemCache = {}
        self:UpdateQuestCache()
    end
end

---end of Network Interfaces
---------------------------------------------------------------------------
---------------------------------------------------------------------------
---DB Watcher

---end of DB Watcher
---data helper

--state ctrller
--初始化状态控制器
function QuestModule_Chapter:CreatePageState()
    if self.stateCtrl == nil then
        self.stateCtrl = require('PageStateCtrl').new(self)
    end
end

function QuestModule_Chapter:SetInitPageState(initState)
    if self.stateCtrl == nil and initState ~= nil then
        self.stateCtrl:SetInitState(initState)
    end
end


---OnViewerInit
---@param viewer ChapterQuestPageComponent
function QuestModule_Chapter:OnViewerInit(viewer)
    if self.stateCtrl == nil then
        return
    end
    self.stateCtrl:SetViewer(viewer)
end

--控制器启停
function QuestModule_Chapter:StartPageState()
    if self.stateCtrl ~= nil then
        self.stateCtrl:Start()
    end
end
function QuestModule_Chapter:StopPageState()
    if self.stateCtrl ~= nil then
       self.stateCtrl:Stop()
    end
end

--获取小节任务奖励，从PartNormal进入下一个状态
function QuestModule_Chapter:GetChapterQuestReward(iQuest, lockable,tableCell)
    if self.stateCtrl ~= nil and self.stateCtrl:IsInState(QuestStateConstant.StateName.PartNormal) then
        self.stateCtrl:WriteBlackboard('cmd',QuestStateConstant.StateCmd.QuestReward)
        self.stateCtrl:WriteBlackboard('iQuest',iQuest)
        self.stateCtrl:WriteBlackboard('lockable',lockable)
        self.stateCtrl:WriteBlackboard('tableCell',tableCell)
        self.stateCtrl:GoNext(true)
    end
end

--获取小节完成奖励，从PartNormal进入下一个状态
function QuestModule_Chapter:GetChapterPartReward(lockable)
    if self.stateCtrl ~= nil and self.stateCtrl:IsInState(QuestStateConstant.StateName.PartNormal) then
        self.stateCtrl:WriteBlackboard('cmd',QuestStateConstant.StateCmd.PartReward)
        self.stateCtrl:WriteBlackboard('lockable',lockable)
        self.stateCtrl:GoNext(true)
    end
end

--进入下一个小节，从PartComplete进入下一个状态
function QuestModule_Chapter:GotoNextPart()
    if self.stateCtrl ~= nil and self.stateCtrl:IsInState(QuestStateConstant.StateName.PartComplete) then
        self.stateCtrl:WriteBlackboard('cmd',QuestStateConstant.StateCmd.NextPart)
        self.stateCtrl:GoNext(true)
    end
end

---GetTaskProgress
---@param taskUnit wds.TaskUnit
---@return number,number count,maxCount
function QuestModule_Chapter:GetTaskProgress(taskUnit)
    return self.parentModule:GetTaskProgress(taskUnit)
end

---@param taskId number
---@return wds.TaskState
function QuestModule_Chapter:GetTaskState(taskId)
    local cachedData = self.taskItemCache[taskId]
    if not cachedData then
        return -1
    end

    return cachedData.state
end

---------------------------------------New Task----------------------------------------------
function QuestModule_Chapter:GetDilaogueIdsByGroupId(dialogueGroupId)
    local dialogueIds = self.dialogueGruopId2Ids[dialogueGroupId]
    if dialogueIds and #dialogueIds > 0 then
        return dialogueIds
    end
    dialogueIds = {}
    local dialogueId = ConfigRefer.StoryDialogGroup:Find(dialogueGroupId):StoryDialogId()
    self:GetDialogueSubsequent(dialogueId, dialogueIds)
    self.dialogueGruopId2Ids[dialogueGroupId] = dialogueIds
    return dialogueIds
end

function QuestModule_Chapter:GetDialogueSubsequent(dialogueId, dialogueIds)
    if dialogueId and dialogueId > 0 then
        dialogueIds[#dialogueIds + 1] = dialogueId
        local dialogueCfg = ConfigRefer.StoryDialog:Find(dialogueId)
        local dialogueSubsequent = dialogueCfg:Subsequent()
        if dialogueSubsequent and dialogueSubsequent > 0 then
            self:GetDialogueSubsequent(dialogueSubsequent, dialogueIds)
        end
    end
end

function QuestModule_Chapter:GetItemRewardCountById(taskId, itemId)
    local taskCfg = ConfigRefer.Task:Find(taskId)
    local rewards = self:GetQuestRewards(taskCfg) or {}
    local rewardNum = 0
    for _, reward in ipairs(rewards) do
        if reward:Items() == itemId then
            rewardNum = rewardNum + reward:Nums()
        end
    end
    return rewardNum
end

function QuestModule_Chapter:GetInProgressNewChapterId()
    local chapterDB = self:CurrentChapterDBData()
    return chapterDB.InProgressNewChapter
end

function QuestModule_Chapter:GetLastFinishedNewChapterId()
    local chapterDB = self:CurrentChapterDBData()
    return chapterDB.LastFinishedNewChapter
end

function QuestModule_Chapter:GetMaxSearchNewChapterId()
    local curNewChapterId = self:GetInProgressNewChapterId()
    local lastNewChapterId = self:GetLastFinishedNewChapterId()
    local chapterId = curNewChapterId
    if curNewChapterId == 0 then --当前没有正在进行的chapter
        if lastNewChapterId == 0 then --上次完成的章节是0代表现在是第一章
            chapterId = 1
        elseif lastNewChapterId > 0 then
            local nextNewChapterId = ConfigRefer.NewMainChapter:Find(lastNewChapterId):Next()
            if nextNewChapterId and nextNewChapterId > 0  then
                chapterId = nextNewChapterId
            else
                chapterId = lastNewChapterId
            end
        end
    end
    return chapterId
end

function QuestModule_Chapter:GetReceivedTaskChatNpcs()
    local receivedTaskChatNpcList = {}
    self:GetAllNpcTasks()
    for _, npcTasks in pairs(self.npc2TasksCache) do
        for _, npcTask in ipairs(npcTasks) do
            local taskId = npcTask.taskId
            local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
            if taskState == wds.TaskState.TaskStateReceived then
                receivedTaskChatNpcList[#receivedTaskChatNpcList + 1] = npcTask
            end
        end
    end
    self:GetAllCitizenTasks()
    for _, citizenTasks in pairs(self.citizen2TasksCache) do
        for _, citizenTask in ipairs(citizenTasks) do
            local taskId = citizenTask.taskId
            local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
            if taskState == wds.TaskState.TaskStateReceived then
                receivedTaskChatNpcList[#receivedTaskChatNpcList + 1] = citizenTask
            end
        end
    end
    local sortfunc = function(a, b)
        if a.priority ~= b.priority then
            return a.priority < b.priority
        else
            if a.newChapterId ~= b.newChapterId then
                return a.newChapterId > b.newChapterId
            else
                if a.taskId ~= b.taskId then
                    return a.taskId < b.taskId
                else
                    return false
                end
            end
        end
    end
    table.sort(receivedTaskChatNpcList, sortfunc)
    local result = {}
    for _, v in ipairs(receivedTaskChatNpcList) do
        if not self:CheckIsContainChatNpc(result, v.chatNpcId) then
            result[#result + 1] = v
        end
    end
    return result
end

function QuestModule_Chapter:CheckIsContainChatNpc(result, chatNpcId)
    for _, v in ipairs(result) do
        if v.chatNpcId == chatNpcId then
            return true
        end
    end
    return false
end

function QuestModule_Chapter:GetAllChatNpcTasks()
    local tasks = {}
    self:GetAllNpcTasks()
    for _, npcTasks in pairs(self.npc2TasksCache) do
        for _, npcTask in ipairs(npcTasks) do
            if self:CheckIsUnlockTask(npcTask.unlockTask) then
                local chatNpcId = npcTask.chatNpcId
                tasks[chatNpcId] = tasks[chatNpcId] or {}
                tasks[chatNpcId][#tasks[chatNpcId] + 1] = npcTask
            end
        end
    end
    self:GetAllCitizenTasks()
    for _, citizenTasks in pairs(self.citizen2TasksCache) do
        for _, citizenTask in ipairs(citizenTasks) do
            if self:CheckIsUnlockTask(citizenTask.unlockTask) then
                local chatNpcId = citizenTask.chatNpcId
                tasks[chatNpcId] = tasks[chatNpcId] or {}
                tasks[chatNpcId][#tasks[chatNpcId] + 1] = citizenTask
            end
        end
    end
    return tasks
end

function QuestModule_Chapter:GetAllDialogueIds(chatNpcId2Tasks, chatNpcId)
    local dialogueGroups = self:GetAllChatNpcDialogueGroupIds(chatNpcId2Tasks, chatNpcId) or {}
    local dialogues = {}
    for _ , dialogueGroupInfo in ipairs(dialogueGroups) do
        local dialogueGroupId = dialogueGroupInfo.dialogueGroupId
        local dialogueIds = {}
        if dialogueGroupId and dialogueGroupId > 0 then
            dialogueIds = self:GetDilaogueIdsByGroupId(dialogueGroupId)
        end
        for _, dialogeId in ipairs(dialogueIds) do
            dialogues[#dialogues + 1] = {dialogeId, dialogueGroupInfo.newChapterId}
        end
    end
    return dialogues
end

function QuestModule_Chapter:GetAllChatNpcDialogueGroupIds(chatNpcId2Tasks, chatNpcId)
    local curNewChapterId = self:GetInProgressNewChapterId()
    local lastNewChapterId = self:GetLastFinishedNewChapterId()
    local dialogueGroups = {}
    local maxChapterId = math.max(curNewChapterId, lastNewChapterId)
    if maxChapterId > 0 then
        for i = 1, maxChapterId do
            local chapterMainDialogueInfo = self:GetChapterMainDialogueInfo(i)
            if chapterMainDialogueInfo and chapterMainDialogueInfo.chatNpcId == chatNpcId then
                if not dialogueGroups[chapterMainDialogueInfo.dialogueGroupId] then
                    dialogueGroups[chapterMainDialogueInfo.dialogueGroupId] = {isMainDialogue = true, newChapterId = i, dialogueGroupId = chapterMainDialogueInfo.dialogueGroupId}
                end
            end
        end
    end
    local tasks = chatNpcId2Tasks[chatNpcId] or {}
    for _, task in ipairs(tasks) do
        local newChapterId = task.newChapterId
        if newChapterId <= maxChapterId then
            local chapterDialogueInfo = self:GetChapterDialogueInfo(newChapterId)
            for _, dialogueGroup in ipairs(chapterDialogueInfo) do
                if dialogueGroup.chatNpcId == chatNpcId then
                    if not dialogueGroups[dialogueGroup.dialogueGroupId] then
                        dialogueGroups[dialogueGroup.dialogueGroupId] = {isMainDialogue = false, newChapterId = newChapterId, dialogueGroupId = dialogueGroup.dialogueGroupId}
                    end
                end
            end
        end
    end
    local result = {}
    for _, dialogueInfo in pairs(dialogueGroups) do
        result[#result + 1] = dialogueInfo
    end
    local sortfunc = function(a, b)
        if a.newChapterId ~= b.newChapterId then
            return a.newChapterId < b.newChapterId
        else
            if a.isMainDialogue ~= b.isMainDialogue then
                return a.isMainDialogue
            else
                if a.dialogueGroupId ~= b.dialogueGroupId then
                    return a.dialogueGroupId < b.dialogueGroupId
                else
                    return false
                end
            end
        end
    end
    table.sort(result, sortfunc)
    local preDialog = ConfigRefer.ChatNPC:Find(chatNpcId):PreDialog()
    if preDialog > 0 then
        table.insert(result, 1, {isMainDialogue = false, newChapterId = 0, dialogueGroupId = preDialog})
    end
    return result
end

function QuestModule_Chapter:GetChapterMainDialogueInfo(newChapterId)
    if not self.newChapterMainDialogueCache[newChapterId] then
        local cfg = ConfigRefer.NewMainChapter:Find(newChapterId)
        if cfg then
            self.newChapterMainDialogueCache[newChapterId] = {chatNpcId = cfg:Chat(), dialogueGroupId = cfg:MainTaskDialog()}
        else
            return nil
        end
    end
    return self.newChapterMainDialogueCache[newChapterId]
end

function QuestModule_Chapter:GetChapterDialogueInfo(newChapterId)
    if not self.newChapterDialogueCache[newChapterId] then
        local dialogueGroups = {}
        local cfg = ConfigRefer.NewMainChapter:Find(newChapterId)
        for i = 1, cfg:NPCParamsLength() do
            local npcParam = cfg:NPCParams(i)
            dialogueGroups[#dialogueGroups + 1] = {chatNpcId = npcParam:Chat(), dialogueGroupId = npcParam:Dialogs()}
        end
        for i = 1, cfg:CitizenParamsLength() do
            local citizenParam = cfg:CitizenParams(i)
            dialogueGroups[#dialogueGroups + 1] = {chatNpcId = citizenParam:Chat(), dialogueGroupId = citizenParam:Dialogs()}
        end
        self.newChapterDialogueCache[newChapterId] = dialogueGroups
    end
    return self.newChapterDialogueCache[newChapterId]
end

function QuestModule_Chapter:GetChapterDialogueInfoByNpcId(newChapterId, chatNpcId)
    local chapterDialogueInfo = self:GetChapterDialogueInfo(newChapterId)
    for _, dialogueGroup in ipairs(chapterDialogueInfo) do
        if dialogueGroup.chatNpcId == chatNpcId then
            return dialogueGroup.dialogueGroupId
        end
    end
    return nil
end

function QuestModule_Chapter:CheckIsUnlockTask(taskId)
    if not taskId then
        return true
    end
    if taskId == 0 then
        return true
    end
    local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
    return taskState == wds.TaskState.TaskStateFinished
end

function QuestModule_Chapter:IsChapterContainChatNpc(newChapterId, chatNpcId)
    self.chapterChatNpcCache[newChapterId] = self.chapterChatNpcCache[newChapterId] or {}
    if not self.chapterChatNpcCache[newChapterId][chatNpcId] then
        local boolNum = 0
        local cfg = ConfigRefer.NewMainChapter:Find(newChapterId)
        for i = 1, cfg:NPCParamsLength() do
            local npcParam = cfg:NPCParams(i)
            if npcParam:Chat() == chatNpcId and self:CheckIsUnlockTask(npcParam:UnlockTask()) then
                boolNum = 1
                break
            end
        end
        if boolNum == 0 then
            for i = 1, cfg:CitizenParamsLength() do
                local citizenParam = cfg:CitizenParams(i)
                if citizenParam:Chat() == chatNpcId and self:CheckIsUnlockTask(citizenParam:UnlockTask()) then
                    boolNum = 1
                    break
                end
            end
        end
        self.chapterChatNpcCache[newChapterId][chatNpcId] = boolNum
    end
    return self.chapterChatNpcCache[newChapterId][chatNpcId] == 1
end

function QuestModule_Chapter:IsChatNpcContainChapter(task, checkChapterId)
    local containChapterTask = false
    local hasReceivedOrFinishedTask = false
    if task.isNpc then
        local cityElementNpcId = task.cityElementNpcId
        local npcTasks = self:GetCityElementNpcTasks(cityElementNpcId)
        for _, npcTask in ipairs(npcTasks) do
            if npcTask.newChapterId == checkChapterId and self:CheckIsUnlockTask(npcTask.unlockTask) then
                containChapterTask = true
                local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(npcTask.taskId)
                if taskState >= wds.TaskState.TaskStateReceived then
                    hasReceivedOrFinishedTask = true
                end
            end
        end
    else
        local citizenId = task.citizenId
        local citizenTasks = self:GetCitizensTasks(citizenId)
        for _, citizenTask in ipairs(citizenTasks) do
            if citizenTask.newChapterId == checkChapterId and self:CheckIsUnlockTask(citizenTask.unlockTask) then
                containChapterTask = true
                local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(citizenTask.taskId)
                if taskState >= wds.TaskState.TaskStateReceived then
                    hasReceivedOrFinishedTask = true
                end
            end
        end
    end
    return containChapterTask and hasReceivedOrFinishedTask
end

function QuestModule_Chapter:GetChapterOutOfSignalChatNpcs(checkChapterId)
    local newCfg = ConfigRefer.NewMainChapter:Find(checkChapterId)
    local results = {}
    for i = 1, newCfg:NPCParamsLength() do
        local npcParam = newCfg:NPCParams(i)
        if npcParam:BaseHint() then
            results[npcParam:Chat()] = true
        end
    end
    for i = 1, newCfg:CitizenParamsLength() do
        local citizenParam = newCfg:CitizenParams(i)
        if citizenParam:BaseHint() then
            results[citizenParam:Chat()] = true
        end
    end
    return results
end

function QuestModule_Chapter:CheckIsReadCityElementNpcInitialStory(cityElementNpcId)
    local initialStory = ConfigRefer.CityElementNpc:Find(cityElementNpcId):InitStoryTaskId()
    if initialStory and initialStory > 0 then
        return ModuleRefer.StoryModule:IsPlayerStoryTaskFinished(initialStory)
    end
    return true
end

function QuestModule_Chapter:CheckIsShowCityElementNpcHeadIcon(cityElementNpcId)
    -- local showTasks, _ = self:GetCityElementNpcShowTasks(cityElementNpcId)
    return false
end

function QuestModule_Chapter:GetCityElementNpcShowTasks(cityElementNpcId)
    local npcTasks, finishedTasks = self:GetNpcReceviedAndFinished(cityElementNpcId)
    local curNewChapterId = self:GetInProgressNewChapterId()
    local curTasks = {}
    local curChatNpc = nil
    local passTasks = {}
    local passChatNpc = nil
    local hasReceived = false
    for _, npcTask in ipairs(npcTasks) do
        local taskId = npcTask.taskId
        local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
        if  npcTask.newChapterId == curNewChapterId then
            curTasks[#curTasks + 1] = taskId
            curChatNpc = npcTask.chatNpcId
            if taskState == wds.TaskState.TaskStateReceived then
                hasReceived = true
            end
        elseif taskState == wds.TaskState.TaskStateReceived then
            passTasks[#passTasks + 1] = taskId
            passChatNpc = npcTask.chatNpcId
        end
    end
    local showTasks = {}
    local showChatNpc = nil
    if hasReceived and #curTasks > 0 then
        showTasks = curTasks
        showChatNpc = curChatNpc
    elseif #passTasks > 0 then
        showTasks = passTasks
        showChatNpc = passChatNpc
    end
    return showTasks, showChatNpc, finishedTasks
end

function QuestModule_Chapter:OpenNpcTaskCircleMenu(cityElementNpcId)
    local showTasks, showChatNpc = self:GetCityElementNpcShowTasks(cityElementNpcId)
    if #showTasks > 0 then
        local chatNpcCfg = ConfigRefer.ChatNPC:Find(showChatNpc)
        local chatNpcName = I18N.Get(chatNpcCfg:Name())
        local chatNpcIcon =  chatNpcCfg:IconLarge()
        local chatDesc = I18N.Get(chatNpcCfg:Des())
        local basicInfoDatum = TouchMenuBasicInfoDatum.new(chatNpcName, chatNpcIcon, chatDesc)
        local ret = {}
        for _, taskId in ipairs(showTasks) do
            ret[#ret + 1] = TouchMenuCellNpcTaskDatum.new(taskId)
        end
        local uiDatum = TouchMenuHelper.GetSinglePageUIDatum(basicInfoDatum, ret, {}):SetPos(nil)
        TouchMenuUIMediator.OpenSingleton(uiDatum)
    end
end

function QuestModule_Chapter:OnNpcChapterChanged(_, changedTable)
    local addMap, removeMap, changedMap = OnChangeHelper.GenerateMapFieldChangeMap(changedTable)
    for cityElementNpcId, _ in pairs(addMap or {}) do
        self.npc2TasksCache[cityElementNpcId] = nil
    end
    for cityElementNpcId, _ in pairs(removeMap or {}) do
        self.npc2TasksCache[cityElementNpcId] = nil
    end
    for cityElementNpcId, _ in pairs(changedMap or {}) do
        self.npc2TasksCache[cityElementNpcId] = nil
    end
end

function QuestModule_Chapter:GetAllNpcTasks()
    local player = ModuleRefer.PlayerModule:GetPlayer()
    local npcs = ModuleRefer.PlayerServiceModule:GetServiceMapByObjectType(NpcServiceObjectType.CityElement)
    for _, npc in pairs(npcs) do
        local cityElementCfg = ConfigRefer.CityElementData:Find(npc.ObjectId)
        if cityElementCfg then
            self:GetCityElementNpcTasks(cityElementCfg:ElementId())
        end
    end
    --这里和Citizen不同，因为Npc会被删除，所以从PlayerNpc.Npcs中取到的Npc并不包含已经被删除的，只能从PlayerNpc.NpcAcceptedChapters中取
    local npcAcceptedChapters = player.PlayerWrapper2.NpcServices.NpcAcceptedChapters or {}
    for cityElementNpcId, _ in pairs(npcAcceptedChapters) do
        self:GetCityElementNpcTasksByRecord(cityElementNpcId)
    end
    return self.npc2TasksCache
end

function QuestModule_Chapter:GetAllNpcsInCurChapter()
    local curNewChapterId = self:GetInProgressNewChapterId()
    if curNewChapterId <= 0 then
        return {}
    end
    local newCfg = ConfigRefer.NewMainChapter:Find(curNewChapterId)
    local results = {}
    for i = 1, newCfg:NPCParamsLength() do
        local npcParam = newCfg:NPCParams(i)
        local cityElementNpcId = npcParam:NPC()
        local cityElementId = ModuleRefer.CityModule.myCity.cityExplorerManager:GetCityElementIdByNpcId(cityElementNpcId)
        local hasService = ModuleRefer.PlayerServiceModule:HasInteractableServiceOnObject(NpcServiceObjectType.CityElement, cityElementId)
        if hasService then
            local chatNpcId = npcParam:Chat()
            results[chatNpcId] = {cityElementNpcId = cityElementNpcId, showHead = true, isNpc = true}
        end
    end
    for i = 1, newCfg:CitizenParamsLength() do
        local citizenParam = newCfg:CitizenParams(i)
        local citizenId = citizenParam:Citizens()
        local hasService = ModuleRefer.PlayerServiceModule:HasInteractableServiceOnObject(NpcServiceObjectType.Citizen, citizenId)
        if hasService then
            local chatNpcId = citizenParam:Chat()
            results[chatNpcId] = {citizenId = citizenId, showHead = true, isNpc = false}
        end
    end
    return results
end

---@return Chapter_task_cache
function QuestModule_Chapter:GetCityElementNpcTasks(id)
   local maxNewChapter = self:GetMaxSearchNewChapterId()
    local npcTasks = self.npc2TasksCache[id]
    if not npcTasks then
        if maxNewChapter and maxNewChapter > 0 then
            for newChapterId = 1, maxNewChapter do
                local newCfg = ConfigRefer.NewMainChapter:Find(newChapterId)
                if not newCfg then
                    goto continue
                end
                for i = 1, newCfg:NPCParamsLength() do
                    local npcParam = newCfg:NPCParams(i)
                    local cityElementNpcId = npcParam:NPC()
                    if cityElementNpcId == id then
                        npcTasks = npcTasks or {}
                        for j = 1, npcParam:TasksLength() do
                            ---@type Chapter_task_cache
                            local cache = {isNpc = true, cityElementNpcId = cityElementNpcId, taskId = npcParam:Tasks(j), newChapterId = newChapterId, dialogueGroupId = npcParam:Dialogs(),
                                           chatNpcId = npcParam:Chat(), priority = npcParam:Priority(), isAutoAccept = npcParam:AutoAccept(), unlockTask = npcParam:UnlockTask()}
                            npcTasks[#npcTasks + 1] = cache
                        end
                    end
                end
                ::continue::
            end
        end
        if npcTasks and #npcTasks >= 1 then
            self.npc2TasksCache[id] = npcTasks
        end
    end
    return npcTasks or {}
end

function QuestModule_Chapter:GetCityElementNpcTasksByRecord(id)
    local player = ModuleRefer.PlayerModule:GetPlayer()
    local npcAcceptedChapters = player.PlayerWrapper2.NpcServices.NpcAcceptedChapters
    local npcTasks = self.npc2TasksCache[id]
    if not npcTasks then
        local acceptedChapters = (npcAcceptedChapters[id] or {}).AcceptedChapters
        if acceptedChapters then
            for _, newChapterId in pairs(acceptedChapters) do
                local newCfg = ConfigRefer.NewMainChapter:Find(newChapterId)
                for i = 1, newCfg:NPCParamsLength() do
                    local npcParam = newCfg:NPCParams(i)
                    local cityElementNpcId = npcParam:NPC()
                    if cityElementNpcId == id then
                        npcTasks = npcTasks or {}
                        for j = 1, npcParam:TasksLength() do
                            ---@type Chapter_task_cache
                            local cache = {isNpc = true, cityElementNpcId = cityElementNpcId, taskId = npcParam:Tasks(j), newChapterId = newChapterId, dialogueGroupId = npcParam:Dialogs(),
                                           chatNpcId = npcParam:Chat(), priority = npcParam:Priority(), isAutoAccept = npcParam:AutoAccept(), unlockTask = npcParam:UnlockTask()}
                            npcTasks[#npcTasks + 1] = cache
                        end
                    end
                end
            end
        end
        if npcTasks and #npcTasks >= 1 then
            self.npc2TasksCache[id] = npcTasks
        end
    end
    return npcTasks or {}
end

function QuestModule_Chapter:GetNpcReceviedAndFinished(cityElementNpcId)
    local npcTasks = self:GetCityElementNpcTasks(cityElementNpcId)
    local receviedTasks = {}
    local finishedTasks = {}
    for _, npcTask in ipairs(npcTasks) do
        local taskId = npcTask.taskId
        local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
        if taskState == wds.TaskState.TaskStateReceived then
            receviedTasks[#receviedTasks + 1] = npcTask
        elseif taskState == wds.TaskState.TaskStateFinished then
            finishedTasks[#finishedTasks + 1] = npcTask
        end
    end
    return receviedTasks, finishedTasks
end

function QuestModule_Chapter:CheckIsReadCitizenInitialStory(citizenId)
    local initialStory = self:GetCitizenInitalStory(citizenId)
    if initialStory and initialStory > 0 then
        return ModuleRefer.StoryModule:IsPlayerStoryTaskFinished(initialStory)
    end
    return true
end

function QuestModule_Chapter:CheckIsShowCitizenHeadIcon(citizenId)
    -- local showTasks, _ = self:GetCitizenShowTasks(citizenId)
    -- return #showTasks > 0, self:GetCitizenInitalStory(citizenId)
    return false, nil
end

function QuestModule_Chapter:GetCitizenInitalStory(citizenId)
    local curNewChapterId = self:GetInProgressNewChapterId()
    if curNewChapterId <= 0 then
        return nil
    end
    local newCfg = ConfigRefer.NewMainChapter:Find(curNewChapterId)
    for i = 1, newCfg:CitizenParamsLength() do
        local citizenParam = newCfg:CitizenParams(i)
        local id = citizenParam:Citizens()
        if id == citizenId then
            return citizenParam:CitizenInitialStory()
        end
    end
    return nil
end

function QuestModule_Chapter:GetCitizenShowTasks(citizenId)
    local citizenTasks, finishedTasks = self:GetCitizenReceviedAndFInished(citizenId)
    local curNewChapterId = self:GetInProgressNewChapterId()
    local curTasks = {}
    local curChatNpc = nil
    local passTasks = {}
    local passChatNpc = nil
    local hasReceived = false
    for _, citizenTask in ipairs(citizenTasks) do
        local taskId = citizenTask.taskId
        local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
        if  citizenTask.newChapterId == curNewChapterId then
            curTasks[#curTasks + 1] = taskId
            curChatNpc = citizenTask.chatNpcId
            if taskState == wds.TaskState.TaskStateReceived then
                hasReceived = true
            end
        elseif taskState == wds.TaskState.TaskStateReceived then
            passTasks[#passTasks + 1] = taskId
            passChatNpc = citizenTask.chatNpcId
        end
    end
    local showTasks = {}
    local showChatNpc = nil
    if hasReceived and #curTasks > 0 then
        showTasks = curTasks
        showChatNpc = curChatNpc
    elseif #passTasks > 0 then
        showTasks = passTasks
        showChatNpc = passChatNpc
    end
    return showTasks, showChatNpc, finishedTasks
end

function QuestModule_Chapter:OpenCitizenTaskCircleMenu(citizenId, onHideCallback)
    local showTasks, showChatNpc = self:GetCitizenShowTasks(citizenId)
    if #showTasks > 0 then
        local chatNpcCfg = ConfigRefer.ChatNPC:Find(showChatNpc)
        local chatNpcName = I18N.Get(chatNpcCfg:Name())
        local chatNpcIcon = chatNpcCfg:IconLarge()
        local chatDesc = I18N.Get(chatNpcCfg:Des())
        local basicInfoDatum = TouchMenuBasicInfoDatum.new(chatNpcName, chatNpcIcon, chatDesc)
        local ret = {}
        for _, taskId in ipairs(showTasks) do
            ret[#ret + 1] = TouchMenuCellNpcTaskDatum.new(taskId)
        end
        local uiDatum = TouchMenuHelper.GetSinglePageUIDatum(basicInfoDatum, ret, {}):SetPos(nil):SetOnHideCallback(onHideCallback)
        TouchMenuUIMediator.OpenSingleton(uiDatum)
        return true
    end
end

function QuestModule_Chapter:OnCitizenDataChanged(_, changedTable)
    local addMap, _, changedMap = OnChangeHelper.GenerateMapFieldChangeMap(changedTable)
    for _, v in pairs(addMap or {}) do
        if v.ConfigId then
            self.citizen2TasksCache[v.ConfigId] = nil
        end
    end
    for _, v in pairs(changedMap or {}) do
        for _, k in pairs(v) do
            if k.ConfigId then
                self.citizen2TasksCache[k.ConfigId] = nil
            end
        end
    end
end

function QuestModule_Chapter:GetAllCitizenTasks()
    local player = ModuleRefer.PlayerModule:GetPlayer()
    local castleBrief = g_Game.DatabaseManager:GetEntity(player.SceneInfo.CastleBriefId, DBEntityType.CastleBrief)
    local citizens = castleBrief.Castle.CastleCitizens or {}
    for _, citizen in pairs(citizens) do
        self:GetCitizensTasks(citizen.ConfigId)
    end
    return self.citizen2TasksCache
end

function QuestModule_Chapter:GetCitizensTasks(citizenId)
    local citizenTasks = self.citizen2TasksCache[citizenId]
    local maxNewChapter = self:GetMaxSearchNewChapterId()
    if not citizenTasks then
        if maxNewChapter and maxNewChapter > 0 then
            for newChapterId = 1, maxNewChapter do
                local newCfg = ConfigRefer.NewMainChapter:Find(newChapterId)
                if not newCfg then
                    goto continue
                end
                for i = 1, newCfg:CitizenParamsLength() do
                    local citizenParam = newCfg:CitizenParams(i)
                    local id = citizenParam:Citizens()
                    if id == citizenId then
                        citizenTasks = citizenTasks or {}
                        for j = 1, citizenParam:TasksLength() do
                            citizenTasks[#citizenTasks + 1] = {isNpc = false, citizenId = id, taskId = citizenParam:Tasks(j), newChapterId = newChapterId, dialogueGroupId = citizenParam:Dialogs(),
                                chatNpcId = citizenParam:Chat(), priority = citizenParam:Priority(), isAutoAccept = citizenParam:AutoAccept(), unlockTask = citizenParam:UnlockTask()}
                        end
                    end
                end
                ::continue::
            end
        end
        if citizenTasks and #citizenTasks >= 1 then
            self.citizen2TasksCache[citizenId] = citizenTasks
        end
    end
    return citizenTasks or {}
end

function QuestModule_Chapter:GetCitizenReceviedAndFInished(citizenId)
    local citizenTasks = self:GetCitizensTasks(citizenId)
    local receviedTasks = {}
    local finishedTasks = {}
    for _, citizenTask in ipairs(citizenTasks) do
        local taskId = citizenTask.taskId
        local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
        if taskState == wds.TaskState.TaskStateReceived then
            receviedTasks[#receviedTasks + 1] = citizenTask
        elseif taskState == wds.TaskState.TaskStateFinished then
            finishedTasks[#finishedTasks + 1] = citizenTask
        end
    end
    return receviedTasks, finishedTasks
end

function QuestModule_Chapter:GetHudQuestAnimState()
    return self.hudQuestAnimState
end

function QuestModule_Chapter:SetHudQuestAnimState(hudQuestAnimState)
    self.hudQuestAnimState = hudQuestAnimState
end

function QuestModule_Chapter:ForceRefreshAnimState()
    TimerUtility.DelayExecute(function()
        if self:GetHudQuestAnimState() then
            self:SetHudQuestAnimState(false)
            g_Game.EventManager:TriggerEvent(EventConst.REFRESH_HUD_NPC_QUEST)
        end
    end, 4)
end

return QuestModule_Chapter
