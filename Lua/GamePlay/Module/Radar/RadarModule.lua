---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by hao.wu.ss
--- DateTime: 2022/9/15 11:59
---
local BaseModule = require('BaseModule')
local CityUtils = require("CityUtils")
local BuildingType = require("BuildingType")
local ArtResourceUtils = require('ArtResourceUtils')
local ModuleRefer = require("ModuleRefer")
local ConfigRefer = require("ConfigRefer")
local KingdomMapUtils = require('KingdomMapUtils')
local Utils = require('Utils')
local CityConstructState = require('CityConstructState')
local NotificationType = require('NotificationType')
local EventConst = require('EventConst')
local ArtResourceUIConsts = require("ArtResourceUIConsts")
local ObjectType = require("ObjectType")
local UIHelper = require("UIHelper")
local RadarTaskUtils = require("RadarTaskUtils")
local UIMediatorNames = require("UIMediatorNames")
local DBEntityPath = require("DBEntityPath")
local Delegate = require('Delegate')
local I18N = require('I18N')
local DBEntityType = require('DBEntityType')
local CityFurnitureTypeNames = require('CityFurnitureTypeNames')
local ProgressType = require('ProgressType')
local StoryDialogUIMediatorParameter = require('StoryDialogUIMediatorParameter')
local StoryDialogUIMediatorParameterChoiceProvider = require('StoryDialogUIMediatorParameterChoiceProvider')
local ManualResourceConst = require('ManualResourceConst')
local TimerUtility = require('TimerUtility')
local UIAsyncDataProvider = require('UIAsyncDataProvider')
local FinishExploreRadarTaskParameter = require('FinishExploreRadarTaskParameter')
local RadarTaskBoardData = require('RadarTaskBoardData')
local PetQuality = require('PetQuality')

local Vector3 = CS.UnityEngine.Vector3
local Vector2 = CS.UnityEngine.Vector2
local PooledGameObjectCreateHelper = CS.DragonReborn.AssetTool.PooledGameObjectCreateHelper

---@class BubbleUIPosCacheData
---@field x number
---@field y number
---@field row number
---@field col number
---@field go CS.UnityEngine.GameObject
---@field luaGO "CS.XLua.LuaTable"
---@field isShake boolean       是否已抖动
---@field ShakeAngle number     圆心到原点的角度

---@class RadarModule
local RadarModule = class('RadarModule', BaseModule)

RadarModule.CITY_FILTER_BUBBLE_TYPE = {SE_BATTLE = 10, SE_PET = 11}

local QUALITY_COLOR_STR = {"#519F0E", "#0E74FF", "#D81FF1", "#E37A00"}
local RADARTASK_TYPE = {
    normal = 1, -- 一般雷达任务
    elite = 2, -- 精英雷达任务
    creepNormal = 3, -- 菌毯雷达任务(未清除)
    creepUnlock = 4, -- 菌毯雷达任务(已清除)
}
local PetTrackState = {tracking = 0, complete = 1, idle = 2}
local QUALITY_COLOR = {"sp_city_bubble_base_green", "sp_city_bubble_base_blue", "sp_city_bubble_base_purple", "sp_city_bubble_base_orange"}
local QUALITY_COLOR_CYST = {"sp_radar_img_light_01", "sp_radar_img_light_02", "sp_radar_img_light_03", "sp_radar_img_light_04"}
function RadarModule:ctor()

end

function RadarModule:CheckIsUnlockRadar()
    local sysIndex = ConfigRefer.ConstMain:UnlockRadarSystemSwitch()
    return ModuleRefer.NewFunctionUnlockModule:CheckNewFunctionIsUnlocked(sysIndex)
end

function RadarModule:CheckIsNeedFakeRadar()
    -- return false
    local taskId = ConfigRefer.ConstMain:UnlockFakeRadarTask()
    if taskId and taskId > 0 then
        local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
        local isFinish = taskState == wds.TaskState.TaskStateFinished
        return not isFinish
    else
        return false
    end
end

function RadarModule:CheckIsLockWorldRadar()
    return false
    -- local taskId = ConfigRefer.ConstMain:LockWorldRadarTask()
    -- if taskId and taskId > 0 then
    --     local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(taskId)
    --     local isFinish = taskState == wds.TaskState.TaskStateFinished
    --     return not isFinish
    -- else
    --     return false
    -- end
end

function RadarModule:OnRegister()
    self.createHelper = PooledGameObjectCreateHelper.Create("RadarFilter")
    self.radarBubbleList = {}
    self.bubbleList = {}
    self.cityBubbleList = {}
    self.recordFilterLv = {}
    self.radarTaskBubbleList = {}
    self.mistTaskBubbleList = {}
    self.creepBubbleList = {}
    self.allianceBubbleList = {}
    self.bubbleUIPosCache = {}
    self.scoutObjects = {}
    self.newAddWorldEventInfo = nil
    self.curShowRadarTaskCount = 0
    self.loadTaskLock = false
    self.loadEventLock = false
    self:ClearLastRefreshRecord()
    g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MsgPath, Delegate.GetOrCreate(self, self.RefreshRedDot))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.ReceivedTasks.MsgPath, Delegate.GetOrCreate(self, self.ShowToast))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.EliteTasks.MsgPath, Delegate.GetOrCreate(self, self.ShowToast))
    -- g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.ReceivedTasks.MsgPath, Delegate.GetOrCreate(self, self.OnTasksRemove))
    -- g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.EliteTasks.MsgPath, Delegate.GetOrCreate(self, self.OnTasksRemove))
    --    g_Game.DatabaseManager:AddChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.MistTasks.MsgPath,Delegate.GetOrCreate(self,self.OnMistTasksRemove))
    g_Game.DatabaseManager:AddChanged(DBEntityPath.CastleBrief.BasicInfo.MainBuildingLevel.MsgPath, Delegate.GetOrCreate(self, self.OnCastleLevelChanged))
end

function RadarModule:SetUp()
    self.cityRadarTasks = {}
    self:RefreshRadarTask()
    self:SetFirstOpen(1)
end

function RadarModule:GetCreateHelper()
    return self.createHelper
end

function RadarModule:SetRadarState(isInRadar)
    self.isInRadar = isInRadar
    -- g_Game.EventManager:TriggerEvent(EventConst.RADAR_STATE_CHANGE, self.isInRadar)
    -- g_Game.EventManager:TriggerEvent(EventConst.CITY_BUBBLE_STATE_CHANGE)
end

function RadarModule:IsInRadar()
    return self.isInRadar
end

function RadarModule:RecordSelectLv(filterType, lv)
    self.recordFilterLv[filterType] = lv or -1
end

function RadarModule:GetSelectLv(filterType)
    return self.recordFilterLv[filterType] or -1
end

function RadarModule:OnRemove()
    self:DestroyAllBubble()
    self:ClearUIPosCache()
    self.scoutObjects = {}
    self.newAddWorldEventInfo = nil
    self.curShowRadarTaskCount = 0
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MsgPath, Delegate.GetOrCreate(self, self.RefreshRedDot))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.ReceivedTasks.MsgPath, Delegate.GetOrCreate(self, self.ShowToast))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.EliteTasks.MsgPath, Delegate.GetOrCreate(self, self.ShowToast))
    -- g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.ReceivedTasks.MsgPath, Delegate.GetOrCreate(self, self.OnTasksRemove))
    -- g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.EliteTasks.MsgPath, Delegate.GetOrCreate(self, self.OnTasksRemove))
    --    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.Player.PlayerWrapper2.Radar.MapRadarTask.MistTasks.MsgPath,Delegate.GetOrCreate(self,self.OnMistTasksRemove))
    g_Game.DatabaseManager:RemoveChanged(DBEntityPath.CastleBrief.BasicInfo.MainBuildingLevel.MsgPath, Delegate.GetOrCreate(self, self.OnCastleLevelChanged))
end

function RadarModule:InitRedDot()
    if self.createRedDot then
        return
    end

    self.createRedDot = true
end

function RadarModule:RefreshRedDot()
    if not self.createRedDot then
        self:InitRedDot()
    end
    local rewardCount = self:GetRadarTaskRewardCount()
    local canAward = rewardCount > 0
    -- local canUpgrade = self:CheckIsCanUpgrade()

    if not canAward then
        g_Game.EventManager:TriggerEvent(EventConst.RADAR_SHOW_REWARD_TASK, false)
        g_Game.EventManager:TriggerEvent(EventConst.RADAR_FURNITURE_CHANGED, 1000101)
    end

    self:RefreshRadarEntryReddot()
end

function RadarModule:IsRadarCanUpgrade()
    local canLevelUp = false
    local city = ModuleRefer.CityModule.myCity
    if city then
        local furnitureManager = city.furnitureManager
        if furnitureManager then
            ---@type CityFurniture
            local radarFurnitureInfo = furnitureManager:GetFurnitureByTypeCfgId(CityFurnitureTypeNames.radartable)
            if radarFurnitureInfo then
                canLevelUp = furnitureManager:IsFunitureCanUpgrade(radarFurnitureInfo.singleId)
            end
        end
    end
    return canLevelUp
end

function RadarModule:ShowToast(entity, changedData)
    if not changedData then
        return
    end

    if changedData.Add then
        if self:GetRadarLv() < ConfigRefer.ConstBigWorld:RadarDisplayNewTaskPop() then
            g_Game.EventManager:TriggerEvent(EventConst.RADAR_SHOW_NEW_TASK, true)
        end
    end

    ---@type table<number, wds.RadarTask>
    for k, v in pairs(changedData) do
        if v.State == wds.RadarTaskState.RadarTaskState_CanReceiveReward then
            if self.cityRadarTasks[v.EntityId] then
                self.cityRadarTasks[v.EntityId] = nil
            end
            local taskInfo = self:GetRadarInfo().MapRadarTask.ReceivedTasks[k]
            if not taskInfo then
                taskInfo = self:GetRadarInfo().MapRadarTask.EliteTasks[k]
            end
            if not taskInfo then
                goto continue
            end
            local taskConfig = ConfigRefer.RadarTask:Find(taskInfo.RadarTaskId)
            if not taskConfig then
                goto continue
            end
            local colorStr = QUALITY_COLOR_STR[taskInfo.Quality + 1]
            local name = UIHelper.GetColoredText(I18N.Get(taskConfig:Name()), colorStr)
            local content = I18N.GetWithParams("Radar_task_finished_toast", name)
            ModuleRefer.ToastModule:AddJumpToast(content)

            if self:GetRadarLv() < ConfigRefer.ConstBigWorld:RadarDisplayNewTaskPop() then
                g_Game.EventManager:TriggerEvent(EventConst.RADAR_SHOW_REWARD_TASK, true)
            end

            return
        end
        ::continue::
    end
end

function RadarModule:OnTasksRemove(entity, changedData)
    if not changedData or not changedData.Remove then
        return
    end
    for k, v in pairs(changedData.Remove) do
        self:DeleteUIPosCache(k)
    end
end

function RadarModule:DestroyAllBubble()
    for _, bubbleGo in pairs(self.bubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.bubbleList = {}

    for _, bubbleGo in pairs(self.radarBubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.radarBubbleList = {}

    for _, bubbles in pairs(self.cityBubbleList) do
        for _, bubbleGo in ipairs((bubbles)) do
            if (Utils.IsNotNull(bubbleGo)) then
                CS.UnityEngine.Object.Destroy(bubbleGo)
            end
        end
    end
    self.cityBubbleList = {}

    for _, bubbleGo in pairs(self.radarTaskBubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.radarTaskBubbleList = {}
    self.curShowRadarTaskCount = 0

    for _, bubbleGo in pairs(self.mistTaskBubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.mistTaskBubbleList = {}

    for _, bubbleGo in pairs(self.creepBubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.creepBubbleList = {}

    for _, bubbleGo in pairs(self.allianceBubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.allianceBubbleList = {}
end

function RadarModule:ClearRadarBubbleList()
    for _, bubbleGo in pairs(self.radarBubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.radarBubbleList = {}
end

function RadarModule:ClearRadarTaskBubbleList()
    for _, bubbleGo in pairs(self.radarTaskBubbleList) do
        if (Utils.IsNotNull(bubbleGo)) then
            CS.UnityEngine.Object.Destroy(bubbleGo)
        end
    end
    self.radarTaskBubbleList = {}
end

function RadarModule:HideBubbleByType(hideRadar, hideOther, hideCity, hideRadarTask, hideMistTask, hideCreepTask, hideAlliance)
    if hideRadar then
        for _, bubbleGo in pairs(self.radarBubbleList) do
            if (Utils.IsNotNull(bubbleGo)) then
                bubbleGo:SetVisible(false)
            end
        end
    end

    if hideOther then
        for _, bubbleGo in pairs(self.bubbleList) do
            if (Utils.IsNotNull(bubbleGo)) then
                bubbleGo:SetVisible(false)
            end
        end
    end

    if hideCity then
        for _, bubbles in pairs(self.cityBubbleList) do
            for _, bubbleGo in ipairs((bubbles)) do
                if (Utils.IsNotNull(bubbleGo)) then
                    bubbleGo:SetVisible(false)
                end
            end
        end
    end

    hideRadarTask = hideRadarTask or false
    if hideRadarTask then
        for _, bubbleGo in pairs(self.radarTaskBubbleList) do
            if (Utils.IsNotNull(bubbleGo)) then
                bubbleGo:SetVisible(false)
            end
        end
    end

    hideMistTask = hideMistTask or false
    if hideMistTask then
        for _, bubbleGo in pairs(self.mistTaskBubbleList) do
            if (Utils.IsNotNull(bubbleGo)) then
                bubbleGo:SetVisible(false)
            end
        end
    end

    hideCreepTask = hideCreepTask or false
    if hideCreepTask then
        for _, bubbleGo in pairs(self.creepBubbleList) do
            if (Utils.IsNotNull(bubbleGo)) then
                bubbleGo:SetVisible(false)
            end
        end
    end

    hideAlliance = hideAlliance or false
    if hideAlliance then
        for _, bubbleGo in pairs(self.allianceBubbleList) do
            if (Utils.IsNotNull(bubbleGo)) then
                bubbleGo:SetVisible(false)
            end
        end
    end
end

function RadarModule:LoadFakeRadar()
    if self.fakeBubble then
        self:UnloadFakeRadar()
    end
    local parent = KingdomMapUtils.GetMapSystem().Parent
    self.createHelper:Create("ui3d_bubble_fake_world_events", parent, function(bubbleGo)
        bubbleGo.transform.position = self:GetFakePos()
        self.fakeBubble = bubbleGo
    end)
end

function RadarModule:GetFakePos()
    local city = ModuleRefer.CityModule.myCity
    if not city then
        return
    end
    local cityPos = city:GetKingdomMapPosition() + CS.UnityEngine.Vector3(1500, 0, 0)
    return cityPos
end

function RadarModule:UnloadFakeRadar()
    if (Utils.IsNotNull(self.fakeBubble)) then
        CS.UnityEngine.Object.Destroy(self.fakeBubble)
        self.fakeBubble = nil
    end
end

function RadarModule:LoadCityIcon()
    -- if self.cityBubble then
    --     self:UnloadCityIcon()
    -- end
    -- local parent = KingdomMapUtils.GetMapSystem().Parent
    -- local city = ModuleRefer.CityModule.myCity
    -- if not city then
    --     return
    -- end
    -- self.createHelper:Create("ui3d_bubble_radar", parent, function(bubbleGo)
    --     local cityPos = city:GetKingdomMapPosition()
    --     bubbleGo.transform.position = cityPos
    --     local spriteTrans = bubbleGo.transform:Find("p_rotation/p_position/p_icon_status")
    --     if Utils.IsNotNull(spriteTrans) then
    --         local renderer = spriteTrans:GetComponent(typeof(CS.U2DSpriteMesh))
    --         if Utils.IsNotNull(renderer) then
    --             g_Game.SpriteManager:LoadSprite("sp_icon_slg_home_1", renderer)
    --         end
    --     end
    --     local behavior = bubbleGo:GetLuaBehaviour("PvETileAsseRadarBubbleBehavior").Instance
    --     behavior:InitEvent(nil, {isMainCity = true, worldPos = cityPos})
    --     self.cityBubble = bubbleGo
    -- end)
end

function RadarModule:UnloadCityIcon()
    if (Utils.IsNotNull(self.cityBubble)) then
        CS.UnityEngine.Object.Destroy(self.cityBubble)
        self.cityBubble = nil
    end
end

function RadarModule:LoadBubble(iconName, position, bubbleType, customData, uniqueId)
    -- local parent = KingdomMapUtils.GetMapSystem().Parent
    -- self.createHelper:Create("ui3d_bubble_radar", parent, function(bubbleGo)
    --     self.bubbleList[uniqueId] = bubbleGo
    --     bubbleGo.transform.position = position
    --     local spriteTrans = bubbleGo.transform:Find("p_rotation/p_position/p_icon_status")
    --     if Utils.IsNotNull(spriteTrans) then
    --         local renderer = spriteTrans:GetComponent(typeof(CS.U2DSpriteMesh))
    --         if Utils.IsNotNull(renderer) then
    --             g_Game.SpriteManager:LoadSprite(iconName, renderer)
    --             local frame = bubbleGo.transform:Find("p_rotation/p_position/Frame")
    --             if customData and customData.inCity then
    --                 spriteTrans.transform.localPosition = CS.UnityEngine.Vector3(-1, 2, -0.04)
    --                 frame.transform.localPosition = CS.UnityEngine.Vector3(0, -8, 0)
    --             end
    --         end
    --         local baseTrans = bubbleGo.transform:Find("p_rotation/p_position/p_base")
    --         if Utils.IsNotNull(baseTrans) then
    --             local baserenderer = baseTrans:GetComponent(typeof(CS.U2DSpriteMesh))
    --             if Utils.IsNotNull(baserenderer) then
    --                 g_Game.SpriteManager:LoadSprite("sp_city_bubble_base_01", baserenderer)
    --             end
    --         end
    --         if bubbleType then
    --             local behavior = bubbleGo:GetLuaBehaviour("PvETileAsseRadarBubbleBehavior").Instance
    --             behavior:InitEvent(bubbleType, customData)
    --         end
    --     end
    -- end)
end

function RadarModule:RefreshBubble(icon, worldPos, customData, bubbleGo, bubbleType, uniqueId)
    bubbleGo.transform.position = worldPos
    local spriteTrans = bubbleGo.transform:Find("p_rotation/p_position/p_icon_status")
    if Utils.IsNotNull(spriteTrans) then
        local renderer = spriteTrans:GetComponent(typeof(CS.U2DSpriteMesh))
        if Utils.IsNotNull(renderer) then
            g_Game.SpriteManager:LoadSprite(icon, renderer)
            local frame = bubbleGo.transform:Find("p_rotation/p_position/Frame")
            if customData and customData.inCity then
                spriteTrans.transform.localPosition = CS.UnityEngine.Vector3(-1, 2, -0.04)
                frame.transform.localPosition = CS.UnityEngine.Vector3(0, -8, 0)
            end
        end
        local behavior = bubbleGo:GetLuaBehaviour("PvETileAsseRadarBubbleBehavior").Instance
        behavior:InitEvent(bubbleType, customData)
    end
    bubbleGo:SetVisible(true)
    self.bubbleList[uniqueId] = bubbleGo
end

function RadarModule:LoadExpeditionBubble(customData, uniqueId, parentTrans, item, isActive, isAlliance)
    isActive = isActive or false
    isAlliance = isAlliance or false
    local boardData = self:SetBoardData(uniqueId, customData.Pos.X, customData.Pos.Y)
    if boardData.result then
        local btnComp = UIHelper.DuplicateUIComponent(item, parentTrans)
        if not btnComp then
            return
        end
        self:UpdateBubbleUIPosCache(boardData, uniqueId, btnComp.gameObject, btnComp.Lua, true)
        btnComp.gameObject.transform.localPosition = boardData.arrowPos
        -- btnComp.gameObject.name = uniqueId
        btnComp.gameObject:SetVisible(isActive)
        local expeditionInfo = self:CreateExpeditionInfoByRadarTaskData(customData)
        ---@type WorldEventButtonData
        local param = {iconName = "sp_comp_icon_worldevent", expeditionInfo = expeditionInfo, radarTaskData = customData, uiPos = boardData.arrowPos}
        param.isAlliance = isAlliance
        btnComp.Lua:OnFeedData(param)
        if isAlliance then
            self.allianceBubbleList[uniqueId] = btnComp.gameObject
        else
            self.radarBubbleList[uniqueId] = btnComp.gameObject
        end
    end
end

function RadarModule:RefreshExpeditionBubble(customData, bubbleGo, uniqueId, isAlliance)
    isAlliance = isAlliance or false
    local behavior = bubbleGo:GetComponent(typeof(CS.DragonReborn.UI.LuaBaseComponent)).Lua
    ---@type wrpc.RadarScanResultExpedition
    local expeditionInfo = self:CreateExpeditionInfoByRadarTaskData(customData)
    ---@type WorldEventButtonData
    local param = {iconName = "sp_comp_icon_worldevent", expeditionInfo = expeditionInfo, radarTaskData = customData, uiPos = bubbleGo.transform.localPosition}
    param.isAlliance = isAlliance
    behavior:OnFeedData(param)
    -- bubbleGo.name = uniqueId
    bubbleGo:SetVisible(true)

    local x, z = KingdomMapUtils.ParseBuildingPos(customData.Pos)
    local boardData = self:SetBoardData(uniqueId, x, z)
    if boardData.result then
        self:UpdateBubbleUIPosCache(boardData, uniqueId, bubbleGo, behavior, true)
        bubbleGo.transform.localPosition = boardData.arrowPos
        -- bubbleGo.name = uniqueId
        bubbleGo:SetVisible(true)
        if isAlliance then
            self.allianceBubbleList[uniqueId] = bubbleGo
        else
            self.radarBubbleList[uniqueId] = bubbleGo
        end
    end
end

function RadarModule:LoadRadarTaskBubble(customData, uniqueId, parentTrans, item, isActive)
    isActive = isActive or false
    local cfg = ConfigRefer.RadarTask:Find(customData.RadarTaskId)
    if ModuleRefer.RadarModule:GetRadarEventLock() then
        local isSpecial = cfg:IsSpecial()
        if isSpecial then
            self:SetSpecialTaskId(uniqueId)
        end
    end

    local x, z = KingdomMapUtils.ParseBuildingPos(customData.Pos)
    local isCityRadar = self:GetCityRadarTask(customData.EntityTid)
    local boardData = self:SetBoardData(uniqueId, x, z, isCityRadar)
    if boardData.result then
        local btnComp = UIHelper.DuplicateUIComponent(item, parentTrans)
        if not btnComp then
            return
        end

        if self:IsEliteRadarTask(customData.ID) then
            local spriteTrans = btnComp.gameObject.transform:Find("p_rotation/p_position/p_icon_status")
            if Utils.IsNotNull(spriteTrans) then
                spriteTrans.gameObject:SetVisible(false)
            end
            local frameTrans = btnComp.gameObject.transform:Find("p_rotation/p_position/p_frame")
            if Utils.IsNotNull(frameTrans) then
                frameTrans.gameObject:SetVisible(false)
            end
            local spriteIconTrans = btnComp.gameObject.transform:Find("p_rotation/p_position/p_icon_status_1")
            if Utils.IsNotNull(spriteIconTrans) then
                spriteIconTrans.gameObject:SetVisible(true)
            end
            btnComp.Lua:SetRadarTaskType(RADARTASK_TYPE.elite)
            btnComp.gameObject:SetVisible(false)
            customData.Type = 0
        else
            btnComp.gameObject:SetVisible(isActive)
            customData.Type = 0
        end
        self:UpdateBubbleUIPosCache(boardData, uniqueId, btnComp.gameObject, btnComp.Lua, false)
        btnComp.gameObject.transform.localPosition = boardData.arrowPos
        -- btnComp.gameObject.name = uniqueId
        btnComp.Lua:OnFeedData({customData = customData, uiPos = boardData.arrowPos})
        self.radarTaskBubbleList[uniqueId] = btnComp.gameObject
    end

    if (cfg:IsManual() or cfg:IsElite()) and self:GetManualRadarTaskLock() then
        local targets = self:GetManualRadarTasks()
        for i = 1, #targets do
            if targets[i] == customData.RadarTaskId then
                self:SetManualRadarTaskBubble(uniqueId)
                break
            end
        end
    end
end

function RadarModule:RefreshRadarTaskBubble(customData, bubbleGo, uniqueId, parentTrans)
    local isActive = true
    bubbleGo:SetVisible(isActive)
    local behavior = nil
    behavior = bubbleGo:GetComponent(typeof(CS.DragonReborn.UI.LuaBaseComponent)).Lua
    customData.Type = 0
    behavior:OnFeedData({customData = customData, uiPos = bubbleGo.transform.localPosition})
    local x, z = KingdomMapUtils.ParseBuildingPos(customData.Pos)
    local boardData = self:SetBoardData(uniqueId, x, z)
    if boardData.result then
        self:UpdateBubbleUIPosCache(boardData, uniqueId, bubbleGo, behavior, false)
        bubbleGo.transform.localPosition = boardData.arrowPos
        -- bubbleGo.name = uniqueId
        bubbleGo:SetVisible(isActive)
        self.radarTaskBubbleList[uniqueId] = bubbleGo
    end
end

function RadarModule:LoadMistTaskBubble(iconName, customData, uniqueId, parentTrans, item, isActive)
    isActive = isActive or false
    local x, z = KingdomMapUtils.ParseBuildingPos(customData.Pos)
    local boardData = self:SetBoardData(uniqueId, x, z)
    if boardData.result then
        local btnComp = UIHelper.DuplicateUIComponent(item, parentTrans)
        if not btnComp then
            return
        end
        if self:IsCreepRadarTask(customData.EntityId) then
            if self:IsCreepNormalRadarTask(customData.EntityId) then
                btnComp.Lua:SetRadarTaskType(RADARTASK_TYPE.creepNormal)
                customData.Type = 3
            else
                btnComp.Lua:SetRadarTaskType(RADARTASK_TYPE.creepUnlock)
                customData.Type = 4
            end
            btnComp.gameObject:SetVisible(isActive)
        else
            btnComp.gameObject:SetVisible(isActive)
            customData.Type = 2
        end
        self:UpdateBubbleUIPosCache(boardData, uniqueId, btnComp.gameObject, btnComp.Lua, false)
        btnComp.gameObject.transform.localPosition = boardData.arrowPos
        -- btnComp.gameObject.name = uniqueId
        btnComp.gameObject:SetVisible(isActive)
        btnComp.Lua:OnFeedData({iconName = iconName, customData = customData, uiPos = boardData.arrowPos})
        self.mistTaskBubbleList[uniqueId] = btnComp.gameObject
    end
end

function RadarModule:RefreshMistTaskBubble(icon, customData, bubbleGo, uniqueId, parentTrans)
    bubbleGo:SetVisible(true)
    local behavior = nil
    local spriteTrans = bubbleGo.transform:Find("p_rotation/p_position/p_icon_status")
    if Utils.IsNotNull(spriteTrans) then
        local renderer = spriteTrans:GetComponent(typeof(CS.U2DSpriteMesh))
        if Utils.IsNotNull(renderer) then
            g_Game.SpriteManager:LoadSprite(icon, renderer)
        end
        behavior = bubbleGo:GetComponent(typeof(CS.DragonReborn.UI.LuaBaseComponent)).Lua
        if self:IsCreepRadarTask(customData.EntityId) then
            if self:IsCreepNormalRadarTask(customData.EntityId) then
                behavior:SetRadarTaskType(RADARTASK_TYPE.creepNormal)
                customData.Type = 3
            else
                behavior:SetRadarTaskType(RADARTASK_TYPE.creepUnlock)
                customData.Type = 4
            end
        else
            customData.Type = 2
        end
        behavior:OnFeedData({iconName = icon, customData = customData, uiPos = bubbleGo.transform.localPosition})
    end
    local x, z = KingdomMapUtils.ParseBuildingPos(customData.Pos)
    local boardData = self:SetBoardData(uniqueId, x, z)
    if boardData.result then
        self:UpdateBubbleUIPosCache(boardData, uniqueId, bubbleGo, behavior, false)
        bubbleGo.transform.localPosition = boardData.arrowPos
        -- bubbleGo.name = uniqueId
        bubbleGo:SetVisible(true)
        self.mistTaskBubbleList[uniqueId] = bubbleGo
    end
end

function RadarModule:HideRadarTaskByID(uniqueId)
    if not self.radarTaskBubbleList then
        return false
    end
    local isDeleteSuccess = false
    for id, bubbleGo in pairs(self.radarTaskBubbleList) do
        if id == uniqueId and Utils.IsNotNull(bubbleGo) then
            local pos = bubbleGo.transform.localPosition
            RadarTaskUtils.DeleteRadarTaskBtnByWorldPos(pos.x, pos.y)
            self:RemoveUniqueId(uniqueId)
            local behavior = bubbleGo:GetComponent(typeof(CS.DragonReborn.UI.LuaBaseComponent)).Lua
            if behavior then
                local radarTaskConfig = ConfigRefer.RadarTask:Find(behavior:GetRadarTaskID())
                if radarTaskConfig and not radarTaskConfig:IgnoreLimitByMaxCount() then
                    self.curShowRadarTaskCount = self.curShowRadarTaskCount - 1
                end
            end
            bubbleGo:SetVisible(false)
            self.radarTaskBubbleList[uniqueId] = nil
            self:DeleteUIPosCache(uniqueId)
            -- CS.UnityEngine.Object.Destroy(bubbleGo)
            isDeleteSuccess = true
            break
        end
    end
    if isDeleteSuccess and self.curShowRadarTaskCount < ConfigRefer.ConstBigWorld:MaxRadarTaskShowCount() then
        local radarMediator = g_Game.UIManager:FindUIMediatorByName(UIMediatorNames.RadarMediator)
        if radarMediator then
            self:LoadRadarTask(radarMediator.goBubbleBtnParent.transform, radarMediator.goRadarTaskItem, true)
        end
    end
    return isDeleteSuccess
end

function RadarModule:HideWorldEventByID(uniqueId)
    if not self.radarBubbleList then
        return false
    end
    for id, bubbleGo in pairs(self.radarBubbleList) do
        if id == uniqueId and Utils.IsNotNull(bubbleGo) then
            local pos = bubbleGo.transform.localPosition
            RadarTaskUtils.DeleteRadarTaskBtnByWorldPos(pos.x, pos.y)
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
            self.radarBubbleList[uniqueId] = nil
            self:DeleteUIPosCache(uniqueId)
            -- CS.UnityEngine.Object.Destroy(bubbleGo)
            return true
        end
    end
end

function RadarModule:HideAllianceWorldEventByID(uniqueId)
    if not self.allianceBubbleList then
        return false
    end
    for id, bubbleGo in pairs(self.allianceBubbleList) do
        if id == uniqueId and Utils.IsNotNull(bubbleGo) then
            local pos = bubbleGo.transform.localPosition
            RadarTaskUtils.DeleteRadarTaskBtnByWorldPos(pos.x, pos.y)
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
            self.allianceBubbleList[uniqueId] = nil
            self:DeleteUIPosCache(uniqueId)
            -- CS.UnityEngine.Object.Destroy(bubbleGo)
            return true
        end
    end
end

function RadarModule:HideMistTaskByID(uniqueId)
    if not self.mistTaskBubbleList then
        return false
    end
    local isDeleteSuccess = false
    for id, bubbleGo in pairs(self.mistTaskBubbleList) do
        if id == uniqueId and Utils.IsNotNull(bubbleGo) then
            local pos = bubbleGo.transform.localPosition
            RadarTaskUtils.DeleteRadarTaskBtnByWorldPos(pos.x, pos.y)
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
            self.mistTaskBubbleList[uniqueId] = nil
            self:DeleteUIPosCache(uniqueId)
            -- CS.UnityEngine.Object.Destroy(bubbleGo)
            isDeleteSuccess = true
            break
        end
    end

    if isDeleteSuccess and self:GetTableCount(self.mistTaskBubbleList) < ConfigRefer.ConstBigWorld:MistTaskMaxCount() then
        local radarMediator = g_Game.UIManager:FindUIMediatorByName(UIMediatorNames.RadarMediator)
        if radarMediator then
            self:LoadMistRadarTask(radarMediator.goBubbleBtnParent.transform, radarMediator.goRadarTaskItem, true)
        end
    end
    return isDeleteSuccess
end

function RadarModule:HideRadarTaskBtn(uniqueId)
    if self:HideRadarTaskByID(uniqueId) then
        return
    end
    if self:HideWorldEventByID(uniqueId) then
        return
    end
    if self:HideMistTaskByID(uniqueId) then
        return
    end
    if self:HideAllianceWorldEventByID(uniqueId) then
        return
    end
end

function RadarModule:DeleteUIPosCache(uniqueId)
    if not self.bubbleUIPosCache then
        return
    end
    for k, v in pairs(self.bubbleUIPosCache) do
        if uniqueId == k and self.bubbleUIPosCache[uniqueId] then
            self.bubbleUIPosCache[uniqueId] = nil
        end
    end
end

function RadarModule:ClearUIPosCache()
    if not self.bubbleUIPosCache then
        return
    end
    for k, v in pairs(self.bubbleUIPosCache) do
        UIHelper.DeleteUIGameObject(self.bubbleUIPosCache[k].go)
        self.bubbleUIPosCache[k] = nil
    end
    self.bubbleUIPosCache = {}
end

function RadarModule:HideCreepTaskByID(uniqueId)
    if not self.creepBubbleList then
        return
    end
    for id, bubbleGo in pairs(self.creepBubbleList) do
        if id == uniqueId and Utils.IsNotNull(bubbleGo) then
            local pos = bubbleGo.transform.localPosition
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
            self.creepBubbleList[uniqueId] = nil
            return
        end
    end
end

function RadarModule:GetRadarTaskArrowPos(x, z, isCityRadar)
    if isCityRadar then
        local arrowPos = Vector3.zero
        arrowPos.x = (x - 128)
        arrowPos.y = (z - 128)
        return arrowPos
    end

    local myCityCoord = ModuleRefer.PlayerModule:GetCastle().MapBasics.Position
    local arrowPos = Vector3.zero
    local radarInfo = ModuleRefer.RadarModule:GetRadarInfo()
    local curLv = self:GetRadarLv()
    local curCfg = ConfigRefer.RadarLevel:Find(curLv)
    local maxDix = curCfg:HighQualityExpeditionRadius()
    arrowPos.x = (x - myCityCoord.X) / maxDix * 635
    arrowPos.y = (z - myCityCoord.Y) / maxDix * 340
    return arrowPos
end

function RadarModule:GetWorldPos(X, Y)
    local staticMapData = KingdomMapUtils.GetStaticMapData()
    local x = X * staticMapData.UnitsPerTileX
    local z = Y * staticMapData.UnitsPerTileZ
    return Vector3(x, 0, z)
end

function RadarModule:ClearLastRefreshRecord()
    self.lastRefreshRecrod = {}
end

function RadarModule:AddUniqueId(uniqueId)
    self.lastRefreshRecrod[uniqueId] = true
end

function RadarModule:RemoveUniqueId(uniqueId)
    self.lastRefreshRecrod[uniqueId] = false
end

function RadarModule:CheckIsRefreshed(uniqueId)
    return self.lastRefreshRecrod[uniqueId]
end

function RadarModule:GetChangeTables(filterInfo)
    local refreshedList = {}
    local addList = {}
    for _, singleInfo in pairs(filterInfo) do
        if self:CheckIsRefreshed(singleInfo.EntityID) then
            refreshedList[singleInfo.EntityID] = true
        else
            addList[singleInfo.EntityID] = singleInfo
        end
    end
    return refreshedList, addList
end

function RadarModule:GetCanAwardExpeditionsChangeTables(filterInfo)
    local refreshedList = {}
    local addList = {}
    for entityID, singleInfo in pairs(filterInfo) do
        if self:CheckIsRefreshed(entityID) then
            refreshedList[entityID] = true
        else
            addList[entityID] = singleInfo
        end
    end
    return refreshedList, addList
end

function RadarModule:LoadBubbleByType(filterType, result, parentTrans, item)
    local isResourceField = filterType == wrpc.RadarEntityType.RadarEntityType_ResourceField
    local isCreep = filterType == wrpc.RadarEntityType.RadarEntityType_Creep
    local isLightHouse = filterType == wrpc.RadarEntityType.RadarEntityType_Lighthouse
    if filterType == wrpc.RadarEntityType.RadarEntityType_Expedition then
        self:HideBubbleByType(false, true, true, false, false)
        self:RadarBrachFresh(result, parentTrans, item)
    elseif isResourceField or isCreep or isLightHouse then
        self:HideBubbleByType(true, false, true, true, true)
        self:WorldOtherBrachFresh(filterType, result)
    end
end

function RadarModule:RadarBrachFresh(result, parentTrans, item)
    local filterInfo = result.Expeditions
    local refreshedList, addList = self:GetChangeTables(filterInfo)
    local recycleBubbles = {}
    -- for uniqueId, bubbleGo in pairs(self.radarBubbleList) do
    --     if not refreshedList[uniqueId] then
    --         recycleBubbles[#recycleBubbles + 1] = uniqueId
    --         self:RemoveUniqueId(uniqueId)
    --         bubbleGo:SetVisible(false)
    --     else
    --         bubbleGo:SetVisible(true)
    --     end
    -- end
    local addCount = 0
    for _, singleInfo in pairs(addList) do
        if self:CheckIsInMist(singleInfo.X, singleInfo.Y) then
            local progress = singleInfo.PersonalProgress
            local config = ConfigRefer.WorldExpeditionTemplate:Find(singleInfo.CfgId)
            if progress < config:MaxProgress() then
                singleInfo.ID = singleInfo.EntityID
                singleInfo.Tid = singleInfo.CfgId
                addCount = addCount + 1
                local recycleUniqueId = recycleBubbles[addCount]
                if recycleUniqueId then
                    local oldGo = self.radarBubbleList[singleInfo.EntityID]
                    if oldGo then
                        self:RefreshExpeditionBubble(singleInfo, oldGo, singleInfo.EntityID, parentTrans)
                    else
                        local bubbleGo = self.radarBubbleList[recycleUniqueId]
                        self.radarBubbleList[recycleUniqueId] = nil
                        self:RefreshExpeditionBubble(singleInfo, bubbleGo, singleInfo.EntityID, parentTrans)
                    end
                else
                    self:LoadExpeditionBubble(singleInfo, singleInfo.EntityID, parentTrans, item)
                end
                self:AddUniqueId(singleInfo.EntityID)
            end
        end
    end

    -- 可领奖世界事件
    filterInfo = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.PlayerExpeditions.CanReceiveRewardExpeditions
    refreshedList, addList = self:GetCanAwardExpeditionsChangeTables(filterInfo)
    -- recycleBubbles = {}
    -- for uniqueId, bubbleGo in pairs(self.radarBubbleList) do
    --     if not refreshedList[uniqueId] then
    --         recycleBubbles[#recycleBubbles + 1] = uniqueId
    --         self:RemoveUniqueId(uniqueId)
    --         bubbleGo:SetVisible(false)
    --     else
    --         bubbleGo:SetVisible(true)
    --     end
    -- end
    addCount = 0
    for entityID, singleInfo in pairs(addList) do
        if self:CheckIsInMist(singleInfo.BuildingPos.X, singleInfo.BuildingPos.Y) then
            local expeditionInfo = {}
            expeditionInfo.PersonalProgress = singleInfo.PersonalProgress
            expeditionInfo.X = singleInfo.BuildingPos.X
            expeditionInfo.Y = singleInfo.BuildingPos.Y
            expeditionInfo.CfgId = singleInfo.ExpeditionInstanceTid
            expeditionInfo.EntityID = entityID
            expeditionInfo.Quality = singleInfo.Quality
            expeditionInfo.ActivateEndTime = singleInfo.EndTime
            local progress = singleInfo.PersonalProgress
            local config = ConfigRefer.WorldExpeditionTemplate:Find(expeditionInfo.CfgId)
            if progress <= config:MaxProgress() then
                -- addCount = addCount + 1
                local recycleUniqueId = recycleBubbles[addCount]
                if recycleUniqueId then
                    local oldGo = self.radarBubbleList[entityID]
                    if oldGo then
                        self:RefreshExpeditionBubble(expeditionInfo, oldGo, entityID, parentTrans)
                    else
                        local bubbleGo = self.radarBubbleList[recycleUniqueId]
                        self.radarBubbleList[recycleUniqueId] = nil
                        self:RefreshExpeditionBubble(expeditionInfo, bubbleGo, entityID, parentTrans)
                    end
                else
                    self:LoadExpeditionBubble(expeditionInfo, entityID, parentTrans, item)
                end
                self:AddUniqueId(entityID)
            end
        end
    end

end

function RadarModule:WorldOtherBrachFresh(filterType, result)
    local filterInfo
    local isResourceField = filterType == wrpc.RadarEntityType.RadarEntityType_ResourceField
    local isCreep = filterType == wrpc.RadarEntityType.RadarEntityType_Creep
    local isLightHouse = filterType == wrpc.RadarEntityType.RadarEntityType_Lighthouse
    if isResourceField then
        filterInfo = result.ResourceFields
    elseif isCreep then
        filterInfo = result.SlgCreepTumors
    elseif isLightHouse then
        filterInfo = result.LightHouses
    end
    local refreshedList, addList = self:GetChangeTables(filterInfo)
    local recycleBubbles = {}
    for uniqueId, bubbleGo in pairs(self.bubbleList) do
        if not refreshedList[uniqueId] then
            recycleBubbles[#recycleBubbles + 1] = uniqueId
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
        else
            bubbleGo:SetVisible(true)
        end
    end
    local addCount = 0
    for _, singleInfo in pairs(addList) do
        if self:CheckIsInMist(singleInfo.X, singleInfo.Y) or isLightHouse then
            addCount = addCount + 1
            self:AddUniqueId(singleInfo.EntityID)

            local pos = self:GetWorldPos(singleInfo.X, singleInfo.Y)
            local tile
            local lv
            local image
            if isResourceField or isCreep then
                tile = KingdomMapUtils.RetrieveMap(singleInfo.X, singleInfo.Y)
            end
            if isResourceField then
                local cfg = ConfigRefer.FixedMapBuilding:Find(singleInfo.CfgId)
                lv = cfg:Level()
                image = cfg:BubbleImage()
            elseif isCreep then
                local cfg = ConfigRefer.SlgCreepTumor:Find(singleInfo.CfgId)
                lv = cfg:Level()
                image = "sp_icon_leida_juntan_s"
            elseif isLightHouse then
                image = "sp_icon_leida_dengta_s"
            end
            local customData = {worldPos = pos, singleInfo = singleInfo, lv = lv, tile = tile}
            local recycleUniqueId = recycleBubbles[addCount]
            if recycleUniqueId then
                local oldGo = self.bubbleList[singleInfo.EntityID]
                if oldGo then
                    self:RefreshBubble(image, pos, customData, oldGo, filterType, singleInfo.EntityID)
                else
                    local bubbleGo = self.bubbleList[recycleUniqueId]
                    self.bubbleList[recycleUniqueId] = nil
                    self:RefreshBubble(image, pos, customData, bubbleGo, filterType, singleInfo.EntityID)
                end
            else
                self:LoadBubble(image, pos, filterType, customData, singleInfo.EntityID)
            end
        end
    end
end

function RadarModule:LoadPet()
    local petList = ModuleRefer.PetModule:GetWorldPetList()
    local filterType = wrpc.RadarEntityType.RadarEntityType_Pet
    local refreshedList, addList = self:GetPetChangeTables(petList)
    self:HideBubbleByType(true, false, true, true, true)
    local recycleBubbles = {}
    for uniqueId, bubbleGo in pairs(self.bubbleList) do
        if not refreshedList[uniqueId] then
            recycleBubbles[#recycleBubbles + 1] = uniqueId
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
        else
            bubbleGo:SetVisible(true)
        end
    end
    local addCount = 0
    for _, pdata in pairs(addList) do
        addCount = addCount + 1
        self:AddUniqueId(pdata.id)
        local petId = ConfigRefer.PetWild:Find(pdata.data.ConfigId):PetId()
        local image = ArtResourceUtils.GetUIItem(ConfigRefer.Pet:Find(petId):Icon())
        local recycleUniqueId = recycleBubbles[addCount]
        if recycleUniqueId then
            local oldGo = self.bubbleList[pdata.id]
            if oldGo then
                self:RefreshBubble(image, pdata.worldPos, pdata, oldGo, filterType, pdata.uniqueName)
            else
                local bubbleGo = self.bubbleList[recycleUniqueId]
                self.bubbleList[recycleUniqueId] = nil
                self:RefreshBubble(image, pdata.worldPos, pdata, bubbleGo, filterType, pdata.uniqueName)
            end
        else
            self:LoadBubble(image, pdata.worldPos, filterType, pdata, pdata.uniqueName)
        end
    end
end

function RadarModule:GetPetChangeTables(petList)
    local refreshedList = {}
    local addList = {}
    for _, pdata in pairs(petList) do
        if self:CheckIsRefreshed(pdata.uniqueName) then
            refreshedList[pdata.uniqueName] = true
        else
            addList[pdata.uniqueName] = pdata
        end
    end
    return refreshedList, addList
end

function RadarModule:RefreshRadarTask()
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    local tempRadarTaskList = {}
    self.radarTaskCount = 0
    for k, v in pairs(radarTaskList) do
        -- 内城雷达任务
        if v.EntityType == ObjectType.SeElementData then
            self:SetCityRadarTasks(v)
            -- 提前过滤掉不合法的任务数据
        elseif v.State == wds.RadarTaskState.RadarTaskState_Received and v.EntityId == 0 then
            goto continueNext
        end
        self.radarTaskCount = self.radarTaskCount + 1
        table.insert(tempRadarTaskList, v)
        ::continueNext::
    end
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for k, v in pairs(eliteTaskList) do
        -- 提前过滤掉不合法的任务数据
        if v.EntityType == ObjectType.SeElementData then
            self:SetCityRadarTasks(v)
        elseif v.State == wds.RadarTaskState.RadarTaskState_Received and v.EntityId == 0 or v.EntityType == ObjectType.SlgExpedition then
            goto continueNextElite
        end
        self.radarTaskCount = self.radarTaskCount + 1
        table.insert(tempRadarTaskList, v)
        ::continueNextElite::
    end
    return tempRadarTaskList
end

function RadarModule:LoadRadarTask(parentTrans, item, isActive, isClearBoard)
    isActive = isActive or false
    isClearBoard = isClearBoard or false

    -- self:ClearRadarTaskBubbleList()
    if isClearBoard then
        RadarTaskUtils.ClearRadarTaskBtnPosBoard()
    end
    local tempRadarTaskList = self:RefreshRadarTask()
    local refreshedList, addList = self:GetRadarTaskChangeTables(tempRadarTaskList)
    self:HideBubbleByType(false, true, true, false, false)
    local recycleBubbles = {}
    for uniqueId, bubbleGo in pairs(self.radarTaskBubbleList) do
        if not refreshedList[uniqueId] then
            recycleBubbles[#recycleBubbles + 1] = uniqueId
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
        else
            local behavior = bubbleGo:GetComponent(typeof(CS.DragonReborn.UI.LuaBaseComponent)).Lua
            if behavior then
                behavior:RefreshData(refreshedList[uniqueId])
            end
            bubbleGo:SetVisible(isActive)
        end
    end
    local addCount = 0
    for _, taskData in pairs(addList) do
        local radarTaskInfo = ConfigRefer.RadarTask:Find(taskData.RadarTaskId)
        if not radarTaskInfo then
            goto continue
        end

        if taskData.State ~= wds.RadarTaskState.RadarTaskState_CanReceiveReward then
            if not radarTaskInfo:IgnoreLimitByMaxCount() then
                if self.curShowRadarTaskCount >= ConfigRefer.ConstBigWorld:MaxRadarTaskShowCount() then
                    goto continue
                end
                self.curShowRadarTaskCount = self.curShowRadarTaskCount + 1
            end
        end

        addCount = addCount + 1
        self:AddUniqueId(taskData.ID)
        local recycleUniqueId = recycleBubbles[addCount]

        if recycleUniqueId then
            local oldGo = self.radarTaskBubbleList[taskData.ID]
            if oldGo then
                self:RefreshRadarTaskBubble(taskData, oldGo, taskData.ID, parentTrans)
            else
                self:LoadRadarTaskBubble(taskData, taskData.ID, parentTrans, item, isActive)
            end
        else
            self:LoadRadarTaskBubble(taskData, taskData.ID, parentTrans, item, isActive)
        end
        ::continue::
    end

    self:LoadMistRadarTask(parentTrans, item, isActive)
end

function RadarModule:SetSpecialTaskId(id)
    self.specialTaskId = id
end

function RadarModule:GetSpecialTaskId(id)
    return self.specialTaskId
end

function RadarModule:GetSpecialTaskObj()
    return self.radarTaskBubbleList[self.specialTaskId]
end

function RadarModule:GetRadarTaskChangeTables(radarTaskList)
    local refreshedList = {}
    local addList = {}
    for _, taskData in pairs(radarTaskList) do
        if self:CheckIsRefreshed(taskData.ID) then
            refreshedList[taskData.ID] = taskData
        else
            addList[taskData.ID] = taskData
        end
    end
    return refreshedList, addList
end

function RadarModule:GetMistTaskChangeTables(mistTaskList)
    local refreshedList = {}
    local addList = {}
    for i = 1, #mistTaskList do
        if self:CheckIsRefreshed(mistTaskList[i].ID) then
            refreshedList[mistTaskList[i].ID] = true
        else
            table.insert(addList, mistTaskList[i])
        end
    end
    return refreshedList, addList
end

function RadarModule:GetCreepTaskChangeTables(creepList)
    local refreshedList = {}
    local addList = {}
    for _, creepData in pairs(creepList) do
        if self:CheckIsRefreshed(creepData.ID) then
            refreshedList[creepData.ID] = true
        else
            addList[creepData.ID] = creepData
        end
    end
    return refreshedList, addList
end

function RadarModule:GetAllianceTaskChangeTables(allianceExpeditionMap)
    local refreshedList = {}
    local addList = {}
    local target = ModuleRefer.WorldEventModule:GetPersonalOwnAllianceExpedition()
    local player = ModuleRefer.PlayerModule:GetPlayer()
    for _, v in pairs(allianceExpeditionMap) do
        if v.Progress ~= 100 and v.ConfigId == target and v.CreatePlayerId == player.ID then
            local taskData = self:CreateTaskDataByAllianceExpeditionData(v)
            if self:CheckIsRefreshed(v.ExpeditionEntityId) then
                refreshedList[v.ExpeditionEntityId] = taskData
            else
                addList[v.ExpeditionEntityId] = taskData
            end
        end
    end
    return refreshedList, addList
end

function RadarModule:LoadWorldEvent(parentTrans, item, isActive)
    isActive = isActive or false
    local eliteTaskList = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.EliteTasks
    local tempEliteTaskList = {}
    for k, v in pairs(eliteTaskList) do
        if v.EntityType == ObjectType.SlgExpedition then
            table.insert(tempEliteTaskList, v)
        end
    end
    local refreshedList, addList = self:GetRadarTaskChangeTables(tempEliteTaskList)
    self:HideBubbleByType(false, true, true, false, false)
    local recycleBubbles = {}
    for uniqueId, bubbleGo in pairs(self.radarBubbleList) do
        if not refreshedList[uniqueId] then
            recycleBubbles[#recycleBubbles + 1] = uniqueId
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
        else
            local behavior = bubbleGo:GetComponent(typeof(CS.DragonReborn.UI.LuaBaseComponent)).Lua
            if behavior then
                if refreshedList[uniqueId].EntityType == ObjectType.SlgExpedition then
                    local expeditionInfo = self:CreateExpeditionInfoByRadarTaskData(refreshedList[uniqueId])
                    behavior:RefreshData(expeditionInfo, refreshedList[uniqueId])
                else
                    behavior:RefreshData(refreshedList[uniqueId])
                end
            end
            bubbleGo:SetVisible(true)
        end
    end
    local addCount = 0
    for _, taskData in pairs(addList) do
        if addCount == 0 then
            self.newAddWorldEventInfo = taskData
        end
        addCount = addCount + 1
        self:AddUniqueId(taskData.ID)
        local recycleUniqueId = recycleBubbles[addCount]
        if recycleUniqueId then
            local oldGo = self.radarBubbleList[taskData.ID]
            if oldGo then
                self:RefreshExpeditionBubble(taskData, oldGo, taskData.ID)
            else
                self:LoadExpeditionBubble(taskData, taskData.ID, parentTrans, item, isActive)
            end
        else
            self:LoadExpeditionBubble(taskData, taskData.ID, parentTrans, item, isActive)
        end
    end
end

function RadarModule:LoadMistRadarTask(parentTrans, item, isActive)
    local mistTaskList = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.MistTasks
    local tempMistTaskList = {}
    for k, v in pairs(mistTaskList) do
        if self:IsCanShowMistTask(v) then
            table.insert(tempMistTaskList, v)
        end
    end
    -- 可领奖，距离近的优先
    local myCityCoord = ModuleRefer.PlayerModule:GetCastle().MapBasics.Position
    table.sort(tempMistTaskList, function(a, b)
        if a.State ~= b.State then
            return a.State > b.State
        end
        local distanceA = Vector2.Distance(Vector2(myCityCoord.X, myCityCoord.Y), Vector2(a.Pos.X, a.Pos.Y))
        local distanceB = Vector2.Distance(Vector2(myCityCoord.X, myCityCoord.Y), Vector2(b.Pos.X, b.Pos.Y))
        return distanceA < distanceB
    end)
    local refreshedList, addList = self:GetMistTaskChangeTables(tempMistTaskList)
    self:HideBubbleByType(false, true, true, false, false)
    local recycleBubbles = {}
    for uniqueId, bubbleGo in pairs(self.mistTaskBubbleList) do
        if not refreshedList[uniqueId] then
            recycleBubbles[#recycleBubbles + 1] = uniqueId
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
        else
            bubbleGo:SetVisible(true)
        end
    end
    local addCount = 0
    for _, taskData in pairs(addList) do
        -- 迷雾任务显示不能超过上限
        if self:GetTableCount(self.mistTaskBubbleList) >= ConfigRefer.ConstBigWorld:MistTaskMaxCount() then
            return
        end
        addCount = addCount + 1
        self:AddUniqueId(taskData.ID)
        local radarTaskConfig = ConfigRefer.RadarTask:Find(taskData.RadarTaskId)
        local iconName = "sp_icon_reward"
        if radarTaskConfig then
            iconName = radarTaskConfig:RadarTaskIcon()
        end
        local recycleUniqueId = recycleBubbles[addCount]
        if recycleUniqueId then
            local oldGo = self.mistTaskBubbleList[taskData.ID]
            if oldGo then
                self:RefreshMistTaskBubble(iconName, taskData, oldGo, taskData.ID, parentTrans)
            else
                self:LoadMistTaskBubble(iconName, taskData, taskData.ID, parentTrans, item, isActive)
            end
        else
            self:LoadMistTaskBubble(iconName, taskData, taskData.ID, parentTrans, item, isActive)
        end
    end
end

---@return wds.AllianceExpedition
function RadarModule:GetAllianceExpeditionInfo()
    ---@type wds.Alliance
    local allianceInfo = ModuleRefer.AllianceModule:GetMyAllianceData()
    if not allianceInfo then
        return nil
    end
    return allianceInfo.AllianceWrapper.AllianceExpedition
end

function RadarModule:LoadAllianceRadarTask(parentTrans, item, isActive)
    isActive = isActive or false
    local allianceExpeditionInfo = self:GetAllianceExpeditionInfo()
    if not allianceExpeditionInfo then
        return
    end
    local refreshedList, addList = self:GetAllianceTaskChangeTables(allianceExpeditionInfo.Expeditions)
    self:HideBubbleByType(false, true, true, false, false)
    local recycleBubbles = {}
    for uniqueId, bubbleGo in pairs(self.allianceBubbleList) do
        if not refreshedList[uniqueId] then
            recycleBubbles[#recycleBubbles + 1] = uniqueId
            self:RemoveUniqueId(uniqueId)
            bubbleGo:SetVisible(false)
        else
            local behavior = bubbleGo:GetComponent(typeof(CS.DragonReborn.UI.LuaBaseComponent)).Lua
            if behavior then
                local expeditionInfo = self:CreateExpeditionInfoByRadarTaskData(refreshedList[uniqueId], true)
                behavior:RefreshData(expeditionInfo, refreshedList[uniqueId])
            end
            bubbleGo:SetVisible(true)
        end
    end
    local addCount = 0
    for _, taskData in pairs(addList) do
        addCount = addCount + 1
        self:AddUniqueId(taskData.EntityId)
        local recycleUniqueId = recycleBubbles[addCount]
        if recycleUniqueId then
            local oldGo = self.allianceBubbleList[taskData.EntityId]
            if oldGo then
                self:RefreshExpeditionBubble(taskData, oldGo, taskData.EntityId, true)
            else
                self:LoadExpeditionBubble(taskData, taskData.EntityId, parentTrans, item, isActive, true)
            end
        else
            self:LoadExpeditionBubble(taskData, taskData.EntityId, parentTrans, item, isActive, true)
        end
    end
end

function RadarModule:IsCanUpgradeRadar()
    local info = ModuleRefer.PlayerModule:GetCastleBuildingInfoByType(BuildingType.Radar)
    if not info then
        return false
    end
    local lvCell = ModuleRefer.CityConstructionModule:GetBuildingLevelConfigCellByTypeId(info.BuildingType, info.Level)
    local nextLvCell = ConfigRefer.BuildingLevel:Find(lvCell:NextLevel())
    local status = ModuleRefer.CityConstructionModule:GetBuildingLevelState(nextLvCell, true)
    local flag = status == CityConstructState.CanBuild and CityUtils.IsStatusReady(info.Status) and not info.Polluted
    return flag
end

function RadarModule:InitCityBubble(icon, pos, bubbleType, index)
    if self.cityBubbleList[bubbleType] and self.cityBubbleList[bubbleType][index] then
        self:RefreshCityBubble(ArtResourceUtils.GetUIItem(icon), pos, {worldPos = pos, inCity = true}, self.cityBubbleList[bubbleType][index], bubbleType)
    else
        self:LoadCityBubble(ArtResourceUtils.GetUIItem(icon), pos, bubbleType, {worldPos = pos, inCity = true})
    end
end

function RadarModule:RefreshBubbleState(showCount, filterType)
    for i = 1, #(self.cityBubbleList[filterType] or {}) do
        self.cityBubbleList[filterType][i]:SetVisible(showCount >= i)
    end
    self.showCount = showCount
end

function RadarModule:FilterCityBubble()
    for type, bubbles in pairs(self.cityBubbleList) do
        local isShow = type == ModuleRefer.WorldEventModule:GetFilterType()
        for index, bubbleGo in ipairs((bubbles)) do
            if (Utils.IsNotNull(bubbleGo)) then
                bubbleGo:SetVisible(isShow and index <= self.showCount)
            end
        end
    end
end

function RadarModule:LoadCityBubble(iconName, position, bubbleType, customData)
    -- local parent = KingdomMapUtils.GetMapSystem().Parent
    -- self.createHelper:Create("ui3d_bubble_radar", parent, function(bubbleGo)
    --     if bubbleType then
    --         if not self.cityBubbleList[bubbleType] then
    --             self.cityBubbleList[bubbleType] = {}
    --         end
    --         self.cityBubbleList[bubbleType][#self.cityBubbleList[bubbleType] + 1] = bubbleGo
    --     end
    --     bubbleGo.transform.position = position
    --     local spriteTrans = bubbleGo.transform:Find("p_rotation/p_position/p_icon_status")
    --     if Utils.IsNotNull(spriteTrans) then
    --         local renderer = spriteTrans:GetComponent(typeof(CS.U2DSpriteMesh))
    --         if Utils.IsNotNull(renderer) then
    --             g_Game.SpriteManager:LoadSprite(iconName, renderer)
    --             local frame = bubbleGo.transform:Find("p_rotation/p_position/Frame")
    --             if customData and customData.inCity then
    --                 spriteTrans.transform.localPosition = CS.UnityEngine.Vector3(-1, 2, -0.04)
    --                 frame.transform.localPosition = CS.UnityEngine.Vector3(0, -8, 0)
    --             end
    --         end
    --         if bubbleType then
    --             local behavior = bubbleGo:GetLuaBehaviour("PvETileAsseRadarBubbleBehavior").Instance
    --             behavior:InitEvent(bubbleType, customData)
    --         end
    --     end
    --     self:FilterCityBubble()
    -- end)
end

function RadarModule:RefreshCityBubble(icon, worldPos, customData, bubbleGo, bubbleType)
    bubbleGo.transform.position = worldPos
    local spriteTrans = bubbleGo.transform:Find("p_rotation/p_position/p_icon_status")
    if Utils.IsNotNull(spriteTrans) then
        local renderer = spriteTrans:GetComponent(typeof(CS.U2DSpriteMesh))
        if Utils.IsNotNull(renderer) then
            g_Game.SpriteManager:LoadSprite(icon, renderer)
            local frame = bubbleGo.transform:Find("p_rotation/p_position/Frame")
            if customData and customData.inCity then
                spriteTrans.transform.localPosition = CS.UnityEngine.Vector3(-1, 2, -0.04)
                frame.transform.localPosition = CS.UnityEngine.Vector3(0, -8, 0)
            end
        end
        local behavior = bubbleGo:GetLuaBehaviour("PvETileAsseRadarBubbleBehavior").Instance
        behavior:InitEvent(bubbleType, customData)
    end
    bubbleGo:SetVisible(true)
end

function RadarModule:GetRadarInfo()
    local player = ModuleRefer.PlayerModule:GetPlayer()
    return player.PlayerWrapper2.Radar
end

---@param entityID number
---@return number
function RadarModule:GetRadarTaskQuality(entityID)
    local radar = self:GetRadarInfo()
    local radarTaskList = radar.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if taskData.EntityId == entityID then
            return taskData.Quality
        end
    end
    local mistTaskList = radar.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCreepRadarTask(taskData.EntityId) and self:CheckCreepIsRadarTaskEntity(entityID, taskData.EntityId) then
            return taskData.Quality
        else
            if entityID == taskData.EntityId and entityID ~= 0 and taskData.EntityId ~= 0 then
                return taskData.Quality
            end
        end
    end
    local eliteTaskList = radar.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if taskData.EntityId == entityID then
            return taskData.Quality
        end
    end
end

function RadarModule:GetRandomCanReceiveTaskTrans()
    local player = ModuleRefer.PlayerModule:GetPlayer()
    local radarTaskList = player.PlayerWrapper2.Radar.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if taskData.State == wds.RadarTaskState.RadarTaskState_CanReceiveReward then
            return self:GetBtnTransByID(taskData.ID)
        end
    end
    local expeditions = player.PlayerWrapper2.PlayerExpeditions.CanReceiveRewardExpeditions or {}
    for id, _ in pairs(expeditions) do
        local transform = self:GetBtnTransByID(id)
        if transform then
            return transform
        end
    end
    local eliteTaskList = player.PlayerWrapper2.Radar.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if taskData.State == wds.RadarTaskState.RadarTaskState_CanReceiveReward then
            return self:GetBtnTransByID(taskData.ID)
        end
    end
    return nil
end

function RadarModule:GetBtnTransByID(id)
    if self.radarTaskBubbleList then
        for uniqueId, bubbleGo in pairs(self.radarTaskBubbleList) do
            if uniqueId == id and Utils.IsNotNull(bubbleGo) then
                return bubbleGo.transform
            end
        end
    end

    if self.radarBubbleList then
        for uniqueId, bubbleGo in pairs(self.radarBubbleList) do
            if id == uniqueId and Utils.IsNotNull(bubbleGo) then
                return bubbleGo.transform
            end
        end
    end

    if self.allianceBubbleList then
        for uniqueId, bubbleGo in pairs(self.allianceBubbleList) do
            if id == uniqueId and Utils.IsNotNull(bubbleGo) then
                return bubbleGo.transform
            end
        end
    end
    return nil
end

function RadarModule:GetRadarLv()
    -- local typeID = ConfigRefer.CityConfig:FurnitureTypeRadarLevel()
    -- local city = ModuleRefer.CityModule.myCity
    -- if not city then return 1 end
    -- local furnitureManager = city.furnitureManager
    -- if furnitureManager then
    --     local castleFurniture = furnitureManager:GetMaxLevelFurnitureByTypeInWds(typeID)
    --     if castleFurniture then
    --         local furCfg = ConfigRefer.CityFurnitureLevel:Find(castleFurniture.ConfigId)
    --         return furCfg:Level()
    --     end
    -- end
    local radar = self:GetRadarInfo()
    return radar.RadarLevel
end

---@return wds.RadarTask
function RadarModule:GetRadarTaskInfoByID(id)
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if id == taskData.ID then
            return taskData
        end
    end
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if id == taskData.ID then
            return taskData
        end
    end
    local mistTaskList = radarInfo.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if id == taskData.ID then
            return taskData
        end
    end
    return nil
end

function RadarModule:CheckIsMax()
    local curLv = self:GetRadarLv()
    local maxLv = ConfigRefer.RadarLevel.length
    return curLv >= maxLv
end

function RadarModule:CheckIsInMist(x, y)
    x, y = KingdomMapUtils.ParseCoordinate(x, y)
    return ModuleRefer.MapFogModule:IsFogUnlocked(x, y)
end

function RadarModule:CreateExpeditionInfoByRadarTaskData(radarTaskData, isAlliance)
    isAlliance = isAlliance or false
    ---@type wrpc.RadarScanResultExpedition
    local expeditionInfo = {}
    expeditionInfo.X = radarTaskData.Pos.X
    expeditionInfo.Y = radarTaskData.Pos.Y
    expeditionInfo.CfgId = radarTaskData.EntityTid
    expeditionInfo.Quality = radarTaskData.Quality
    expeditionInfo.EntityID = radarTaskData.EntityId
    local progress = 0
    local joinExpeditions = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.PlayerExpeditions.JoinExpeditions
    for _, info in pairs(joinExpeditions) do
        if info.ExpeditionEntityId == radarTaskData.EntityId then
            local configInfo = ConfigRefer.WorldExpeditionTemplate:Find(info.ExpeditionInstanceTid)
            if configInfo then
                if configInfo:ProgressType() == ProgressType.Personal then
                    progress = info.PersonalProgress
                elseif configInfo:ProgressType() == ProgressType.Alliance then
                    progress = info.Progress
                end
            end
            break
        end
    end
    expeditionInfo.PersonalProgress = progress
    expeditionInfo.ActivateEndTime = radarTaskData.VanishTime.timeSeconds
    if isAlliance then
        expeditionInfo.State = radarTaskData.State
    end
    return expeditionInfo
end

---@param allianceExpeditionData wds.AllianceExpeditionNode
---@return wds.RadarTask
function RadarModule:CreateTaskDataByAllianceExpeditionData(allianceExpeditionData)
    ---@type wds.Expedition
    local entity = g_Game.DatabaseManager:GetEntity(allianceExpeditionData.ExpeditionEntityId, DBEntityType.Expedition)
    if not entity then
        return
    end
    local taskData = wds.RadarTask.New()
    taskData.ID = allianceExpeditionData.ExpeditionEntityId
    taskData.RadarTaskId = allianceExpeditionData.ExpeditionConfigId
    taskData.EntityId = allianceExpeditionData.ExpeditionEntityId
    taskData.EntityType = ObjectType.SlgExpedition
    taskData.State = entity.ExpeditionInfo.State
    taskData.Pos = wds.Vector3F.New(entity.MapBasics.Position.X, entity.MapBasics.Position.Y, 0)
    taskData.Quality = 3
    taskData.EntityTid = allianceExpeditionData.ExpeditionConfigId
    taskData.VanishTime.timeSeconds = entity.ExpeditionInfo.ActivateEndTime
    return taskData
end

---@param allianceExpeditionData wds.AllianceExpeditionNode
---@return wrpc.RadarScanResultExpedition
function RadarModule:CreateExpeditionInfoByAllianceExpeditionData(allianceExpeditionData)
    ---@type wds.Expedition
    local entity = g_Game.DatabaseManager:GetEntity(allianceExpeditionData.ExpeditionEntityId, DBEntityType.Expedition)
    if not entity then
        return
    end
    ---@type wds.ExpeditionInfo
    local expeditionInfo = {}
    expeditionInfo.X = entity.MapBasics.Position.X
    expeditionInfo.Y = entity.MapBasics.Position.Y
    expeditionInfo.CfgId = allianceExpeditionData.ExpeditionConfigId
    expeditionInfo.Quality = 3
    expeditionInfo.EntityID = allianceExpeditionData.ExpeditionEntityId
    expeditionInfo.PersonalProgress = allianceExpeditionData.Progress
    expeditionInfo.ActivateEndTime = entity.ExpeditionInfo.ActivateEndTime
    expeditionInfo.State = entity.ExpeditionInfo.State
    return expeditionInfo
end

-- 是否是由雷达任务创建entity
---@param objectType ObjectType
function RadarModule:IsRadarTaskEntity(id, objectType)
    local needCheckType = objectType and true or false
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if self:CheckObjectType(taskData, objectType, needCheckType) and id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return true
        end
    end
    -- local expeditions = radarInfo.ExpeditionQuality
    -- if expeditions then
    --     for entityID, info in pairs(expeditions) do
    --         if id == entityID and id ~= 0 and entityID ~= 0 and info.QualityType > 0 then
    --             return true
    --         end
    --     end
    -- end

    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if self:CheckObjectType(taskData, objectType, needCheckType) and id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return true
        end
    end

    local mistTaskList = radarInfo.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCreepRadarTask(taskData.EntityId) then
            if self:CheckObjectType(taskData, objectType, needCheckType) and self:CheckCreepIsRadarTaskEntity(id, taskData.EntityId) then
                return true
            end
        else
            if self:CheckObjectType(taskData, objectType, needCheckType) and id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
                return true
            end
        end
    end
    return false
end

---@param taskData wds.RadarTask
---@param objectType ObjectType
function RadarModule:CheckObjectType(taskData, objectType, needCheck)
    if needCheck then
        return taskData.EntityType == objectType or taskData.EntityType == ObjectType.SlgCreepTumor
    end
    return true
end

function RadarModule:IsRadarTaskById(id)
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if id == taskData.RadarTaskId and id ~= 0 and taskData.RadarTaskId ~= 0 then
            return true
        end
    end
    return false
end

function RadarModule:IsEliteRadarTask(id)
    local radarInfo = self:GetRadarInfo()
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if id == taskData.ID and id ~= 0 and taskData.ID ~= 0 and taskData.EntityType == ObjectType.SlgExpedition then
            return true
        end
    end
    return false
end

function RadarModule:IsCreepNormalRadarTask(id)
    local crerpList = ModuleRefer.MapCreepModule.GetAllCreeps()
    for _, taskData in pairs(crerpList) do
        if id == taskData.ID and id ~= 0 and taskData.ID ~= 0 and taskData.Status == wds.PlayerMapCreepStatus.PlayerMapCreepStatusNormal then
            return true
        end
    end
    return false
end

function RadarModule:IsCreepRadarTask(id)
    local crerpList = ModuleRefer.MapCreepModule.GetAllCreeps()
    for _, taskData in pairs(crerpList) do
        if id == taskData.ID and id ~= 0 and taskData.ID ~= 0 then
            return true
        end
    end
    return false
end

function RadarModule:GetCreepConfigIDByEntityID(entityID)
    local crerpList = ModuleRefer.MapCreepModule.GetAllCreeps()
    for _, taskData in pairs(crerpList) do
        if entityID == taskData.ID and entityID ~= 0 and taskData.ID ~= 0 then
            return taskData.CfgId
        end
    end
    return 0
end

function RadarModule:GetRadarTaskRewardCount()
    local count = 0
    local player = ModuleRefer.PlayerModule:GetPlayer()
    local radarTaskList = player.PlayerWrapper2.Radar.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if taskData.State == wds.RadarTaskState.RadarTaskState_CanReceiveReward then
            count = count + 1
        end
    end
    -- local expeditions = player.PlayerWrapper2.PlayerExpeditions.CanReceiveRewardExpeditions or {}
    -- for id, expeditionInfo in pairs(expeditions) do
    --     count = count + 1
    -- end
    local eliteTaskList = player.PlayerWrapper2.Radar.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if taskData.State == wds.RadarTaskState.RadarTaskState_CanReceiveReward then
            count = count + 1
        end
    end
    local mistTaskList = player.PlayerWrapper2.Radar.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCanShowMistTask(taskData) then
            if taskData.State == wds.RadarTaskState.RadarTaskState_CanReceiveReward then
                count = count + 1
            end
        end
    end
    return count
end

function RadarModule:GetRadarTaskIDByEntityID(entityID)
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if entityID == taskData.EntityId and entityID ~= 0 and taskData.EntityId ~= 0 then
            return taskData.ID
        end
    end
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if entityID == taskData.EntityId and entityID ~= 0 and taskData.EntityId ~= 0 then
            return taskData.ID
        end
    end
    local mistTaskList = radarInfo.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCreepRadarTask(taskData.EntityId) and self:CheckCreepIsRadarTaskEntity(entityID, taskData.EntityId) then
            return taskData.ID
        end
    end
    return 0
end

function RadarModule:CheckCreepIsRadarTaskEntity(entityID, creepID)
    local creepData = ModuleRefer.MapCreepModule:GetCreepData(creepID)
    if not creepData then
        return false
    end
    return true -- entityID == creepData.TransformTargetID
end

function RadarModule:LoadRadarBubbleByType(type, customData, uniqueId, parentTrans, item, isActive)
    if type == ObjectType.SlgExpedition then
        self:LoadExpeditionBubble(customData, uniqueId, parentTrans, item, isActive)
    else
        self:LoadRadarTaskBubble(customData, uniqueId, parentTrans, item, isActive)
    end
end

function RadarModule:GetRadarTaskBase(id)
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return QUALITY_COLOR[taskData.Quality + 1]
        end
    end
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return QUALITY_COLOR[taskData.Quality + 1]
        end
    end
    local mistTaskList = radarInfo.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCreepRadarTask(taskData.EntityId) and self:CheckCreepIsRadarTaskEntity(id, taskData.EntityId) then
            return QUALITY_COLOR[taskData.Quality + 1]
        else
            if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
                return QUALITY_COLOR[taskData.Quality + 1]
            end
        end
    end
    return ""
end

function RadarModule:GetRadarTaskId(id)
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return taskData.RadarTaskId
        end
    end
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return taskData.RadarTaskId
        end
    end
    local mistTaskList = radarInfo.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCreepRadarTask(taskData.EntityId) and self:CheckCreepIsRadarTaskEntity(id, taskData.EntityId) then
            return taskData.RadarTaskId
        else
            if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
                return taskData.RadarTaskId
            end
        end
    end
    return 0
end

function RadarModule:GetRadarTaskFrameCyst(id)
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return QUALITY_COLOR_CYST[taskData.Quality + 1]
        end
    end
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return QUALITY_COLOR_CYST[taskData.Quality + 1]
        end
    end
    local mistTaskList = radarInfo.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCreepRadarTask(taskData.EntityId) and self:CheckCreepIsRadarTaskEntity(id, taskData.EntityId) then
            return QUALITY_COLOR_CYST[taskData.Quality + 1]
        else
            if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
                return QUALITY_COLOR_CYST[taskData.Quality + 1]
            end
        end
    end
    return ""
end

function RadarModule:GetRadarTaskLodBase(id)
    local radarInfo = self:GetRadarInfo()
    local radarTaskList = radarInfo.MapRadarTask.ReceivedTasks
    for _, taskData in pairs(radarTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return QUALITY_COLOR[taskData.Quality + 1]
        end
    end
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for _, taskData in pairs(eliteTaskList) do
        if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
            return QUALITY_COLOR[taskData.Quality + 1]
        end
    end
    local mistTaskList = radarInfo.MapRadarTask.MistTasks
    for _, taskData in pairs(mistTaskList) do
        if self:IsCreepRadarTask(taskData.EntityId) and self:CheckCreepIsRadarTaskEntity(id, taskData.EntityId) then
            return QUALITY_COLOR[taskData.Quality + 1]
        else
            if id == taskData.EntityId and id ~= 0 and taskData.EntityId ~= 0 then
                return QUALITY_COLOR[taskData.Quality + 1]
            end
        end
    end
    return ""
end

---@return BubbleUIPosCacheData
function RadarModule:GetBubbleUIPosCache(uniqueId)
    if not self.bubbleUIPosCache then
        return nil
    end
    for id, data in pairs(self.bubbleUIPosCache) do
        if id == uniqueId and data then
            return data
        end
    end
    return nil
end

function RadarModule:CheckIsCanUpgrade()
    if self:CheckIsMax() then
        return false
    end
    local radarInfo = self:GetRadarInfo()
    local curlevel = radarInfo.RadarLevel
    local curCfg = ConfigRefer.RadarLevel:Find(curlevel)
    if not curCfg then
        return false
    end
    local curExp = radarInfo.Exp
    local upgradeExp = curCfg:Exp()
    local isCanUp = curExp >= upgradeExp
    local itemArrays = ModuleRefer.InventoryModule:ItemGroupId2ItemArrays(curCfg:CostItem())
    for _, item in ipairs(itemArrays) do
        local curCount = ModuleRefer.InventoryModule:GetAmountByConfigId(item.configCell:Id())
        local isLack = curCount < item.count
        if isLack then
            isCanUp = false
        end
    end
    local conditionLength = curCfg:MistLevelUpConditionLength()
    if conditionLength > 0 then
        for i = 1, conditionLength do
            local taskState = ModuleRefer.QuestModule:GetQuestFinishedStateLocalCache(curCfg:MistLevelUpCondition(i))
            if taskState ~= wds.TaskState.TaskStateFinished then
                isCanUp = false
            end
        end
    end
    return isCanUp
end

function RadarModule:TableInsert(list, list2)
    if not list2 then
        return list or {}
    end

    for k, v in pairs(list2) do
        if v.State == wds.RadarTaskState.RadarTaskState_Received and v.EntityId == 0 then
            goto continue
        end
        list[k] = v
        ::continue::
    end
    return list
end

function RadarModule:GetTableCount(list)
    if not list then
        return 0
    end
    local count = 0
    for _, go in pairs(list) do
        if Utils.IsNotNull(go) then
            count = count + 1
        end
    end
    return count
end

---@param radarTask wds.RadarTask
function RadarModule:IsCanShowMistTask(radarTask)
    if not radarTask then
        return false
    end
    if radarTask.EntityType == ObjectType.SlgRtBox then
        local radarConfig = ConfigRefer.RadarTask:Find(radarTask.RadarTaskId)
        if radarConfig then
            if radarConfig:IsSkipReward() then
                return false
            end
        end
    end
    return true
end

function RadarModule:IsRadarTaskNeedRelocate(objectType, id)
    if objectType == ObjectType.SeEnter then
        return true
    end
    return not ModuleRefer.MapUnitModule:IsUnitRelocated(objectType, id) and (objectType == ObjectType.SlgRtBox or objectType == ObjectType.SlgCatchPet)
end

function RadarModule:GetRadarTaskObjectTypeAndID(objectType, id)
    if objectType == ObjectType.SlgCreepTumor then
        -- todo slgCreep -> SlgCreepCenter
        -- local creepData = ModuleRefer.MapCreepModule:GetCreepData(id)
        -- id = creepData.TransformTargetID
        -- if creepData.Status == wds.PlayerMapCreepStatus.PlayerMapCreepStatusRtBox then
        --     objectType = ObjectType.SlgRtBox
        -- elseif creepData.Status == wds.PlayerMapCreepStatus.PlayerMapCreepStatusSE then
        --     objectType =  0
        -- elseif creepData.Status == wds.PlayerMapCreepStatus.PlayerMapCreepStatusPet then
        --     objectType =  ObjectType.SlgCatchPet
        -- elseif creepData.Status == wds.PlayerMapCreepStatus.PlayerMapCreepStatusBranchSelect then
        --     objectType =  0
        -- end
    end
    return objectType, id
end

function RadarModule:SetBoardData(uniqueId, posX, posY, isCityRadar)
    ---@type RadarTaskBoardData
    local boardData = RadarTaskBoardData.new()
    boardData.cacheData = self:GetBubbleUIPosCache(uniqueId)
    if boardData.cacheData then
        boardData.arrowPos.x = boardData.cacheData.x
        boardData.arrowPos.y = boardData.cacheData.y
        boardData.row = boardData.cacheData.row
        boardData.col = boardData.cacheData.col
        boardData.result = true
        boardData.isCacheData = true
        local result_1, row_1, col_1 = RadarTaskUtils.SetBoardPos(boardData.row, boardData.col)
        if not result_1 then
            boardData.result = false
            g_Logger.Error("SetBoardData Fail uniqueId = " .. uniqueId)
            return boardData
        end
        if boardData.row ~= row_1 or boardData.col ~= col_1 then
            g_Logger.Error(string.format("SetBoardData CacheData Error uniqueId = (%s) cacheRow = (%d) cacheCol = (%d) curRow = (%d) curCol = (%d)", uniqueId, boardData.row, boardData.col, row_1,
                                         col_1))
            boardData.needUpdateCacheData = true
            boardData.row = row_1
            boardData.col = col_1
        end
    else
        boardData.arrowPos = self:GetRadarTaskArrowPos(posX, posY, isCityRadar)
        boardData.result, boardData.row, boardData.col = RadarTaskUtils.SetBoardPosByWorldPos(boardData.arrowPos.x, boardData.arrowPos.y)
    end
    return boardData
end

function RadarModule:UpdateBubbleUIPosCache(boardData, uniqueId, go, luaGO, isWorldEvent)
    isWorldEvent = isWorldEvent or false
    if not boardData.isCacheData then
        if isWorldEvent then
            boardData.arrowPos = RadarTaskUtils.GetWorldPosByBoardPos(boardData.row, boardData.col)
        else
            boardData.arrowPos = RadarTaskUtils.GetWorldPosWithOffsetByBoardPos(boardData.row, boardData.col)
        end
        boardData.arrowPos.x = math.clamp(boardData.arrowPos.x, -650, 650)
        boardData.arrowPos.y = math.clamp(boardData.arrowPos.y, -420, 420)
        ---@type BubbleUIPosCacheData
        local data = {
            x = boardData.arrowPos.x,
            y = boardData.arrowPos.y,
            row = boardData.row,
            col = boardData.col,
            go = go,
            luaGO = luaGO,
            isShake = false,
            shakeAngle = RadarTaskUtils.CalcAngleByPos(boardData.arrowPos.x, boardData.arrowPos.y),
        }
        self.bubbleUIPosCache[uniqueId] = data
    else
        self.bubbleUIPosCache[uniqueId].go = go
        self.bubbleUIPosCache[uniqueId].luaGO = luaGO
        self.bubbleUIPosCache[uniqueId].isShake = false
        if boardData.needUpdateCacheData then
            self.bubbleUIPosCache[uniqueId].row = boardData.row
            self.bubbleUIPosCache[uniqueId].col = boardData.col
            boardData.arrowPos = RadarTaskUtils.GetWorldPosByBoardPos(boardData.row, boardData.col)
            boardData.arrowPos.x = math.clamp(boardData.arrowPos.x, -650, 650)
            boardData.arrowPos.y = math.clamp(boardData.arrowPos.y, -420, 420)
            self.bubbleUIPosCache[uniqueId].x = boardData.arrowPos.x
            self.bubbleUIPosCache[uniqueId].y = boardData.arrowPos.y
            self.bubbleUIPosCache[uniqueId].shakeAngle = RadarTaskUtils.CalcAngleByPos(boardData.arrowPos.x, boardData.arrowPos.y)
            g_Logger.Error("UpdateBubbleUIPosCache ! " .. uniqueId)
        end
    end
end

-- 唯一标识符
function RadarModule:GetKey(entity)
    local str = {entity.ID, entity.TypeHash}
    return table.concat(str)
end

function RadarModule:SetScoutObject(entity, isScout)
    self.scoutObjects[self:GetKey(entity)] = isScout
end
function RadarModule:GetScout(entity)
    return self.scoutObjects[self:GetKey(entity)]
end
function RadarModule:ScoutDialogue(entity)
    local coorPos = entity.MapBasics.Position
    local worldPos = CS.Grid.MapUtils.CalculateCoordToTerrainPosition(math.floor(coorPos.X), math.floor(coorPos.Y), KingdomMapUtils.GetMapSystem())
    local taskId = self:GetRadarTaskId(entity.ID)
    local cfg = ConfigRefer.RadarTask:Find(taskId)
    local storyParameter = StoryDialogUIMediatorParameter.new()
    local provider = StoryDialogUIMediatorParameterChoiceProvider.new()
    provider._choice = {}
    provider._type = 2
    provider._dialogText = I18N.Get(cfg:RadarTaskStoryDescription(1))
    provider._characterImageSprite = false
    provider._characterSpine = 102917
    provider._characterName = I18N.Get('hero_ivy_nick')
    ---@type StoryDialogUIMediatorParameterChoiceProviderOption
    local option = {}
    option.showNumberPair = false
    option.showIsOnGoing = false
    option.content = I18N.Get("bw_radar_invest_finish")
    option.type = 0
    option.onClickOption = function()
        local msg = FinishExploreRadarTaskParameter.new()
        msg.args.RadarTaskCompId = self:GetRadarTaskIDByEntityID(entity.ID)
        msg:SendOnceCallback(nil, nil, nil, function(_, isSuccess, _)
            if isSuccess then
                self:SetScoutObject(entity, false)

                -- 侦察任务完成toast
                local colorStr = QUALITY_COLOR_STR[cfg:FixedQuality() + 1]
                local name = UIHelper.GetColoredText(I18N.Get(cfg:Name()), colorStr)
                local content = I18N.GetWithParams("Radar_task_finished_toast", name)
                ModuleRefer.ToastModule:AddJumpToast(content)

                g_Game.EventManager:TriggerEvent(EventConst.RADAR_SCOUT_REFRESH, entity.ID)
                -- 侦察特效
                local scoutVfx = CS.DragonReborn.VisualEffect.VisualEffectHandle()
                scoutVfx:Create(ManualResourceConst.vfx_bigmap_leidakuosan, ManualResourceConst.vfx_bigmap_leidakuosan, nil, function(success, obj, handle)
                    if success then
                        local go = handle.Effect.gameObject
                        go.transform.position = worldPos
                        go.transform.localScale = Vector3.one * 100
                        go.transform.localEulerAngles = Vector3(0, 0, 0)
                        scoutVfx.Effect.gameObject:SetVisible(true)
                    end
                end, nil, 0, false, false)
                TimerUtility.DelayExecute(function()
                    scoutVfx:Delete()
                end, 1.5)
                g_Game.UIManager:CloseByName(UIMediatorNames.StoryDialogUIMediator)
            end
        end)
    end
    provider:AppendOption(option)
    storyParameter:SetChoiceProvider(provider)
    g_Game.UIManager:Open(UIMediatorNames.StoryDialogUIMediator, storyParameter)
end

---@return number   itemId
---@return number   needCount
function RadarModule:GetRadarUpgradeInfo(level)
    local radarInfo = self:GetRadarInfo()
    local curlevel = radarInfo.RadarLevel
    if level then
        curlevel = level
    end
    local curCfg = ConfigRefer.RadarLevel:Find(curlevel)
    if not curCfg then
        return 0, 0
    end
    local itemArrays = ModuleRefer.InventoryModule:ItemGroupId2ItemArrays(curCfg:CostItem())
    for _, item in ipairs(itemArrays) do
        return item.configCell:Id(), item.count
    end
    return 0, 0
end

-- 获取最小的能解锁该等级迷雾的雷达等级
function RadarModule:GetCanUnlockMistRadarLevel(mistLevel)
    local radarLevel = 1
    for _, cfg in ConfigRefer.RadarLevel:ipairs() do
        if cfg:MistLevel() >= mistLevel then
            return cfg:Id()
        end
    end
    return radarLevel
end

-- 内城雷达相关
function RadarModule:IsCityRadar()
    local systemEntryId = ConfigRefer.ConstBigWorld:RadarWorldSystemEntryId()
    local isWolrdRadarOpen = ModuleRefer.NewFunctionUnlockModule:CheckNewFunctionIsUnlocked(systemEntryId)
    return not isWolrdRadarOpen
    -- Test
    -- return true
end

function RadarModule:SetCityRadarTasks(entity)
    if not self.cityRadarTasks[entity.EntityId] then
        local param = {}
        local cfg = ConfigRefer.RadarTask:Find(entity.RadarTaskId)
        param.icon = cfg:RadarTaskIcon()
        if param.icon == "" then
            local taskConfig = ConfigRefer.RadarTask:Find(entity.RadarTaskId)
            local itemGroupConfig = ConfigRefer.ItemGroup:Find(taskConfig:QualityExtReward(entity.Quality + 1))
            local itemGroup = itemGroupConfig:ItemGroupInfoList(1)
            param.icon = ConfigRefer.Item:Find(itemGroup:Items()):Icon()
        end

        param.frame = cfg:IsSpecial() and "sp_city_bubble_base_events" or QUALITY_COLOR[entity.Quality + 1]
        self.cityRadarTasks[entity.EntityId] = param
    end
end

function RadarModule:GetCityRadarTask(elementId)
    return self.cityRadarTasks[elementId]
end

function RadarModule:GetConfigIds(cfgId)
    local id = ConfigRefer.RadarTask:Find(cfgId):ConfigIds(1)
    local cfg = ConfigRefer.CityElementData:Find(id)
    local type = cfg:Type()
    local elementId = cfg:ElementId()

end

function RadarModule:GetRadarTaskNum()
    self:RefreshRadarTask()
    return self.radarTaskCount
end

function RadarModule:GetPetEggRewards()
    local items = {}
    local curLv = ModuleRefer.RadarModule:GetRadarLv()
    local randlibId = ConfigRefer.CastleLevelRadarTaskRandLib:Find(curLv):RandLibId()
    local radarTaskRandLibConfig = ConfigRefer.RadarTaskRandLib:Find(randlibId)
    if not radarTaskRandLibConfig then
        g_Logger.Error("策划没配 ConfigRefer.RadarTaskRandLib" .. curLv)
        return
    end

    local radarTaskConfig = ConfigRefer.RadarTask:Find(radarTaskRandLibConfig:EliteRadarTasks(1))
    if not radarTaskConfig then
        return
    end
    local radarTaskRewardConfig = ConfigRefer.ItemGroup:Find(radarTaskConfig:QualityExtReward(3))
    if radarTaskRewardConfig then
        for i = 1, radarTaskRewardConfig:ItemGroupInfoListLength() do
            local itemGroup = radarTaskRewardConfig:ItemGroupInfoList(i)
            table.insert(items, {itemId = itemGroup:Items(), itemCount = itemGroup:Nums()})
        end
    end

    local worldExpeditonConfig = ConfigRefer.WorldExpeditionTemplate:Find(radarTaskConfig:ConfigIds(1))
    if worldExpeditonConfig then
        local worldExpeditonRewardConfig = ConfigRefer.ItemGroup:Find(worldExpeditonConfig:FullProgressReward())
        if worldExpeditonRewardConfig then
            for i = 1, worldExpeditonRewardConfig:ItemGroupInfoListLength() do
                local itemGroup = worldExpeditonRewardConfig:ItemGroupInfoList(i)
                table.insert(items, {itemId = itemGroup:Items(), itemCount = itemGroup:Nums()})
            end
        end
    end

    return items
end

function RadarModule:GetRadarQualityFrame(quality)
    return QUALITY_COLOR[quality]
end

-- 雷达升级锁
function RadarModule:SetRadarTaskLock(isLock)
    self.loadTaskLock = isLock
end

function RadarModule:GetRadarTaskLock()
    return self.loadTaskLock
end

-- 飞蛋锁
function RadarModule:SetRadarEventLock(isLock)
    self.loadEventLock = isLock
end

function RadarModule:GetRadarEventLock()
    return self.loadEventLock
end

-- 手动雷达任务锁
function RadarModule:SetManualRadarTaskLock(isLock)
    self.manualRadarTaskLock = isLock
end

function RadarModule:GetManualRadarTaskLock()
    return self.manualRadarTaskLock
end

function RadarModule:SetManualRadarTasks(taskId)
    if self.manualRadarTasks == nil then
        self.manualRadarTasks = {}
    end
    table.insert(self.manualRadarTasks, taskId)
end

function RadarModule:GetManualRadarTasks()
    return self.manualRadarTasks
end

function RadarModule:SetManualRadarTaskBubble(uniqueId)
    if self.manualRadarTaskBubble == nil then
        self.manualRadarTaskBubble = {}
    end
    table.insert(self.manualRadarTaskBubble, uniqueId)

    -- 气泡加载完毕
    if #self.manualRadarTaskBubble == #self.manualRadarTasks then
        g_Game.EventManager:TriggerEvent(EventConst.RADAR_MANUAL_TASKS_READY)
    end
end

function RadarModule:GetManualRadarTaskBubble()
    if #self.manualRadarTaskBubble == 0 then
        return nil
    end

    return self.radarTaskBubbleList[table.remove(self.manualRadarTaskBubble, 1)]
end

function RadarModule:ClearManualRadarTasks()
    self.manualRadarTasks = {}
end

function RadarModule:ClearManualRadarTaskBubbles()
    self.radarTaskBubbleList = {}
end

-- 首次进入雷达界面
function RadarModule:SetFirstShow(value)
    self.isFirstShow = value
end

function RadarModule:GetFirstShow()
    return self.isFirstShow
end
-- TODO: 替换Mediator

-- 雷达元件
function RadarModule:GetRadarItemNum(level)
    local itemID, need = self:GetRadarUpgradeInfo(level)

    -- TODO: 等背包修复
    -- local has = ModuleRefer.InventoryModule:GetAmountByConfigId(itemID)

    local items = ModuleRefer.InventoryModule:GetCastleItems()
    local has = 0
    for k, v in pairs(items) do
        if v.ConfigId == itemID then
            has = v.Count
        end
    end

    return has, need
end

---@param config MineConfigCell
function RadarModule:IsMultiInteractor(config)
    local maxTimes = config:NumInteractOk()
    local limitTimes = config:PlayerInteractLimit()
    return maxTimes > 0 and limitTimes > 0
end

---@param interactor wds.SlgInteractor
function RadarModule:GetInteractorRemainTimes(interactor)
    if interactor and interactor.Interactor then
        local config = ConfigRefer.Mine:Find(interactor.Interactor.ConfigID)
        if not config:CanInteract() then
            return 0
        end

        local times = 0
        for _, num in pairs(interactor.Interactor.PlayerGatherCount) do
            times = times + num
        end
        return config:NumInteractOk() - times
    end
    return 0
end

---@param interactor wds.SlgInteractor
function RadarModule:CanInteract(interactor)
    if interactor and interactor.Interactor then
        local config = ConfigRefer.Mine:Find(interactor.Interactor.ConfigID)
        if not config:CanInteract() then
            return false
        end

        local maxTimes = config:NumInteractOk()
        local limitTimes = config:PlayerInteractLimit()
        if maxTimes > 0 and limitTimes > 0 then
            local playerID = ModuleRefer.PlayerModule.playerId
            local times = interactor.Interactor.PlayerGatherCount[playerID] or 0
            return times < limitTimes
        end
        return true
    end
    return false
end

function RadarModule:GetRadarTracePets()
    local castleLevel = ModuleRefer.PlayerModule:StrongholdLevel()
    local curLand = ModuleRefer.LandformModule:GetMyLandCfgId()
    local pets = {}
    for k, v in ConfigRefer.Pet:ipairs() do
        local petUnlockLevel = v:PetTrackRadarLevel()
        if petUnlockLevel == 999 then
            goto continue
        end
        local petLand = v:PetTrackLandId()
        local lockLand = curLand < petLand
        local lockCastleLevel = castleLevel < petUnlockLevel
        local isLock = lockLand or lockCastleLevel
        local isUnknown = lockCastleLevel
        local isOwn = ModuleRefer.PetModule:HasPetByCfgId(v:Id())
        local rarity = v:Quality()
        table.insert(pets, {rarity = rarity, cfgId = v:Id(), unOwn = not isOwn, isLock = isLock, lockLand = lockLand, lockCastleLevel = lockCastleLevel, isUnknown = isUnknown})

        -- 更多的宠物不用读
        -- if castleLevel < v:PetTrackRadarLevel() then
        --     break
        -- end
        ::continue::
    end
    return pets
end

function RadarModule:GetRadarTracingPets()
    local petTargetIds = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.PetTrackInfo.PetTargetIds
    local res = {}
    for k, v in pairs(petTargetIds) do
        table.insert(res, v)
    end
    return res
end

function RadarModule:SetTempRadarTracingPets(res)
    self.tempRadarTracingPets = res
end

function RadarModule:GetTempRadarTracingPets()
    return self.tempRadarTracingPets
end

function RadarModule:SetRadarTraceSelectPet(cfgId)
    self.selectpet = cfgId
end

function RadarModule:GetRadarTraceSelectPet()
    return self.selectpet
end

function RadarModule:GetRadarPetTraceState()
    local state
    local petTrackInfo = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.PetTrackInfo
    if petTrackInfo.CurPetId and petTrackInfo.CurPetId > 0 then
        local count = 0
        for k, v in pairs(petTrackInfo.SecondPhaseTasks) do
            count = count + 1
        end
        if count > 0 then
            state = PetTrackState.complete
        else
            state = PetTrackState.tracking
        end
    else
        state = PetTrackState.idle
    end

    return state
end

function RadarModule:GetRadarTrackingPet()
    local petTrackInfo = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.PetTrackInfo
    return petTrackInfo.CurPetId
end

function RadarModule:GetRadarTrackingPetTotalTimes()
    local petTrackInfo = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.PetTrackInfo
    return petTrackInfo.PetTrackTotalTimes, petTrackInfo.PetNotPerfectTimes
end

function RadarModule:GetRadarTrackingPetTimes()
    local radarLevel = self:GetRadarLv()
    local petTrackInfo = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.PetTrackInfo
    local max = ConfigRefer.RadarLevel:Find(radarLevel):PetTrackMaxTimes()
    return petTrackInfo.PetTrackLeftTimes, max
end

function RadarModule:GetRadarPetTrackingTasks()
    local petTrackInfo = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.PetTrackInfo
    return petTrackInfo.FirstPhaseTasks
end

function RadarModule:GetRadarPetTrackingFinalTasks()
    local petTrackInfo = ModuleRefer.PlayerModule:GetPlayer().PlayerWrapper2.Radar.MapRadarTask.PetTrackInfo
    return petTrackInfo.SecondPhaseTasks
end

function RadarModule:GetRadarPetTrackingProgress()
    local radarTasks = self:GetRadarPetTrackingTasks()
    local count = 0
    local max = 0
    for k, v in pairs(radarTasks) do
        if v then
            count = count + 1
        end
        max = max + 1
    end
    return count, max
end

-- 追踪用
function RadarModule:GetEliteRadarTaskCfgId(compId)
    local radarInfo = self:GetRadarInfo()
    local eliteTaskList = radarInfo.MapRadarTask.EliteTasks
    for k, v in pairs(eliteTaskList) do
        if k == compId then
            return v.RadarTaskId
        end
    end
    return nil
end

-- 追踪宠物红点
function RadarModule:OnCastleLevelChanged()
    local node = ModuleRefer.NotificationModule:GetOrCreateDynamicNode("RADAR_TRACE_NEW_PET", NotificationType.RADAR_TRACE_NEW_PET)
    if node.NotificationCount > 0 then
        return
    end

    local castleLevel = ModuleRefer.PlayerModule:StrongholdLevel()
    local hasNew = false
    for k, v in ConfigRefer.Pet:ipairs() do
        local petUnlockLevel = v:PetTrackRadarLevel()
        if petUnlockLevel == 999 then
            goto continue
        end

        -- 更多的宠物不用读
        if castleLevel == v:PetTrackRadarLevel() then
            hasNew = true
            break
        end
        ::continue::
    end

    ModuleRefer.NotificationModule:SetDynamicNodeNotificationCount(node, hasNew and 1 or 0)
end

-- 追踪新宠物红点
function RadarModule:GetPetTraceReddot()
    local node = ModuleRefer.NotificationModule:GetOrCreateDynamicNode("RADAR_TRACE_NEW_PET", NotificationType.RADAR_TRACE_NEW_PET)
    return node
end

--雷达红点改版
function RadarModule:RefreshRadarEntryReddot()
    --当雷达处于可追踪时，红点穿透到入口上
    local node1 = ModuleRefer.NotificationModule:GetOrCreateDynamicNode("RADAR_ENTRY_RED_DOT_1", NotificationType.RADAR_ENTRY_RED_DOT)
    local node2 = ModuleRefer.NotificationModule:GetOrCreateDynamicNode("RADAR_ENTRY_RED_DOT_2", NotificationType.RADAR_ENTRY_RED_DOT)

    local curT, maxT = self:GetRadarTrackingPetTimes()
    local status = self:GetRadarPetTraceState()

    --当雷达处于追踪中时，无红点，但下一次登录时雷达入口会给一个一次性红点，打开雷达界面消除，提醒玩家把任务做完
    local instantCondition = self:GetFirstOpen() == 1 and status ~= 2
    if instantCondition then
        self:SetFirstOpen(0)
    end
    ModuleRefer.NotificationModule:SetDynamicNodeNotificationCount(node1, (status == 2 and curT > 0 or instantCondition )and 1 or 0)
    ModuleRefer.NotificationModule:SetDynamicNodeNotificationCount(node2, (status == 2 and curT > 0 or instantCondition )and 1 or 0)
end

function RadarModule:GetFirstOpen()
    local res = g_Game.PlayerPrefsEx:GetInt('Radar_First_Open_Once_Login', 0)
    return res
end
 
function RadarModule:SetFirstOpen(value)
    g_Game.PlayerPrefsEx:SetInt('Radar_First_Open_Once_Login', value)
end

return RadarModule
