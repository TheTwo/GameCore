---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wupei.
--- DateTime: 2020/11/2
---

local DBEntityType = require('DBEntityType')
local EventConst = require('EventConst')
local ModuleRefer = require('ModuleRefer')
local AllianceAuthorityItem = require('AllianceAuthorityItem')
local SlgUtils = require('SlgUtils')

local Utils = require('Utils')
local ConfigRefer = require('ConfigRefer')
local UISlgBattleInfo = require("UISlgBattleInfo")
local TroopConst = require('TroopConst')
local TroopView = require("TroopView")
local MonsterClassType = require("MonsterClassType")

---@class TroopCtrl
local TroopCtrl = class('TroopCtrl')

---@protected
---@param data wds.Troop | wds.MapMob | wds.MobileFortress | nil
function TroopCtrl:ctor(data, dbEntityPath)
    self._module = ModuleRefer.SlgModule

    self._isSelected = false
    self._isFocus = false

    -- 拖拽预览行军线时，创建的是VirtualTroopCtrl，data可能为nil
    if data then
        self._data = data
        self.TypeHash = data.TypeHash
        self.ID = data.ID
        self._radius = self._module.troopManager:CalcTroopRadius(data)
        self._moveThreadhold = self._radius * 0.25 * self._module.slgScale
    else
        self._radius = 50
    end

    self._curHP = 0
    self._maxHp = 1
    self._dbEntityPath = dbEntityPath
    self._positionQueryFrame = -1
    self._forwardQueryFrame = -1
    self._battleFlag = false
    self._lastRefreshBattleing = -1

    ---@type wds.Troop[]
    self._members = {}
    self.troopType = SlgUtils.TroopType.Invalid
    self.troopView = TroopView.new(self)

    self:GatherMembers()
    self:RecalculateHp()
end

function TroopCtrl:GatherMembers()
    local data = self:GetData()
    if data == nil then
        return
    end

    if data.TypeHash == DBEntityType.TroopChariot then
        for _, participant in pairs(data.Army.PlayerTroopIDs) do
            local member = g_Game.DatabaseManager:GetEntity(participant.Id, DBEntityType.Troop)
            if member then
                table.insert(self._members, member)
            end
        end
    else
        table.insert(self._members, data)
    end
end

function TroopCtrl:RecalculateHp()
    local data = self:GetData()
    if data then
        self._curHP = self:CalculateCurrentHp()
        self._maxHp = self:CalculateMaxHp()
    else
        self._curHP = 0
        self._maxHp = 1
    end
end

function TroopCtrl:CalculateCurrentHp()
    local hp = 0
    for _, member in pairs(self._members) do
        hp = hp + member.Battle.Hp
    end
    return hp
end

function TroopCtrl:CalculateMaxHp()
    local maxHp = 0
    for _, member in pairs(self._members) do
        maxHp = maxHp + member.Battle.MaxHp
    end
    return maxHp
end

---@param holder CS.UnityEngine.Transform
---@param name string
---@param callback fun(pObject:SlgPoolObject)
function TroopCtrl:StartupTroopCtrl(holder, name, callback)
    self.troopView:StartupTroopView(holder, name, function()
        self:DoOnNewEntity()

        if callback then
            callback()
        end
    end)
end

function TroopCtrl:ReleaseTroopCtrl()
    self:DoOnDestroyEntity()
    self.troopView:DoOnDespawn()
end

function TroopCtrl:IsValid()
    return self.troopView:IsValid()
end

function TroopCtrl:GetTransPeer()
    return self.troopView.trans
end

----AbstractCtrl


function TroopCtrl:DoOnNewEntity()
    self:OnNewEntity()
    self:OnLodChange(self._module:GetLodValue())
end

function TroopCtrl:DoOnDestroyEntity()
    if Utils.IsNull( self:GetCSView() ) then
        return
    end  

    self._module.selectManager:CancelSelect(self)
    self:OnDestroyEntity()
end

function TroopCtrl:DoOnLodChange(lod, oldLod)
    self:OnLodChange(lod, oldLod)  
end

function TroopCtrl:GetID()
    return self.ID
end

function TroopCtrl:IsNotValid()
    return not self:IsValid()
end

---@return CS.DragonReborn.SLG.Troop.TroopViewProxy
function TroopCtrl:GetCSView()
    return self.troopView._csView
end

function TroopCtrl:GetData()
    return self._data
end

function TroopCtrl:GetHP()
    return self._curHP
end

function TroopCtrl:GetMaxHP()
    return self._maxHp
end

function TroopCtrl:SyncBattleHpAtRoundEnd()
    self._curHP = self:CalculateCurrentHp()
    self:SetViewDirty(true)
end

function TroopCtrl:UpdateCurrentHP(needShake)
    self._curHP = self:CalculateCurrentHp()
    self:SetViewDirty(true, needShake)
end

function TroopCtrl:GetTransform()
    if self:IsNotValid() then
        return nil
    end
    return self:GetCSView().transform
end

---获取坐标, 物体消失后, 会取得删除点的坐标
function TroopCtrl:GetPosition()
    self:UpdatePosition()
    return self._position
end

---@return Float3
function TroopCtrl:GetPositionFloat3()
    self:UpdatePosition()
    return self._positionFloat3
end

function TroopCtrl:UpdatePosition()
    if g_Game.Time.frameCount ~= self._positionQueryFrame then
        local troop = self:GetData()

        if self:IsValid() then
            self._position = self:GetCSView().transform.position
        else
            if troop then
                self._position = self._module:ServerCoordinate2Vector3(troop.MapBasics.Position)
            end
        end

        -- 当Troop是一个集结的成员时，Troop的坐标应该取TroopChariot的坐标
        if SlgUtils.IsTroopInRally(troop) and SlgUtils.IsTroopInGarrison(troop) then
            local chariotCtrl = self._module:GetCtrl(troop.ID)
            if chariotCtrl then
                self._position = chariotCtrl:GetPosition()
            end
        end

        self._positionFloat3 = 
        {
            x = self._position.x,
            y = self._position.y,
            z = self._position.z
        }

        self._positionQueryFrame = g_Game.Time.frameCount
    end
end

function TroopCtrl:GetForward()
    self:UpdateForward()
    return self._forward
end

---@return Float3
function TroopCtrl:GetForwardFloat3()
    self:UpdateForward()
    return self._forwardFloat3
end

function TroopCtrl:UpdateForward()
    if g_Game.Time.frameCount ~= self._forwardQueryFrame then
        local troop = self:GetData()

        if self:IsValid() then
            self._forward = self:GetCSView().transform.forward
        else
            if troop then
                self._forward = self._module:ServerCoordinate2Vector3(troop.MapBasics.Direction)
            end
        end

        -- 当Troop是一个集结的成员时，Troop的朝向应该取TroopChariot的朝向
        if SlgUtils.IsTroopInRally(troop) and SlgUtils.IsTroopInGarrison(troop) then
            local chariotCtrl = self._module:GetCtrl(troop.ID)
            if chariotCtrl then
                self._forward = chariotCtrl:GetForward()
            end
        end
        
        self._forwardFloat3 =
        {
            x = self._forward.x,
            y = self.forward.y,
            z = self.forward.z
        }

        self._forwardQueryFrame = g_Game.Time.frameCount
    end
end

function TroopCtrl:SetForward(forward)
    if self:IsValid() then
        self:GetCSView().transform.forward = forward
    end
    self._forward = forward
end

---@return UnityEngine.GameObject
function TroopCtrl:GetGameObject()
    if self:IsNotValid() then
        -- g_Logger.Error("ctrl is not valid. typeName: %s", self._data.TypeName)
        return nil
    end
    return self:GetCSView().gameObject
end

---@return SlgPoolObject|TroopView
function TroopCtrl:GetTroopView()
    return self.troopView
end

function TroopCtrl:HasSkill(index)
    return false
end

function TroopCtrl:IsSelected()
    return self._isSelected
end

function TroopCtrl:IsFocus()
    return self._isFocus
end

function TroopCtrl:DespawnIndicator(selectEffect)
    if selectEffect then
        selectEffect.gameObject:SetActive(false)
        selectEffect.Target = nil
    end
end

function TroopCtrl:DoOnEntityChanged(entity)
    self._data = entity
    self:OnEntityChanged()
end

----end AbstractCtrl

function TroopCtrl:OnNewEntity()
    self._isFriend = ModuleRefer.PlayerModule:IsFriendly(self._data.Owner)
    self._isBoss = SlgUtils.IsBoss(self._data)
    self.troopType = SlgUtils.FigureOutTroopType(self._data)

    if self:IsPuppet() then
        self.spawnTime = g_Game.Time.time
        ---@type wds.SlgPuppet
        local puppetData = self._data
        local cfgId =  puppetData.BasicInfo.ConfID
        local cfg = ConfigRefer.PuppetSlg:Find(cfgId)      
        if cfg then
            self.lifeTime = cfg:DurationTime()
            self.deadWaring = cfg:ShowWarning() and self.lifeTime > 0 
            if self.deadWaring then
                g_Game.EventManager:TriggerEvent(EventConst.SLGTROOP_WARNING_PUPPET,
                {
                    troopId = self.ID,
                    show = true
                }
            )
            end
        end
    end

    self:SetTroopViewData()

    local visible = self:IsVisible()
    local troopView = self:GetTroopView()
    troopView:StartFromLua()
    troopView:SetShow(visible)
    troopView:SetCSViewEnabled(visible)
    troopView:SetColliderEnabled(visible)
    troopView:SetColliderSize(self:GetRadius() * 2)
    self:OnRefreshBattling(self._data)
    self:InitBuffs(self._data)
end

function TroopCtrl:OnDestroyEntity()    
    self:ReleaseTroopLine()   
    self:GetTroopView():DestroyTroop()
    if self.deadWaring then
        g_Game.EventManager:TriggerEvent(EventConst.SLGTROOP_WARNING_PUPPET, { troopId = self.ID, show = false })
    end
    self._retreatingPath = nil
    self.troopType = SlgUtils.TroopType.Invalid
    self:ClearBattleRelation()
end

function TroopCtrl:CheckBattleState()
    ---@type TroopView
    if self:IsNotValid() then return end
    if self._lastRefreshBattleing ~= g_Game.Time.frameCount
        and self.troopView and self.troopView:GetState() ~= TroopConst.STATE_BATTLE 
    then
        self._lastRefreshBattleing = g_Game.Time.frameCount
        self:OnRefreshBattling(self._data)
    end
end

---@param data wds.Troop | wds.MapMob
function TroopCtrl:OnRefreshBattling(data)
    if data.ID ~= self._data.ID then
        return
    end
    local troopView = self:GetTroopView()
   
    local state = data.MapStates
    local inAttacking = false   
    if state.Attacking and SlgUtils.IsTroopSelectable(data) then
        local targetUID = data.Battle.TargetUID
        local targetEntity = SlgUtils.GetEntityById(data.Battle.TargetArmyUID)
        
        if targetEntity ~= nil 
            and targetEntity.MapBasics ~= nil 
            and targetEntity.MapBasics.Position ~= nil
        then                         
            local buildingLayout = ModuleRefer.MapBuildingLayoutModule:GetLayout(targetEntity.MapBasics.LayoutCfgId)
            
            troopView:SetAttackPosition(
                self._module:ServerCoordinate2Vector3(targetEntity.MapBasics.Position),
                math.max(buildingLayout.SizeX*self._module.unitsPerTileX,buildingLayout.SizeY*self._module.unitsPerTileZ)
            )
            
            self:StartAttack()
            inAttacking = true
        else            
            local targetCtrl = self._module:GetTroopCtrl(targetUID)
            if targetCtrl then
                if self.lastTargetCtrl ~= targetCtrl then
                    if self.lastTargetCtrl then
                        self:CheckAndSetBattleRelation(self.lastTargetCtrl,false,true)
                        self.lastTargetCtrl:RemoveBeAttackedCtrl(self)
                    end
                    self.lastTargetCtrl = targetCtrl
                    self:CheckAndSetBattleRelation(targetCtrl,true,true) 
                    troopView:SetAttackTarget(targetCtrl)
                    targetCtrl:AddBeAttackedCtrl(self)
                end

                self:StartAttack()
                inAttacking = true
            else
                ---fallback to old data logic
                local troopEntity = SlgUtils.GetEntityById(targetUID)
                if troopEntity ~= nil 
                    and troopEntity.MapBasics ~= nil 
                    and troopEntity.MapBasics.Position ~= nil
                then
                    troopView:SetAttackPosition(self._module:ServerCoordinate2Vector3(troopEntity.MapBasics.Position), 0)                    
                    self:StartAttack()
                    inAttacking = true  
                end
            end
        end
    end
    
    if not inAttacking then
        if self.lastTargetCtrl ~= nil then
            self:CheckAndSetBattleRelation(self.lastTargetCtrl,false,true)
            self.lastTargetCtrl:RemoveBeAttackedCtrl(self)
            self.lastTargetCtrl = nil
        end

        troopView:SetAttackTarget(nil)
        troopView:FinishAttack()
    end
end

function TroopCtrl:StartAttack()
    local troopView = self:GetTroopView()
    if troopView then
        local showStartFx = false
        if not self._battleFlag then
            self._battleFlag = true
            showStartFx = true
        end
        troopView:StartAttackIfNeed(showStartFx)
    end
end

---@param data wds.Troop | wds.MapMob
---@param change wds.MovePathInfo
function TroopCtrl:OnMovePathInfoChanged(data, change)
    if data.ID ~= self._data.ID or self._retreatingPath then
        return
    end

    local troopView = self:GetTroopView()
    if troopView == nil then
        return
    end
    
    --由于驻扎时前端会销毁ECS显示层，如果MovePathInfo更新事件早于MapStats更新事件，路点数据无法灌注到显示层，导致行军动画卡
    troopView:SetShow(self:IsVisible())

    local spState = self:GetSpState()
    if spState ~= TroopConst.SP_STATE_NONE then
        if spState == TroopConst.SP_STATE_FLOATING or spState == TroopConst.SP_STATE_STUN then
            troopView:ResetTroopLine()
        end

        if data.MapStates.Retreating then
            self:SaveRetreatingPath(data.MovePathInfo)
        end
        return
    end

    local showTroopLine = self:IsTroop()
    local movePathInfo = data.MovePathInfo
    troopView.Speed = self._module:ServerSpeed2MapSpeed(movePathInfo.Speed)        
    local path = movePathInfo.Path

    troopView:SetServerPosition(data.MapBasics.Position)
    troopView:SetServerDirection(data.MapBasics.Direction)
    troopView:ApplyTrans()

    local realPath = {}
    local troopLinePoints = {}
    local offset = ModuleRefer.SlgModule:GetLineHeightOffset()
    local c = #path       
    
    for i = c, 1, -1 do
        local v = path[i]
        local pos = self._module:ServerCoordinate2Vector3(v)
    
        table.insert(realPath,  pos)

        if showTroopLine then
            table.insert(troopLinePoints,pos)
        end
    end
  
    troopView:SetPath(realPath, data.MapStates.Moving, showTroopLine)
    if showTroopLine and troopView.TroopLine then
        local p = troopView.transform.position    
        table.insert(troopLinePoints,1,p)
        troopView.TroopLine:UpdatePoints(troopLinePoints, true, offset)
        troopView.TroopLine:SetScale(self._module.slgScale)
        troopView.TroopLine:SetColor(self:GetNameColor())
        g_Game.EventManager:TriggerEvent(EventConst.SLGTROOP_PATH_CHANGED,self._data.ID)
    end    
end

function TroopCtrl:SaveRetreatingPath(movePathInfo)
    local startPosition = self:GetTroopView().transform.position
    local speed = SlgUtils.CalculateTroopMoveSpeed(movePathInfo)
    local length, realPath, troopLinePoints = SlgUtils.CalculateTroopMovePath(startPosition, movePathInfo)
    self._retreatingPath = {}
    self._retreatingPath.realPath = realPath
    self._retreatingPath.troopLinePoints = troopLinePoints
    self._retreatingPath.startTime = g_Game.Time.time
    self._retreatingPath.duration = length / speed    
    self._retreatingPath.length = length
end

function TroopCtrl:UseRetreatingPath()
    if not self._retreatingPath then return end
    local troopView = self:GetTroopView()
    if not troopView then return end
    local newSpeed = self._retreatingPath.length /(self._retreatingPath.duration - g_Game.Time.time + self._retreatingPath.startTime)
    troopView.Speed = newSpeed
    local realPath = self._retreatingPath.realPath
    local troopLinePoints = self._retreatingPath.troopLinePoints
    troopView:SetPath(realPath,true,true)
    if troopView.TroopLine then
        local p = troopView.transform.position    
        local offset = ModuleRefer.SlgModule:GetLineHeightOffset()
        table.insert(troopLinePoints,1,self._module:GetTerrainPos(p,offset))
        troopView.TroopLine:UpdatePoints(troopLinePoints)
        troopView.TroopLine:SetScale(self._module.slgScale)
        troopView.TroopLine:SetColor(self:GetNameColor())        
        g_Game.EventManager:TriggerEvent(EventConst.SLGTROOP_PATH_CHANGED,self._data.ID)
    end    
    
end

---@param data wds.Troop | wds.MapMob | wds.MobileFortress
function TroopCtrl:OnPathTargetMoved(data)
    if not data then
        return
    end

    local troopView = self:GetTroopView()
    if troopView == nil then
        return
    end
    local offset =  self._module:GetLineHeightOffset()
    local pos = self._module:ServerCoordinate2Vector3(data.MapBasics.Position)
    if troopView.TroopLine then
        troopView.TroopLine:MoveEndPointPos(self._module:GetTerrainPos(pos,offset))
    end
end

---OnMapBasicsChanged
---@param data wds.Troop
---@param changed wds.MapEntityBasicInfo
function TroopCtrl:OnMapBasicsChanged(data,changed)
    if data.ID ~= self._data.ID or not changed then
        return
    end

    local troopView = self:GetTroopView()
    local needSyncPos = false
    local needSyncDir = false   
    if changed.Position then     
        local changedPos = changed.Position
        troopView:SetServerPosition(changedPos)
        needSyncPos = true
    end    
    
    if changed.Direction then
        local changedDir = changed.Direction
        troopView:SetServerDirection(changedDir)
        troopView:UpdateLodIconDirection()
        needSyncDir = true
    end

    if self._module.DebugMode and (changed.Position or changed.Direction) then           
        troopView:UpdateDebugInfo()
    end

    if needSyncDir or needSyncPos then
        troopView:ApplyTrans()
    end
end

---@param data wds.Troop
---@param changed wds.MapEntityState
function TroopCtrl:OnMapStateChanged(data,changed)
    if data.ID ~= self._data.ID then
        return
    end
    local troopView = self:GetTroopView()
    if not troopView then
        return 
    end   
    if changed.Battling ~= nil and changed.Battling == false  then
        self._battleFlag = false
    end

    if changed.Attacking ~= nil or changed.Battling ~= nil then               
        self:UpdateCurrentHP()
        self:OnRefreshBattling(data)        
    end

    if SlgUtils.IsTroopRetreating(changed) then
        self:RebuildTroopView()
        self._module.selectManager:CancelSelect(self)
        troopView:SetEscapeState(true)
    elseif changed.StateWrapper2 and changed.StateWrapper2.BackToOrigin == false then
        troopView:SetEscapeState(false)        
    end

    if self:IsTroop() then
        local visible = self:IsVisible()
        troopView:SetShow(visible)
        
        if not visible then
            self._module.selectManager:CancelSelect(self)
        end

        self:SetViewDirty()
    elseif self:IsBattling() then       
        self:SetViewDirty()
    end
end

---@param data wds.MapMob
---@param changed wds.MapEntityState
function TroopCtrl:OnTrusteeshipTargetInfoChanged(data)
    if data.ID ~= self._data.ID or self:IsNotValid() then
        return
    end

    local troopView = self:GetTroopView()
    if not troopView then
        return
    end

    local visible = self:IsVisible()

    troopView:SetShow(visible)
end

---@param data wds.Troop
---@param change wds.Battle
function TroopCtrl:OnBattleChanged(data, change)
    if data.ID ~= self._data.ID or not change then
        return
    end

    self:OnRefreshBattling(data)

    local viewDirty = false
    if change.Hp then
        local view = self:GetTroopView()
        view:UpdateLodIconHp()

        if not SlgUtils.IsTroopBatting(data) then
            local prevHp = self:GetHP()
            self:UpdateCurrentHP()
            local currHp = self:GetHP()
            if currHp > prevHp then --轻伤回血，英雄复活
                view:UpdateHeroState()
            end
        end

        viewDirty = self:SetViewDirty()
    end

    if not viewDirty and change.RageValue then
        self:SetViewDirty(true)
    end
end

function TroopCtrl:IsBuffExist(cfgId)
    if not cfgId or cfgId < 1 then return false end
    if self._data 
        and self._data.Skill 
        and self._data.Skill.SlgBuffs 
        and self._data.Skill.SlgBuffs:Count() > 0 
    then                           
        return self._data.Skill.SlgBuffs[cfgId] ~= nil
    end
    return false
end

function TroopCtrl:AddBuff(round,cfgIds,skillUID,fromSelf)             
    self._module.battleManager:CacheBuff(round,self.ID,skillUID,cfgIds,fromSelf)    
end

function TroopCtrl:TriggerBuff(cfgId,fromSelf)
    if self:IsBuffExist(cfgId)  then        
        local buffCfg = ConfigRefer.KheroBuffLogical:Find(cfgId)                
        if self._module:CanShowBuffVfx() then
            local buffArt = ConfigRefer.ArtResource:Find( buffCfg and buffCfg:Resource() or 0)
            if buffArt then
                local yOffset = 0
                if(buffArt:ModelPositionLength() > 0) then
                    local yOffsetType = buffArt:ModelPosition(1)
                    if yOffsetType >= 0.9 then
                        yOffset = 1                       
                    end                            
                end                
                local vfxPath = buffArt:Path()            
                g_Game.TroopViewManager:SetBuffFx(self.ID,cfgId,vfxPath,yOffset,buffArt:ModelScale(),true)      
            end
        end
        if self:IsSelf() or fromSelf then 
            UISlgBattleInfo.SpawnBuffName(self._module,buffCfg,self)                        
        end
    end
end

---@param data wds.Troop
function TroopCtrl:InitBuffs(data)
    if not data or not data.Skill or not data.Skill.SlgBuffs or not self:IsVisible() then return end
    local buffs = data.Skill.SlgBuffs
    for key, value in pairs(buffs) do
        self:TriggerBuff(value.ConfigId)
    end
end


function TroopCtrl:GetSpState()
    if not self._data or not self._data.Skill then return TroopConst.SP_STATE_NONE end
    return SlgUtils.GetSpStateFromBuffDatas(self._data.Skill.SlgBuffs) 
end

---@param data wds.Troop | wds.Monster | wds.MapMob | wds.CastleBrief | wds.SlgPuppet
---@param change table<number,wds.BuffInfo>
function TroopCtrl:OnBuffChanged(data,change)
    if data.ID ~= self._data.ID or not change or not self:IsVisible() then
        return
    end    

    if data and data.Skill and data.Skill.SlgBuffs then
        if change.Remove then
            for cfgId, value in pairs(change.Remove) do   
                if cfgId > 0 then               
                    if not data.Skill.SlgBuffs[cfgId] then
                        g_Game.TroopViewManager:SetBuffFx(data.ID,cfgId,nil,0,0,false)
                    end
                   
                end
            end
        end        
        local spState = SlgUtils.GetSpStateFromBuffDatas(data.Skill.SlgBuffs)
        if spState == TroopConst.SP_STATE_NONE then
            g_Game.TroopViewManager:SetTroopSpState(data.ID,TroopConst.SP_STATE_RESET_FLAG)     
            self:UseRetreatingPath()   
        end                       
    end
end

---@return wds.Troop | wds.MapMob
function TroopCtrl:GetTroopData()
    return self._data
end

---@param troopView TroopView
---@param troopData wds.Troop | wds.MapMob | wds.MobileFortress ...
function TroopCtrl:SetTroopViewData()
    local data = self._data
    local troopView = self.troopView

    troopView.Speed = self._module:ServerSpeed2MapSpeed(data.MovePathInfo.Speed)
    troopView:SetServerDirection(data.MapBasics.Direction)
    troopView:SetServerPosition(data.MapBasics.Position)
    troopView:ApplyTrans()
end

function TroopCtrl:OnLodChange(lod, oldLod)
    local troopView = self:GetTroopView()
    if troopView then
        troopView:UpdateLod(lod)
    end
end

function TroopCtrl:DoOnCamSizeChange(size,oldSize)
    local troopView = self:GetTroopView()
    if troopView then
        troopView:UpdateCamSize(size, oldSize)
    end
end

function TroopCtrl:IsMonster()
    return self.TypeHash == DBEntityType.MapMob
end

function TroopCtrl:IsBehemothMonster()
    if self.isBehemoth == nil then
        self.isBehemoth = false

        if self:IsMonster() then
            local mobCfg = ConfigRefer.KmonsterData:Find(self._data.MobInfo.MobID)
            if mobCfg and mobCfg:MonsterClass() == MonsterClassType.Behemoth then
                self.isBehemoth = true
            end
        end
    end

    return self.isBehemoth
end

function TroopCtrl:IsPuppet()
    return self.TypeHash == DBEntityType.SlgPuppet
end

function TroopCtrl:IsChariot()
    return self.TypeHash == DBEntityType.TroopChariot
end

function TroopCtrl:IsBoss()    
    return self._isBoss
end

---Get Monster Bubble Type from KmonsterData
---@return number
function TroopCtrl:GetMonsterBubbleType()
    if not self:IsMonster() then
        return 0
    end
    local mobId = self._data.MobInfo.MobID
    local mobCfg = ConfigRefer.KmonsterData:Find(mobId)
    if not mobCfg then
        return 0
    end
    return mobCfg:MonsterBubble()
end

function TroopCtrl:IsFortress()
    return self.TypeHash == DBEntityType.MobileFortress
end

function TroopCtrl:GetTypeHash()
    return self.TypeHash
end

function TroopCtrl:IsTroop()
    return not self:IsMonster() and not self:IsPuppet()
end

function TroopCtrl:GetValues(data, count, key, defaultValue)
    local values = {}
    if data then
        for i = 1, #count do
            values[i] = data[i][key]
        end
    else
        for i = 1, #count do
            values[i] = defaultValue
        end
    end
    return values
end

function TroopCtrl:CanSelect()
    local data = self._data
    if not SlgUtils.IsTroopSelectable(data) then
       return false
    elseif self:IsSameAlliance() then
        return true
    elseif self:IsOthersTroop() then
       return false
    end
    return true
end

function TroopCtrl:IsAttackableMonster()
    if not self._data or not self._data.MobInfo then
        return false
    end
    return SlgUtils.IsMobCanAttackById(self._data.MobInfo.MobID)
end

function TroopCtrl:CanUISelect()
    return SlgUtils.IsTroopSelectable(self._data)
end

function TroopCtrl:IsFriendly()
    return self._isFriend
end

function TroopCtrl:IsSelf()
    return self.troopType == SlgUtils.TroopType.MySelf
end

function TroopCtrl:CanCtrl()
    if not self:CanSelect() then
        return
    end

    if self.TypeHash == wds.MobileFortress.TypeHash then
        if self._module:IsMobileFortressBuilding(self._data) then
            return false
        end
        if not self:IsFriendly() then
            return false
        end        
        local hasAuthority = ModuleRefer.AllianceModule:CheckHasAuthority(AllianceAuthorityItem.MoveMobileFortress)
        if hasAuthority and self._data.BehemothTroopInfo and self._data.BehemothTroopInfo.MonsterTid ~= 0 then
            hasAuthority = ModuleRefer.AllianceModule:CheckHasAuthority(AllianceAuthorityItem.SummonBehemoth)
        end
        if hasAuthority then
            return true
        else
            return false
        end
    else
        return self:IsSelf()
    end    
end

function TroopCtrl:SetSelected(value)
    if self._isSelected ~= value then
        self._isSelected = value            
    end
    if not self:IsValid() then
        return
    end
    local view = self:GetTroopView()
    if view then
        view:SetTroopSelectionInfo(value)
    end
end

function TroopCtrl:SetFocus(value)    
    if self._isFocus ~= value then
        self._isFocus = value                    
    end
    if not self:IsValid() then
        return
    end
    local view = self:GetTroopView()
    if view then
        view:SetFocus(self:IsFocus())
    end
end

function TroopCtrl:SetViewDirty(force, needShake)   
    local view = self:GetTroopView()
    if view then
        return view:SetDirty(force, needShake)
    end
    return false
end

function TroopCtrl:GetName()
    if self:IsTroop() then
        local owner = self._data.Owner
        if not string.IsNullOrEmpty(tostring(owner.GuildName and owner.GuildName.String)) then
            return string.format("[%s]%s", owner.GuildName, owner.PlayerName.String)
        end
        return string.format("%s", owner.PlayerName.String)
    else
       
    end
    return ""
end

function TroopCtrl:GetIntroduction()
    if self:IsTroop() then
        local owner = self._data.Owner
        if not string.IsNullOrEmpty(tostring(owner.GuildName and owner.GuildName.String)) then
            return string.format("[%s]%s", owner.GuildName.String, owner.PlayerName.String)
        end
        return string.format("%s", owner.PlayerName.String)
    else
       
    end
    return ""
end

function TroopCtrl:GetNameColor()
    if self:IsTroop() then
        if self:IsSelf() then
            return ColorUtil.FromHexNoAlpha(0x8df37b)
        elseif self:IsFriendly() then
            return ColorUtil.FromHexNoAlpha(0x77CEFF)
        else
            return CS.UnityEngine.Color.white
        end
    else
        return CS.UnityEngine.Color.white
    end
end

function TroopCtrl:GetSelectColor()
    if self:IsTroop() then
        if self:IsSelf() then
            return ColorUtil.FromHexNoAlpha(0x8df37b)
        elseif self:IsFriendly() then
            return ColorUtil.FromHexNoAlpha(0x77CEFF)
        else
            return ColorUtil.FromHexNoAlpha(0xff6565)
        end
    else
        return ColorUtil.FromHexNoAlpha(0xff6565)
    end
end


function TroopCtrl:IsBattling()
    return (self._data.MapStates.Battling or self._data.MapStates.Attacking) and self._data.Battle.TargetUID > 0
end

function TroopCtrl:GetRadius()   
    return self._radius
end

function TroopCtrl:IsApproaching()
    if self._data and self._data.MovePathInfo then
        return self._data.MovePathInfo.Approaching
    else
        return false
    end
end

function TroopCtrl:IsGoingBackToCity()
    if self._data and self._data.MapStates then
        return self._data.MapStates.BackToCity
    else
        return false
    end
end

function TroopCtrl:CreateTroopLine()
    if self._troopLinePreview == nil then -- 预览行军线
        self._troopLinePreview = self._module.troopLineManager:CreateLine(true)
        self._troopLinePreview:SetupEndPointsTrans(nil)
    end
end

function TroopCtrl:ReleaseTroopLine()
    if self._troopLinePreview then
        self._troopLinePreview:SetupEndPointsTrans(nil)
        self._module.troopLineManager:DestroyTroopLine(self._troopLinePreview)
        self._troopLinePreview = nil
    end

    self._module.touchManager:SetAimCircle(nil,false)
end

function TroopCtrl:GetTroopLine()
    return self._troopLinePreview
end

---@param type number @1 circle 2 rect
---@param position CS.UnityEngine.Vector3
---@param direction CS.UnityEngine.Vector3
---@param size CS.UnityEngine.Vector3
function TroopCtrl:SetSkillWaring(type,position,direction,size)
    -- if not self._skillWaring then 
    --     local troopView = self:GetTroopView()
    --     if not troopView then
    --         return
    --     end
    --     self._skillWaring = troopView:GetSkillWaring()
    --     if not self._skillWaring then return end
    -- end 
    -- if type == 1 then
    --     self._skillWaring.circle:SetVisible(true)
    --     self._skillWaring.rect:SetVisible(false)
    --     self._skillWaring.circle.position = position
    --     self._skillWaring.circle.localScale = CS.UnityEngine.Vector3.one * size.x
    -- elseif type == 2 then
    --     self._skillWaring.circle:SetVisible(false)
    --     self._skillWaring.rect:SetVisible(true)
    --     self._skillWaring.rect.localPosition = CS.UnityEngine.Vector3.zero
    --     self._skillWaring.rect.rotation = CS.UnityEngine.Quaternion.LookRotation(direction,CS.UnityEngine.Vector3.up)
    --     self._skillWaring.rect.localScale = size
    -- end
end

function TroopCtrl:ClearSkillWaring()
    if not self._skillWaring then return end
    self._skillWaring.circle:SetVisible(false)
    self._skillWaring.rect:SetVisible(false)
end

---@param ctrl TroopCtrl
function TroopCtrl:AddBeAttackedCtrl(ctrl)
    if ctrl == nil or not ctrl:IsValid() then
        return
    end  
    self:CheckAndSetBattleRelation(ctrl,true,false)
end

---@param ctrl TroopCtrl
function TroopCtrl:RemoveBeAttackedCtrl(ctrl)
    if ctrl == nil or not ctrl:IsValid() then
        return
    end
    self:CheckAndSetBattleRelation(ctrl,false,false)
end

function TroopCtrl:HasBeAttackedCtrl()
    return self._beAttackedCount ~= nil and self._beAttackedCount > 0
end

function TroopCtrl:GetBeAttackedCtrlCount()
    return self._beAttackedCount or 0
end

---@return table<TroopCtrl, boolean>
function TroopCtrl:GetBeAttackedCtrlMap()
    return self._beAttackedCtrlMap
end

---@return TroopCtrl[]
function TroopCtrl:GetBeAttackedCtrlList()
    local array = {}
    local count = 0
    if self._beAttackedCtrlMap ~= nil then
        for i, v in pairs(self._beAttackedCtrlMap) do
            count = count + 1
            array[count] = i
        end
    end
    return array
end

function TroopCtrl:SyncHpClientFromKeyEvent()

end

function TroopCtrl:GetHeroIndex(heroCfgId)
    local heros = self._data.Battle.Group.Heros
    if not heros or heros:Count() < 1 then
        return 0
    end
    for index, hero in pairs(heros) do
        if hero and hero.HeroID == heroCfgId then
            return index + 1
        end
    end
    return 0
end

function TroopCtrl:RebuildTroopView()
    if self._data == nil then
        return
    end
    
    ---@type TroopView
    local troopView = self:GetTroopView()
    self:SetTroopViewData()
    
    self.lastTargetCtrl = nil
    self._isFocus = false

    troopView:SetShow(false)

    local visible = self:IsVisible()

    troopView:SetShow(visible)
    
    if visible then
        self:OnMovePathInfoChanged(self._data,nil)
        self:OnRefreshBattling(self._data)
        self:InitBuffs(self._data)
    end   
end

function TroopCtrl:ShouldBeAffectedBySimpleMode()
    local typeHash = self:GetTypeHash()
    return typeHash == DBEntityType.Troop or typeHash == DBEntityType.TroopChariot
end

function TroopCtrl:AffectedBySimpleMode()
    return self._module:InSimpleMode() and self:ShouldBeAffectedBySimpleMode()
end

---@param ctrl TroopCtrl
function TroopCtrl:CheckAndSetBattleRelation(ctrl,enable,attack)
    if not self:IsSelf() then
        return
    end
    if enable then
        self._module.battleManager:AddToBattleRelation(self,ctrl,attack)
    else
        self._module.battleManager:RemoveFromeBattleRelation(self,ctrl,attack)
    end
end

function TroopCtrl:ClearBattleRelation()
    self._module.battleManager:ClearBattleRelation(self)
end

function TroopCtrl:IsVisible()
    local data = self:GetData()
    local owner = data.Owner
    local hideOnMap = SlgUtils.IsTroopHideOnMap(data)
    local myPlayerId = self._module:MySelf().ID
    local myAllianceId = ModuleRefer.AllianceModule:GetAllianceId()
    local exclusiveToMe = owner.ExclusivePlayerId ~= 0 and owner.ExclusivePlayerId == myPlayerId --当前玩家独占
    local exclusiveToMyAlliance = owner.ExclusiveAllianceId ~= 0 and owner.ExclusiveAllianceId == myAllianceId --当前玩家所在联盟独占

    return not hideOnMap and
        ((owner.ExclusivePlayerId == 0 and owner.ExclusiveAllianceId == 0) or
        exclusiveToMe or
        (not exclusiveToMe and data.MapStates.Battling) or
        (not exclusiveToMe and SlgUtils.DoesMobHaveRallyInfo(data, myAllianceId)) or
        exclusiveToMyAlliance)
end

function TroopCtrl:IsOthersTroop()
    return (self._data.Owner.ExclusivePlayerId ~= 0 and self._data.Owner.ExclusivePlayerId ~= self._module:MySelf().ID)
end

--同联盟的可显示
function TroopCtrl:IsSameAlliance()
    local myAllianceId = ModuleRefer.AllianceModule:GetAllianceId()
    return self._data.Owner.ExclusiveAllianceId ~= 0 and self._data.Owner.ExclusiveAllianceId == myAllianceId 
end

function TroopCtrl:TickInWatchList()
end

function TroopCtrl:OnExeSkill(skillIds)
end

function TroopCtrl:SetAsFocusBoss()
end

return TroopCtrl