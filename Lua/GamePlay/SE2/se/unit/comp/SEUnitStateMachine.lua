---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by BE.Tenner.
--- DateTime: 2021/7/15 10:09
---
--- 单位状态机组件

local SEUnitComponent = require("SEUnitComponent")
local SEUnitComponentType = require("SEUnitComponentType")
local SEUnitStateType = require("SEUnitStateType")
local SEUnitType = require("SEUnitType")
local ConfigRefer = require('ConfigRefer')
local SELogger = require("SELogger")
local Utils = require("Utils")

---@class SEUnitStateMachine:SEUnitComponent
local SEUnitStateMachine = class("SEUnitStateMachine",  SEUnitComponent);

local LAYER_BASE = 0
local LAYER_OVERRIDE_DOWN = 1
local LAYER_OVERRIDE_UP = 2
local DEFAULT_CROSSFADE_TIME = 0.2
local CATCH_PRIORITY = 998
local DEATH_PRIORITY = 999
--local Interrupt_PRIORITY = 500
local FLAG_NOT_MOVING = "not_moving"

---@param self SEUnitStateMachine
---@param unit SEUnit
---@return void
function SEUnitStateMachine:ctor(unit)
    SEUnitStateMachine.super.ctor(self, SEUnitComponentType.StateMachine, unit)
    self._currState = SEUnitStateType.Idle
    self._performPriority = {}
    self._performPriorityData = {}
    self._lastPlayedAnim = ""
    self._tweenslayerWeight = {}
    self._untilTimeToDeath = nil

    DEFAULT_CROSSFADE_TIME = ConfigRefer.ConstSe:SeUnitDefaultCrossFadeTime()
end

---@param self SEUnitStateMachine
---@return string
function SEUnitStateMachine:GetState()
    return self._currState
end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:Init()

end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:OnGameObjectCreated()
    self:SetLayerWeight(LAYER_OVERRIDE_UP, 1)
    self:SetLayerWeight(LAYER_OVERRIDE_DOWN, 1)
end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:Release()
    --self._loop = false
    self._currState = SEUnitStateType.Idle
end

---@param self SEUnitStateMachine
---@param layerIndex any
---@param weight any
---@param time any
---@return void
function SEUnitStateMachine:SetLayerWeight(layerIndex, weight, time)
    self:ClearLayerWeightTween(layerIndex)
    local animator = self:GetActor()._animator
	local realAnimator = self:GetActor()._animator
    if (not animator or not realAnimator) then
        SELogger.Trace("No animator bind to this unit %s", self._unit._id)
        return
    end
    if time == nil or time <= 0 then
        if layerIndex < animator.layerCount then
            animator:SetLayerWeight(layerIndex, weight)
        end
    else
        if layerIndex < animator.layerCount then
            self._tweenslayerWeight[layerIndex] = realAnimator:DOSetLayerWeight(layerIndex, weight, time)
        end
    end
end

---@param self SEUnitStateMachine
---@param layerIndex any
---@return void
function SEUnitStateMachine:ClearLayerWeightTween(layerIndex)
    local tween = self._tweenslayerWeight[layerIndex]
    if tween then
        if tween:IsActive() then
            tween:Kill()
        end
        self._tweenslayerWeight[layerIndex] = nil
    end
end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:OnStop()
    --self:SetPriority(0)
	if (self:GetActor():AnimatorHasParameter(FLAG_NOT_MOVING)) then
		local animator = self:GetActor()._animator
		if (Utils.IsNotNull(animator)) then
			animator:SetBool(FLAG_NOT_MOVING, true)
		end
	end
	-- if (self._unit:GetType() == SEUnitType.Player) then
    --     self:GetEnvironment():GetPlayer():TryInteractInteractor()
    -- end
    self:OnIdle()
end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:OnMove()
    -- 定身检测
    if (self._unit:IsDominated() or self._unit:IsControl()) then
        return
    end

	if (self:GetActor():AnimatorHasParameter(FLAG_NOT_MOVING)) then
		local animator = self:GetActor()._animator
		if (Utils.IsNotNull(animator)) then
			animator:SetBool(FLAG_NOT_MOVING, false)
		end
	end

    self:SetPriority(0)
    local audio = self._unit:GetAudio()
    local utype = self._unit:GetType()
    if (utype == SEUnitType.Player or utype == SEUnitType.Hero) then
        if (self._unit:IsInvisible()) then
            self:ChangeState(SEUnitStateType.CrouchWalk, true)
            if (audio) then
                audio:StopRun()
                audio:PlayWalk()
            end
            return
        end
    end
    if (audio) then
        audio:StopWalk()
        audio:PlayRun()
    end

    local overrideAnim = nil
    if self:GetActor():IsPlayAttackMove() then
        local value = CS.TransformHelper.SubtractEulerAngleY(self:GetActor():GetForward(), self:GetActor():GetMoveForward());
        value = math.fmod(value, 360)
        if value < 0 then
            value = value + 360
        end
        self:GetActor()._animator:SetFloat("attack_move_rot", value)
        overrideAnim = "attack_move"
        self.inMoveAttack = true
    end
    self:ChangeState(SEUnitStateType.Run, true, false, overrideAnim)
end

---@param self SEUnitStateMachine
---@param force boolean
---@return void
function SEUnitStateMachine:OnIdle(force)
    if (self._unit:IsDead()) then
        SELogger.LogLow("OnIdle failed: unit %s is dead", self._unit._id)
        return
    end
    --if (not force and (self._currState == SEUnitStateType.Perform)) then
    --    return
    --end
    local priority = self:GetPriority()
    if not force and priority > 0 then
        return
    end
    local audio = self._unit:GetAudio()
    if (audio) then
        audio:StopRun()
        audio:StopWalk()
    end
    self:SetPriority(0)
    local utype = self._unit:GetType()
    if (utype == SEUnitType.Player or utype == SEUnitType.Hero) then
        if (self._unit:IsInvisible()) then
            self:ChangeState(SEUnitStateType.Crouch, true, force)
            return
        end
    end
    local overrideAnim = nil
    if self:GetActor():IsPlayAttackMove() then
        overrideAnim = "attack_idle"
        self.inMoveAttack = false
    end
    self:ChangeState(SEUnitStateType.Idle, true, force, overrideAnim)
end

---@param self SEUnitStateMachine
---@param data skillclient.data.Animation
---@param seqId boolean
---@return void
function SEUnitStateMachine:OnPerform(data, seqId)
    if (not data) then
        return false
    end

    local priority = self:GetPriority(data.Layer)
    if (data.Priority < priority) then
        return false
    end

    self:SetPriority(data.Priority, seqId, data.Layer)
    self:ChangeState(SEUnitStateType.Perform, false, true,
            data.AnimName, data.FadeTime, data.Layer)
    return true
end

---@param self SEUnitStateMachine
---@param data skillclient.data.Animation
---@param seqId any
---@param isCancel boolean
---@return void
function SEUnitStateMachine:OnPerformEnd(data, seqId, isCancel)
    local priority, priorityData = self:GetPriority(data.Layer)
    if data.Priority == priority and seqId == priorityData then
        self:SetPriority(0, nil, data.Layer)

        if isCancel then
            self:CancelPerformAnimation()
        end
    end
end

function SEUnitStateMachine:CancelPerformAnimation()
    self:GetActor()._animator:Play('skillcancel', LAYER_OVERRIDE_UP, 0)
end

---@param self SEUnitStateMachine
---@param priority any
---@param priorityData any
---@param layer any
---@return void
function SEUnitStateMachine:SetPriority(priority, priorityData, layer)
    layer = layer or LAYER_BASE
    self._performPriority[layer] = priority
    self._performPriorityData[layer] = priorityData
end

---@param self SEUnitStateMachine
---@param layer any
---@return void
function SEUnitStateMachine:GetPriority(layer)
    layer = layer or LAYER_BASE
    return self._performPriority[layer] or 0, self._performPriorityData[layer]
end

---@param self SEUnitStateMachine
---@param angleY any
---@return void
function SEUnitStateMachine:OnRot(angleY)
    local animator = self:GetActor()._animator
    animator:SetFloat("rot", angleY)
    animator:Play("rot", LAYER_OVERRIDE_DOWN, 0)
end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:OnUnlock()
    self:SetPriority(0)
    self:ChangeState(SEUnitStateType.Unlock, true)
end

---@param self SEUnitStateMachine
---@param override string
---@return void
function SEUnitStateMachine:OnPickUp(override)
    self:SetPriority(0)
    if (override and override ~= "") then
        self:ChangeState(override, false)
    else
        self:ChangeState(SEUnitStateType.Pickup)
    end
end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:OnAttack()
    self:SetPriority(0)
    self:ChangeState(SEUnitStateType.Attack, false)
    local audio = self._unit:GetAudio()
    if (audio) then
        audio:StopRun()
        audio:StopWalk()
    end
end

---@param self SEUnitStateMachine
---@return void
function SEUnitStateMachine:OnDead()
    self._untilTimeToDeath = nil
    self:SetPriority(DEATH_PRIORITY)

    -- 随机播放死亡动画
    local animName = SEUnitStateType.Death
    local config = self._unit:GetData():GetConfig()
    if (config and config:DeathAnimationLength() > 0) then
        if (config:DeathAnimationLength() == 1) then
            animName = config:DeathAnimation(1)
        else
            animName = config:DeathAnimation(math.random(1, config:DeathAnimationLength()))
        end
    end

    SELogger.LogLow("Play unit %s death animation [%s]", self._unit._id, animName)
    self:ChangeState(animName, false, true, nil, 0)

    self:SetPriority(DEATH_PRIORITY, nil, LAYER_OVERRIDE_UP)
    self:SetLayerWeight(LAYER_OVERRIDE_UP, 0, DEFAULT_CROSSFADE_TIME)
    self:SetPriority(DEATH_PRIORITY, nil, LAYER_OVERRIDE_DOWN)
    self:SetLayerWeight(LAYER_OVERRIDE_DOWN, 0, DEFAULT_CROSSFADE_TIME)
end

function SEUnitStateMachine:OnCanCatch(untilTimeToDeath)
    self._untilTimeToDeath = untilTimeToDeath
    self:SetPriority(CATCH_PRIORITY)
    self:SetPriority(CATCH_PRIORITY, nil, LAYER_OVERRIDE_UP)
    self:SetLayerWeight(LAYER_OVERRIDE_UP, 0, DEFAULT_CROSSFADE_TIME)
    self:SetPriority(CATCH_PRIORITY, nil, LAYER_OVERRIDE_DOWN)
    self:SetLayerWeight(LAYER_OVERRIDE_DOWN, 0, DEFAULT_CROSSFADE_TIME)
end

---@param self SEUnitStateMachine
---@param state string
---@param loop boolean
---@param force boolean
---@param overrideAnim string
---@param fadeTime number
---@param layer number
---@return void
function SEUnitStateMachine:ChangeState(state, loop, force, overrideAnim, fadeTime, layer)
    if (self:GetActor() == nil) then
        SELogger.Trace("No actor bind to this state machine! unit id: %s, confId: %s",
        self._unit._id, self._unit:GetData():GetConfig():Id())
        return
    end

    if (self:GetActor()._animator == nil) then
        if (self._unit._init) then
            SELogger.Trace("No animator bind to this state machine! unit id: %s, confId: %s",
                self._unit._id, self._unit:GetData():GetConfig():Id())
        end
        return
    end

    if (not force and self._currState == state) then
        return
    end

    --SELogger.LogLow("Unit [%s] state change from [%s] to [%s]", self._unit._id, self._currState, state)

    if layer == nil then
        layer = LAYER_BASE
    end

    if layer == LAYER_BASE then
        self._currState = state
    end

    local anim = self._currState
    if (overrideAnim) then
        anim = overrideAnim
    end

    -- if fadeTime == nil then
    --     fadeTime = DEFAULT_CROSSFADE_TIME
    -- end

    --SkillLogger.LogAnim("id: %s, anim: %s", self._unit._id, anim)

    local animator = self:GetActor()._animator
    if layer < animator.layerCount then
        -- if fadeTime > 0 then
        --     animator:CrossFadeInFixedTime(anim, fadeTime, layer, 0, 0)
        -- else
			animator:Play(anim, layer, 0)
        --end
    end
    self._lastPlayedAnim = anim
end

---@param self SEUnitStateMachine
---@param delta number
---@return void
function SEUnitStateMachine:Update(delta, nowTime)
    if self._untilTimeToDeath then
        if  self._untilTimeToDeath <= nowTime then
            self:OnDead()
            return
        end 
    end
    local actor = self:GetActor()
    if actor == nil then
        return
    end

    local animator = actor._animator
    if (Utils.IsNull(animator)) then
        return
    end

    local inTransition, loop, normalizedTime = CS.AnimatorHelper.GetCurrentAnimatorState(animator, LAYER_BASE)
    if (not inTransition) then
        if not loop and normalizedTime >= 1 then
            self:OnIdle(true)
        end
    end

    if actor:IsPlayAttackMove() and self.inMoveAttack then
        local value = CS.TransformHelper.SubtractEulerAngleY(actor:GetForward(), actor:GetMoveForward());
        value = math.fmod(value, 360)
        if value < 0 then
            value = value + 360
        end
        animator:SetFloat("attack_move_rot", value)
    end
end

---@param self SEUnitStateMachine
---@param speed number
---@return void
function SEUnitStateMachine:MultiplyAnimatorSpeed(speed)
    local actor = self:GetActor()
    if (actor == nil) then
        return
    end
    local animator = actor._animator
	if (Utils.IsNull(animator)) then return end
	-- local layerMixer = actor:GetLayerMixer()
	-- if (Utils.IsNull(layerMixer)) then return end
	-- local s = animator:GetSpeedForLayerMixer(layerMixer)
	-- animator:SetSpeedForLayerMixer(layerMixer, s * speed)
    animator.speed = animator.speed * speed
end

---@param self SEUnitStateMachine
---@param state number
---@param speed any
---@return void
function SEUnitStateMachine:MultiplyAnimatorStateSpeed(state, speed)
    local actor = self:GetActor()
    if (actor == nil) then
        return
    end
    local animator = actor._animator
	if (Utils.IsNull(animator)) then return end
	
	local stateInfo = animator:GetCurrentAnimatorStateInfo(0)
    if stateInfo == nil then
        return
    end
    if not stateInfo:IsName(state) then
        return
    end
    stateInfo.speed = stateInfo.speed * speed
    return stateInfo
end

return SEUnitStateMachine
