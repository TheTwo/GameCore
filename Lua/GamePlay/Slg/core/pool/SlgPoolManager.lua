---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wupei.
--- DateTime: 2020/11/18
---

local SlgPoolObject = require("SlgPoolObject")
local TimerUtility = require('TimerUtility')
local Delegate = require('Delegate')
local Utils = require('Utils')
---@class SlgPoolManager
local SlgPoolManager = class('SlgPoolManager')

---@type SlgPoolManager
local _instance

---@return SlgPoolManager
function SlgPoolManager.CreateInstance()
    if _instance == nil then
        _instance = SlgPoolManager.new()
    else
        g_Logger.Error("SlgPoolManager.CreateInstance repeated.")
    end
    return _instance
end

function SlgPoolManager.DestroyInstance()
    if _instance then
        _instance:OnDestroy()
        _instance = nil
    else
        g_Logger.Error("SlgPoolManager.DestroyInstance error. _instance = nil")
    end
end

---@return SlgPoolManager
function SlgPoolManager.GetInstance()
    return _instance
end

---@protected
function SlgPoolManager:ctor()
    local luaPoolGo = CS.UnityEngine.GameObject("KingdomUnitPool")
    CS.UnityEngine.GameObject.DontDestroyOnLoad(luaPoolGo)
    self._trans = luaPoolGo.transform
    self._pools = {}
    -- self._useds = {}
    ---@type table<SlgPoolObject, boolean>
    self._willDespawnObjs = {}   
    self._module = require('ModuleRefer').SlgModule
end

function SlgPoolManager:OnDestroy()
    CS.UnityEngine.GameObject.Destroy(self._trans.gameObject)
    if self.createHelper then
        self.createHelper:CancelAllCreate()
    end
    self._trans = nil
    self._pools = nil
end

---@return CS.UnityEngine.Transform
function SlgPoolManager:GetTrans()
    return self._trans
end

---@param bundleName string
---@param callback fun(obj:SlgPoolObject)
---@param poolObj SlgPoolObject
function SlgPoolManager:SpawnAsync(bundleName, callback, poolObj)
    local pool = self._pools[bundleName]
    if pool and #pool > 0 then
        --local trans = pool:PopBack()
        local trans = table.remove(pool)
        self:_ExecuteCallback(bundleName, trans, callback, poolObj)
    else
        if not self.createHelper then 
            self.createHelper = CS.DragonReborn.AssetTool.GameObjectCreateHelper.Create();
        end
        -- if bundleName == 'lod_view_troop' then
        --     g_Logger.LogChannel('TTTDbug','Start Create:' .. bundleName)
        -- end
        self.createHelper:Create(bundleName, self._trans, function (go,data)
             --防止异步加载后，已经关闭Slg场景了
            if  not self._module or not self._module.curScene then
                return
            end
            if go == nil then
                g_Logger.Log("[SlgPoolManager] create failed! BundleName:" .. bundleName)
                self:_ExecuteCallback(bundleName, nil, callback, poolObj)
            else
                self:_ExecuteCallback(bundleName, go.transform, callback, poolObj)
            end
        end)
        -- if bundleName == 'lod_view_troop' then 
        --     g_Logger.LogChannel('TTTDbug','End Create:' .. bundleName)
        -- end
    end
end


function SlgPoolManager:_ExecuteCallback(bundleName, trans, callback, poolObj)   
    if not trans then
        --TryCatch(callback)
        --try_catch(function()
            if callback then
                callback()
            end
        --end,nil)
        return nil
    end
   
    if trans.parent ~= self._trans then
        trans:SetParent(self._trans, false)
    end
    trans.gameObject:SetActive(true)
    if poolObj == nil then
        poolObj = SlgPoolObject.new()
    end
    poolObj:DoOnSpawn(trans, bundleName)
    --TryCatch(callback, poolObj)
    --try_catch(function()
        if callback then
            callback(poolObj)
        end
    --end,nil)
    return poolObj
end

---@param obj SlgPoolObject
function SlgPoolManager:Despawn(obj, time)
    
    if time == nil or time <= 0 then
        if obj._isSpawned then
            self:_DoDespawn(obj)
        else
            if obj._isSpawning then
                self._willDespawnObjs[obj] = true
                if not self._timerProcessDepawnObjs then
                    self._timerProcessDepawnObjs = TimerUtility.StartFrameTimer(Delegate.GetOrCreate(self,self.ProcessDepawnObjs),0.2,-1)
                end
            end
        end
    else
        TimerUtility.DelayExecute(function()
            self:Despawn(obj,0)
        end,time)
    end
end

function SlgPoolManager:_DoDespawn(obj)
    local bundleName = obj.bundleName
    local trans = obj.trans:get_transform()

    if Utils.IsNull(trans) then --已经destroy的transform不回对象池
        return
    end

    obj:DoOnDespawn()

    --local used = self._useds[bundleName]
    --if used then
    --    used:Remove(trans)
    --end

    local pool = self._pools[bundleName]
    if not pool then
        pool = {}
        self._pools[bundleName] = pool
    end
    trans.gameObject:SetActive(false)
    if trans.parent ~= self._trans then
        trans:SetParent(self._trans, false)
    end
    table.insert(pool,trans)
end

function SlgPoolManager:ProcessDepawnObjs()
    local count = 0
    for obj, _ in pairs(self._willDespawnObjs) do
        if obj._isSpawned then
            self:_DoDespawn(obj)
            self._willDespawnObjs[obj] = nil
        else
            count = count + 1
        end
    end
    if count <= 0 then
        TimerUtility.StopAndRecycle(self._timerProcessDepawnObjs)
        self._timerProcessDepawnObjs = nil
        return false
    end
end

return SlgPoolManager